Require Import Coq.NArith.BinNat Coq.Reals.Reals HOLLight_Real_With_N.mappings HOLLight.With_N.
Definition _FALSITY_ : Prop := False.
Lemma _FALSITY__def : _FALSITY_ = False.
Proof. exact (eq_refl _FALSITY_). Qed.
Lemma COND_def {A : Type'} : (@COND A) = (fun t : Prop => fun t1 : A => fun t2 : A => @ε A (fun x : A => ((t = True) -> x = t1) /\ ((t = False) -> x = t2))).
Proof. exact (eq_refl (@COND A)). Qed.
Definition o {A B C : Type'} : (B -> C) -> (A -> B) -> A -> C := fun f : B -> C => fun g : A -> B => fun x : A => f (g x).
Lemma o_def {A B C : Type'} : (@o A B C) = (fun f : B -> C => fun g : A -> B => fun x : A => f (g x)).
Proof. exact (eq_refl (@o A B C)). Qed.
Definition I {A : Type'} : A -> A := fun x : A => x.
Lemma I_def {A : Type'} : (@I A) = (fun x : A => x).
Proof. exact (eq_refl (@I A)). Qed.
Definition hashek : Prop := True.
Lemma hashek_def : hashek = True.
Proof. exact (eq_refl hashek). Qed.
Definition LET {A B : Type'} : (A -> B) -> A -> B := fun f : A -> B => fun x : A => f x.
Lemma LET_def {A B : Type'} : (@LET A B) = (fun f : A -> B => fun x : A => f x).
Proof. exact (eq_refl (@LET A B)). Qed.
Definition LET_END {A : Type'} : A -> A := fun t : A => t.
Lemma LET_END_def {A : Type'} : (@LET_END A) = (fun t : A => t).
Proof. exact (eq_refl (@LET_END A)). Qed.
Definition GABS {A : Type'} : (A -> Prop) -> A := fun P : A -> Prop => @ε A P.
Lemma GABS_def {A : Type'} : (@GABS A) = (fun P : A -> Prop => @ε A P).
Proof. exact (eq_refl (@GABS A)). Qed.
Definition GEQ {A : Type'} : A -> A -> Prop := fun a : A => fun b : A => a = b.
Lemma GEQ_def {A : Type'} : (@GEQ A) = (fun a : A => fun b : A => a = b).
Proof. exact (eq_refl (@GEQ A)). Qed.
Definition _SEQPATTERN {A B : Type'} : (A -> B -> Prop) -> (A -> B -> Prop) -> A -> B -> Prop := fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x).
Lemma _SEQPATTERN_def {A B : Type'} : (@_SEQPATTERN A B) = (fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x)).
Proof. exact (eq_refl (@_SEQPATTERN A B)). Qed.
Definition _UNGUARDED_PATTERN : Prop -> Prop -> Prop := fun p : Prop => fun r : Prop => p /\ r.
Lemma _UNGUARDED_PATTERN_def : _UNGUARDED_PATTERN = (fun p : Prop => fun r : Prop => p /\ r).
Proof. exact (eq_refl _UNGUARDED_PATTERN). Qed.
Definition _GUARDED_PATTERN : Prop -> Prop -> Prop -> Prop := fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r).
Lemma _GUARDED_PATTERN_def : _GUARDED_PATTERN = (fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r)).
Proof. exact (eq_refl _GUARDED_PATTERN). Qed.
Definition _MATCH {A B : Type'} : A -> (A -> B -> Prop) -> B := fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False)).
Lemma _MATCH_def {A B : Type'} : (@_MATCH A B) = (fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False))).
Proof. exact (eq_refl (@_MATCH A B)). Qed.
Definition _FUNCTION {A B : Type'} : (A -> B -> Prop) -> A -> B := fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False)).
Lemma _FUNCTION_def {A B : Type'} : (@_FUNCTION A B) = (fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False))).
Proof. exact (eq_refl (@_FUNCTION A B)). Qed.
Lemma mk_pair_def {A B : Type'} : (@mk_pair A B) = (fun x : A => fun y : B => fun a : A => fun b : B => (a = x) /\ (b = y)).
Proof. exact (eq_refl (@mk_pair A B)). Qed.
Definition CURRY {A B C : Type'} : ((prod A B) -> C) -> A -> B -> C := fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285).
Lemma CURRY_def {A B C : Type'} : (@CURRY A B C) = (fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285)).
Proof. exact (eq_refl (@CURRY A B C)). Qed.
Definition UNCURRY {A B C : Type'} : (A -> B -> C) -> (prod A B) -> C := fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305).
Lemma UNCURRY_def {A B C : Type'} : (@UNCURRY A B C) = (fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305)).
Proof. exact (eq_refl (@UNCURRY A B C)). Qed.
Definition PASSOC {A B C D : Type'} : ((prod (prod A B) C) -> D) -> (prod A (prod B C)) -> D := fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322))).
Lemma PASSOC_def {A B C D : Type'} : (@PASSOC A B C D) = (fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322)))).
Proof. exact (eq_refl (@PASSOC A B C D)). Qed.
Lemma ONE_ONE_def {A B : Type'} : (@ONE_ONE A B) = (fun _2064 : A -> B => forall x1 : A, forall x2 : A, ((_2064 x1) = (_2064 x2)) -> x1 = x2).
Proof. exact (eq_refl (@ONE_ONE A B)). Qed.
Lemma ONTO_def {A B : Type'} : (@ONTO A B) = (fun _2069 : A -> B => forall y : B, exists x : A, y = (_2069 x)).
Proof. exact (eq_refl (@ONTO A B)). Qed.
Lemma IND_SUC_def : IND_SUC = (@ε (ind -> ind) (fun f : ind -> ind => exists z : ind, (forall x1 : ind, forall x2 : ind, ((f x1) = (f x2)) = (x1 = x2)) /\ (forall x : ind, ~ ((f x) = z)))).
Proof. exact (eq_refl IND_SUC). Qed.
Lemma IND_0_def : IND_0 = (@ε ind (fun z : ind => (forall x1 : ind, forall x2 : ind, ((IND_SUC x1) = (IND_SUC x2)) = (x1 = x2)) /\ (forall x : ind, ~ ((IND_SUC x) = z)))).
Proof. exact (eq_refl IND_0). Qed.
Lemma NUM_REP_def : NUM_REP = (fun a : ind => forall NUM_REP' : ind -> Prop, (forall a' : ind, ((a' = IND_0) \/ (exists i : ind, (a' = (IND_SUC i)) /\ (NUM_REP' i))) -> NUM_REP' a') -> NUM_REP' a).
Proof. exact (eq_refl NUM_REP). Qed.
Definition NUMERAL : N -> N := fun _2128 : N => _2128.
Lemma NUMERAL_def : NUMERAL = (fun _2128 : N => _2128).
Proof. exact (eq_refl NUMERAL). Qed.
Lemma BIT1_def : BIT1 = (fun _2143 : N => N.succ (BIT0 _2143)).
Proof. exact (eq_refl BIT1). Qed.
Definition EVEN : N -> Prop := @ε ((prod N (prod N (prod N N))) -> N -> Prop) (fun EVEN' : (prod N (prod N (prod N N))) -> N -> Prop => forall _2603 : prod N (prod N (prod N N)), ((EVEN' _2603 (NUMERAL 0%N)) = True) /\ (forall n : N, (EVEN' _2603 (N.succ n)) = (~ (EVEN' _2603 n)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N))))))))))).
Lemma EVEN_def : EVEN = (@ε ((prod N (prod N (prod N N))) -> N -> Prop) (fun EVEN' : (prod N (prod N (prod N N))) -> N -> Prop => forall _2603 : prod N (prod N (prod N N)), ((EVEN' _2603 (NUMERAL 0%N)) = True) /\ (forall n : N, (EVEN' _2603 (N.succ n)) = (~ (EVEN' _2603 n)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl EVEN). Qed.
Definition ODD : N -> Prop := @ε ((prod N (prod N N)) -> N -> Prop) (fun ODD' : (prod N (prod N N)) -> N -> Prop => forall _2607 : prod N (prod N N), ((ODD' _2607 (NUMERAL 0%N)) = False) /\ (forall n : N, (ODD' _2607 (N.succ n)) = (~ (ODD' _2607 n)))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))))).
Lemma ODD_def : ODD = (@ε ((prod N (prod N N)) -> N -> Prop) (fun ODD' : (prod N (prod N N)) -> N -> Prop => forall _2607 : prod N (prod N N), ((ODD' _2607 (NUMERAL 0%N)) = False) /\ (forall n : N, (ODD' _2607 (N.succ n)) = (~ (ODD' _2607 n)))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N))))))))))).
Proof. exact (eq_refl ODD). Qed.
Definition FACT : N -> N := @ε ((prod N (prod N (prod N N))) -> N -> N) (fun FACT' : (prod N (prod N (prod N N))) -> N -> N => forall _2944 : prod N (prod N (prod N N)), ((FACT' _2944 (NUMERAL 0%N)) = (NUMERAL (BIT1 0%N))) /\ (forall n : N, (FACT' _2944 (N.succ n)) = (N.mul (N.succ n) (FACT' _2944 n)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))).
Lemma FACT_def : FACT = (@ε ((prod N (prod N (prod N N))) -> N -> N) (fun FACT' : (prod N (prod N (prod N N))) -> N -> N => forall _2944 : prod N (prod N (prod N N)), ((FACT' _2944 (NUMERAL 0%N)) = (NUMERAL (BIT1 0%N))) /\ (forall n : N, (FACT' _2944 (N.succ n)) = (N.mul (N.succ n) (FACT' _2944 n)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl FACT). Qed.
Definition minimal : (N -> Prop) -> N := fun _6536 : N -> Prop => @ε N (fun n : N => (_6536 n) /\ (forall m : N, (N.lt m n) -> ~ (_6536 m))).
Lemma minimal_def : minimal = (fun _6536 : N -> Prop => @ε N (fun n : N => (_6536 n) /\ (forall m : N, (N.lt m n) -> ~ (_6536 m)))).
Proof. exact (eq_refl minimal). Qed.
Definition WF {A : Type'} : (A -> A -> Prop) -> Prop := fun _6923 : A -> A -> Prop => forall P : A -> Prop, (exists x : A, P x) -> exists x : A, (P x) /\ (forall y : A, (_6923 y x) -> ~ (P y)).
Lemma WF_def {A : Type'} : (@WF A) = (fun _6923 : A -> A -> Prop => forall P : A -> Prop, (exists x : A, P x) -> exists x : A, (P x) /\ (forall y : A, (_6923 y x) -> ~ (P y))).
Proof. exact (eq_refl (@WF A)). Qed.
Definition MEASURE {A : Type'} : (A -> N) -> A -> A -> Prop := fun _8094 : A -> N => fun x : A => fun y : A => N.lt (_8094 x) (_8094 y).
Lemma MEASURE_def {A : Type'} : (@MEASURE A) = (fun _8094 : A -> N => fun x : A => fun y : A => N.lt (_8094 x) (_8094 y)).
Proof. exact (eq_refl (@MEASURE A)). Qed.
Definition NUMPAIR : N -> N -> N := fun _17487 : N => fun _17488 : N => N.mul (N.pow (NUMERAL (BIT0 (BIT1 0%N))) _17487) (N.add (N.mul (NUMERAL (BIT0 (BIT1 0%N))) _17488) (NUMERAL (BIT1 0%N))).
Lemma NUMPAIR_def : NUMPAIR = (fun _17487 : N => fun _17488 : N => N.mul (N.pow (NUMERAL (BIT0 (BIT1 0%N))) _17487) (N.add (N.mul (NUMERAL (BIT0 (BIT1 0%N))) _17488) (NUMERAL (BIT1 0%N)))).
Proof. exact (eq_refl NUMPAIR). Qed.
Definition NUMFST : N -> N := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> N) (fun X : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> N => forall _17503 : prod N (prod N (prod N (prod N (prod N N)))), exists Y : N -> N, forall x : N, forall y : N, ((X _17503 (NUMPAIR x y)) = x) /\ ((Y (NUMPAIR x y)) = y)) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))))).
Lemma NUMFST_def : NUMFST = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> N) (fun X : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> N => forall _17503 : prod N (prod N (prod N (prod N (prod N N)))), exists Y : N -> N, forall x : N, forall y : N, ((X _17503 (NUMPAIR x y)) = x) /\ ((Y (NUMPAIR x y)) = y)) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl NUMFST). Qed.
Definition NUMSND : N -> N := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> N) (fun Y : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> N => forall _17504 : prod N (prod N (prod N (prod N (prod N N)))), forall x : N, forall y : N, ((NUMFST (NUMPAIR x y)) = x) /\ ((Y _17504 (NUMPAIR x y)) = y)) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N))))))))))))).
Lemma NUMSND_def : NUMSND = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> N -> N) (fun Y : (prod N (prod N (prod N (prod N (prod N N))))) -> N -> N => forall _17504 : prod N (prod N (prod N (prod N (prod N N)))), forall x : N, forall y : N, ((NUMFST (NUMPAIR x y)) = x) /\ ((Y _17504 (NUMPAIR x y)) = y)) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl NUMSND). Qed.
Definition NUMSUM : Prop -> N -> N := fun _17505 : Prop => fun _17506 : N => @COND N _17505 (N.succ (N.mul (NUMERAL (BIT0 (BIT1 0%N))) _17506)) (N.mul (NUMERAL (BIT0 (BIT1 0%N))) _17506).
Lemma NUMSUM_def : NUMSUM = (fun _17505 : Prop => fun _17506 : N => @COND N _17505 (N.succ (N.mul (NUMERAL (BIT0 (BIT1 0%N))) _17506)) (N.mul (NUMERAL (BIT0 (BIT1 0%N))) _17506)).
Proof. exact (eq_refl NUMSUM). Qed.
Definition INJN {A : Type'} : N -> N -> A -> Prop := fun _17537 : N => fun n : N => fun a : A => n = _17537.
Lemma INJN_def {A : Type'} : (@INJN A) = (fun _17537 : N => fun n : N => fun a : A => n = _17537).
Proof. exact (eq_refl (@INJN A)). Qed.
Definition INJA {A : Type'} : A -> N -> A -> Prop := fun _17542 : A => fun n : N => fun b : A => b = _17542.
Lemma INJA_def {A : Type'} : (@INJA A) = (fun _17542 : A => fun n : N => fun b : A => b = _17542).
Proof. exact (eq_refl (@INJA A)). Qed.
Definition INJF {A : Type'} : (N -> N -> A -> Prop) -> N -> A -> Prop := fun _17549 : N -> N -> A -> Prop => fun n : N => _17549 (NUMFST n) (NUMSND n).
Lemma INJF_def {A : Type'} : (@INJF A) = (fun _17549 : N -> N -> A -> Prop => fun n : N => _17549 (NUMFST n) (NUMSND n)).
Proof. exact (eq_refl (@INJF A)). Qed.
Definition INJP {A : Type'} : (N -> A -> Prop) -> (N -> A -> Prop) -> N -> A -> Prop := fun _17554 : N -> A -> Prop => fun _17555 : N -> A -> Prop => fun n : N => fun a : A => @COND Prop (NUMLEFT n) (_17554 (NUMRIGHT n) a) (_17555 (NUMRIGHT n) a).
Lemma INJP_def {A : Type'} : (@INJP A) = (fun _17554 : N -> A -> Prop => fun _17555 : N -> A -> Prop => fun n : N => fun a : A => @COND Prop (NUMLEFT n) (_17554 (NUMRIGHT n) a) (_17555 (NUMRIGHT n) a)).
Proof. exact (eq_refl (@INJP A)). Qed.
Definition ZCONSTR {A : Type'} : N -> A -> (N -> N -> A -> Prop) -> N -> A -> Prop := fun _17566 : N => fun _17567 : A => fun _17568 : N -> N -> A -> Prop => @INJP A (@INJN A (N.succ _17566)) (@INJP A (@INJA A _17567) (@INJF A _17568)).
Lemma ZCONSTR_def {A : Type'} : (@ZCONSTR A) = (fun _17566 : N => fun _17567 : A => fun _17568 : N -> N -> A -> Prop => @INJP A (@INJN A (N.succ _17566)) (@INJP A (@INJA A _17567) (@INJF A _17568))).
Proof. exact (eq_refl (@ZCONSTR A)). Qed.
Definition ZBOT {A : Type'} : N -> A -> Prop := @INJP A (@INJN A (NUMERAL 0%N)) (@ε (N -> A -> Prop) (fun z : N -> A -> Prop => True)).
Lemma ZBOT_def {A : Type'} : (@ZBOT A) = (@INJP A (@INJN A (NUMERAL 0%N)) (@ε (N -> A -> Prop) (fun z : N -> A -> Prop => True))).
Proof. exact (eq_refl (@ZBOT A)). Qed.
Definition BOTTOM {A : Type'} : recspace A := @_mk_rec A (@ZBOT A).
Lemma BOTTOM_def {A : Type'} : (@BOTTOM A) = (@_mk_rec A (@ZBOT A)).
Proof. exact (eq_refl (@BOTTOM A)). Qed.
Definition CONSTR {A : Type'} : N -> A -> (N -> recspace A) -> recspace A := fun _17591 : N => fun _17592 : A => fun _17593 : N -> recspace A => @_mk_rec A (@ZCONSTR A _17591 _17592 (fun n : N => @_dest_rec A (_17593 n))).
Lemma CONSTR_def {A : Type'} : (@CONSTR A) = (fun _17591 : N => fun _17592 : A => fun _17593 : N -> recspace A => @_mk_rec A (@ZCONSTR A _17591 _17592 (fun n : N => @_dest_rec A (_17593 n)))).
Proof. exact (eq_refl (@CONSTR A)). Qed.
Definition FNIL {A : Type'} : N -> A := fun _17624 : N => @ε A (fun x : A => True).
Lemma FNIL_def {A : Type'} : (@FNIL A) = (fun _17624 : N => @ε A (fun x : A => True)).
Proof. exact (eq_refl (@FNIL A)). Qed.
Definition OUTL {A B : Type'} : (Datatypes.sum A B) -> A := @ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A => forall _17649 : prod N (prod N (prod N N)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N))))))))))).
Lemma OUTL_def {A B : Type'} : (@OUTL A B) = (@ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> A => forall _17649 : prod N (prod N (prod N N)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl (@OUTL A B)). Qed.
Definition OUTR {A B : Type'} : (Datatypes.sum A B) -> B := @ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B => forall _17651 : prod N (prod N (prod N N)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))).
Lemma OUTR_def {A B : Type'} : (@OUTR A B) = (@ε ((prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod N (prod N (prod N N))) -> (Datatypes.sum A B) -> B => forall _17651 : prod N (prod N (prod N N)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl (@OUTR A B)). Qed.
Definition LENGTH {A : Type'} : (list A) -> N := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (list A) -> N) (fun LENGTH' : (prod N (prod N (prod N (prod N (prod N N))))) -> (list A) -> N => forall _18106 : prod N (prod N (prod N (prod N (prod N N)))), ((LENGTH' _18106 (@nil A)) = (NUMERAL 0%N)) /\ (forall h : A, forall t : list A, (LENGTH' _18106 (@cons A h t)) = (N.succ (LENGTH' _18106 t)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N))))))))))))).
Lemma LENGTH_def {A : Type'} : (@LENGTH A) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (list A) -> N) (fun LENGTH' : (prod N (prod N (prod N (prod N (prod N N))))) -> (list A) -> N => forall _18106 : prod N (prod N (prod N (prod N (prod N N)))), ((LENGTH' _18106 (@nil A)) = (NUMERAL 0%N)) /\ (forall h : A, forall t : list A, (LENGTH' _18106 (@cons A h t)) = (N.succ (LENGTH' _18106 t)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl (@LENGTH A)). Qed.
Definition LAST {A : Type'} : (list A) -> A := @ε ((prod N (prod N (prod N N))) -> (list A) -> A) (fun LAST' : (prod N (prod N (prod N N))) -> (list A) -> A => forall _18117 : prod N (prod N (prod N N)), forall h : A, forall t : list A, (LAST' _18117 (@cons A h t)) = (@COND A (t = (@nil A)) h (LAST' _18117 t))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))).
Lemma LAST_def {A : Type'} : (@LAST A) = (@ε ((prod N (prod N (prod N N))) -> (list A) -> A) (fun LAST' : (prod N (prod N (prod N N))) -> (list A) -> A => forall _18117 : prod N (prod N (prod N N)), forall h : A, forall t : list A, (LAST' _18117 (@cons A h t)) = (@COND A (t = (@nil A)) h (LAST' _18117 t))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl (@LAST A)). Qed.
Definition REPLICATE {A : Type'} : N -> A -> list A := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> A -> list A) (fun REPLICATE' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> A -> list A => forall _18125 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall x : A, (REPLICATE' _18125 (NUMERAL 0%N) x) = (@nil A)) /\ (forall n : N, forall x : A, (REPLICATE' _18125 (N.succ n) x) = (@cons A x (REPLICATE' _18125 n x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))))))))))).
Lemma REPLICATE_def {A : Type'} : (@REPLICATE A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> A -> list A) (fun REPLICATE' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> A -> list A => forall _18125 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall x : A, (REPLICATE' _18125 (NUMERAL 0%N) x) = (@nil A)) /\ (forall n : N, forall x : A, (REPLICATE' _18125 (N.succ n) x) = (@cons A x (REPLICATE' _18125 n x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N))))))))))))))))).
Proof. exact (eq_refl (@REPLICATE A)). Qed.
Definition NULL {A : Type'} : (list A) -> Prop := @ε ((prod N (prod N (prod N N))) -> (list A) -> Prop) (fun NULL' : (prod N (prod N (prod N N))) -> (list A) -> Prop => forall _18129 : prod N (prod N (prod N N)), ((NULL' _18129 (@nil A)) = True) /\ (forall h : A, forall t : list A, (NULL' _18129 (@cons A h t)) = False)) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N))))))))))).
Lemma NULL_def {A : Type'} : (@NULL A) = (@ε ((prod N (prod N (prod N N))) -> (list A) -> Prop) (fun NULL' : (prod N (prod N (prod N N))) -> (list A) -> Prop => forall _18129 : prod N (prod N (prod N N)), ((NULL' _18129 (@nil A)) = True) /\ (forall h : A, forall t : list A, (NULL' _18129 (@cons A h t)) = False)) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl (@NULL A)). Qed.
Definition EX {A : Type'} : (A -> Prop) -> (list A) -> Prop := @ε ((prod N N) -> (A -> Prop) -> (list A) -> Prop) (fun EX' : (prod N N) -> (A -> Prop) -> (list A) -> Prop => forall _18143 : prod N N, (forall P : A -> Prop, (EX' _18143 P (@nil A)) = False) /\ (forall h : A, forall P : A -> Prop, forall t : list A, (EX' _18143 P (@cons A h t)) = ((P h) \/ (EX' _18143 P t)))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0%N))))))))).
Lemma EX_def {A : Type'} : (@EX A) = (@ε ((prod N N) -> (A -> Prop) -> (list A) -> Prop) (fun EX' : (prod N N) -> (A -> Prop) -> (list A) -> Prop => forall _18143 : prod N N, (forall P : A -> Prop, (EX' _18143 P (@nil A)) = False) /\ (forall h : A, forall P : A -> Prop, forall t : list A, (EX' _18143 P (@cons A h t)) = ((P h) \/ (EX' _18143 P t)))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))))).
Proof. exact (eq_refl (@EX A)). Qed.
Definition ITLIST {A B : Type'} : (A -> B -> B) -> (list A) -> B -> B := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> (list A) -> B -> B) (fun ITLIST' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> (list A) -> B -> B => forall _18151 : prod N (prod N (prod N (prod N (prod N N)))), (forall f : A -> B -> B, forall b : B, (ITLIST' _18151 f (@nil A) b) = b) /\ (forall h : A, forall f : A -> B -> B, forall t : list A, forall b : B, (ITLIST' _18151 f (@cons A h t) b) = (f h (ITLIST' _18151 f t b)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))))).
Lemma ITLIST_def {A B : Type'} : (@ITLIST A B) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> (list A) -> B -> B) (fun ITLIST' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> (list A) -> B -> B => forall _18151 : prod N (prod N (prod N (prod N (prod N N)))), (forall f : A -> B -> B, forall b : B, (ITLIST' _18151 f (@nil A) b) = b) /\ (forall h : A, forall f : A -> B -> B, forall t : list A, forall b : B, (ITLIST' _18151 f (@cons A h t) b) = (f h (ITLIST' _18151 f t b)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl (@ITLIST A B)). Qed.
Definition ALL2 {A B : Type'} : (A -> B -> Prop) -> (list A) -> (list B) -> Prop := @ε ((prod N (prod N (prod N N))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop) (fun ALL2' : (prod N (prod N (prod N N))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop => forall _18166 : prod N (prod N (prod N N)), (forall P : A -> B -> Prop, forall l2 : list B, (ALL2' _18166 P (@nil A) l2) = (l2 = (@nil B))) /\ (forall h1' : A, forall P : A -> B -> Prop, forall t1 : list A, forall l2 : list B, (ALL2' _18166 P (@cons A h1' t1) l2) = (@COND Prop (l2 = (@nil B)) False ((P h1' (@hd B l2)) /\ (ALL2' _18166 P t1 (@tl B l2)))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))).
Lemma ALL2_def {A B : Type'} : (@ALL2 A B) = (@ε ((prod N (prod N (prod N N))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop) (fun ALL2' : (prod N (prod N (prod N N))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop => forall _18166 : prod N (prod N (prod N N)), (forall P : A -> B -> Prop, forall l2 : list B, (ALL2' _18166 P (@nil A) l2) = (l2 = (@nil B))) /\ (forall h1' : A, forall P : A -> B -> Prop, forall t1 : list A, forall l2 : list B, (ALL2' _18166 P (@cons A h1' t1) l2) = (@COND Prop (l2 = (@nil B)) False ((P h1' (@hd B l2)) /\ (ALL2' _18166 P t1 (@tl B l2)))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))).
Proof. exact (eq_refl (@ALL2 A B)). Qed.
Definition MAP2 {A B C : Type'} : (A -> B -> C) -> (list A) -> (list B) -> list C := @ε ((prod N (prod N (prod N N))) -> (A -> B -> C) -> (list A) -> (list B) -> list C) (fun MAP2' : (prod N (prod N (prod N N))) -> (A -> B -> C) -> (list A) -> (list B) -> list C => forall _18174 : prod N (prod N (prod N N)), (forall f : A -> B -> C, forall l : list B, (MAP2' _18174 f (@nil A) l) = (@nil C)) /\ (forall h1' : A, forall f : A -> B -> C, forall t1 : list A, forall l : list B, (MAP2' _18174 f (@cons A h1' t1) l) = (@cons C (f h1' (@hd B l)) (MAP2' _18174 f t1 (@tl B l))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))).
Lemma MAP2_def {A B C : Type'} : (@MAP2 A B C) = (@ε ((prod N (prod N (prod N N))) -> (A -> B -> C) -> (list A) -> (list B) -> list C) (fun MAP2' : (prod N (prod N (prod N N))) -> (A -> B -> C) -> (list A) -> (list B) -> list C => forall _18174 : prod N (prod N (prod N N)), (forall f : A -> B -> C, forall l : list B, (MAP2' _18174 f (@nil A) l) = (@nil C)) /\ (forall h1' : A, forall f : A -> B -> C, forall t1 : list A, forall l : list B, (MAP2' _18174 f (@cons A h1' t1) l) = (@cons C (f h1' (@hd B l)) (MAP2' _18174 f t1 (@tl B l))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))).
Proof. exact (eq_refl (@MAP2 A B C)). Qed.
Definition EL {A : Type'} : N -> (list A) -> A := @ε ((prod N N) -> N -> (list A) -> A) (fun EL' : (prod N N) -> N -> (list A) -> A => forall _18178 : prod N N, (forall l : list A, (EL' _18178 (NUMERAL 0%N) l) = (@hd A l)) /\ (forall n : N, forall l : list A, (EL' _18178 (N.succ n) l) = (EL' _18178 n (@tl A l)))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N))))))))).
Lemma EL_def {A : Type'} : (@EL A) = (@ε ((prod N N) -> N -> (list A) -> A) (fun EL' : (prod N N) -> N -> (list A) -> A => forall _18178 : prod N N, (forall l : list A, (EL' _18178 (NUMERAL 0%N) l) = (@hd A l)) /\ (forall n : N, forall l : list A, (EL' _18178 (N.succ n) l) = (EL' _18178 n (@tl A l)))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))))).
Proof. exact (eq_refl (@EL A)). Qed.
Definition FILTER {A : Type'} : (A -> Prop) -> (list A) -> list A := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> Prop) -> (list A) -> list A) (fun FILTER' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> Prop) -> (list A) -> list A => forall _18185 : prod N (prod N (prod N (prod N (prod N N)))), (forall P : A -> Prop, (FILTER' _18185 P (@nil A)) = (@nil A)) /\ (forall h : A, forall P : A -> Prop, forall t : list A, (FILTER' _18185 P (@cons A h t)) = (@COND (list A) (P h) (@cons A h (FILTER' _18185 P t)) (FILTER' _18185 P t)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))))).
Lemma FILTER_def {A : Type'} : (@FILTER A) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> Prop) -> (list A) -> list A) (fun FILTER' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> Prop) -> (list A) -> list A => forall _18185 : prod N (prod N (prod N (prod N (prod N N)))), (forall P : A -> Prop, (FILTER' _18185 P (@nil A)) = (@nil A)) /\ (forall h : A, forall P : A -> Prop, forall t : list A, (FILTER' _18185 P (@cons A h t)) = (@COND (list A) (P h) (@cons A h (FILTER' _18185 P t)) (FILTER' _18185 P t)))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl (@FILTER A)). Qed.
Definition ASSOC {A B : Type'} : A -> (list (prod A B)) -> B := @ε ((prod N (prod N (prod N (prod N N)))) -> A -> (list (prod A B)) -> B) (fun ASSOC' : (prod N (prod N (prod N (prod N N)))) -> A -> (list (prod A B)) -> B => forall _18192 : prod N (prod N (prod N (prod N N))), forall h : prod A B, forall a : A, forall t : list (prod A B), (ASSOC' _18192 a (@cons (prod A B) h t)) = (@COND B ((@fst A B h) = a) (@snd A B h) (ASSOC' _18192 a t))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))))))).
Lemma ASSOC_def {A B : Type'} : (@ASSOC A B) = (@ε ((prod N (prod N (prod N (prod N N)))) -> A -> (list (prod A B)) -> B) (fun ASSOC' : (prod N (prod N (prod N (prod N N)))) -> A -> (list (prod A B)) -> B => forall _18192 : prod N (prod N (prod N (prod N N))), forall h : prod A B, forall a : A, forall t : list (prod A B), (ASSOC' _18192 a (@cons (prod A B) h t)) = (@COND B ((@fst A B h) = a) (@snd A B h) (ASSOC' _18192 a t))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N))))))))))))).
Proof. exact (eq_refl (@ASSOC A B)). Qed.
Definition ITLIST2 {A B C : Type'} : (A -> B -> C -> C) -> (list A) -> (list B) -> C -> C := @ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> B -> C -> C) -> (list A) -> (list B) -> C -> C) (fun ITLIST2' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> B -> C -> C) -> (list A) -> (list B) -> C -> C => forall _18201 : prod N (prod N (prod N (prod N (prod N (prod N N))))), (forall f : A -> B -> C -> C, forall l2 : list B, forall b : C, (ITLIST2' _18201 f (@nil A) l2 b) = b) /\ (forall h1' : A, forall f : A -> B -> C -> C, forall t1 : list A, forall l2 : list B, forall b : C, (ITLIST2' _18201 f (@cons A h1' t1) l2 b) = (f h1' (@hd B l2) (ITLIST2' _18201 f t1 (@tl B l2) b)))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))).
Lemma ITLIST2_def {A B C : Type'} : (@ITLIST2 A B C) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> B -> C -> C) -> (list A) -> (list B) -> C -> C) (fun ITLIST2' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> B -> C -> C) -> (list A) -> (list B) -> C -> C => forall _18201 : prod N (prod N (prod N (prod N (prod N (prod N N))))), (forall f : A -> B -> C -> C, forall l2 : list B, forall b : C, (ITLIST2' _18201 f (@nil A) l2 b) = b) /\ (forall h1' : A, forall f : A -> B -> C -> C, forall t1 : list A, forall l2 : list B, forall b : C, (ITLIST2' _18201 f (@cons A h1' t1) l2 b) = (f h1' (@hd B l2) (ITLIST2' _18201 f t1 (@tl B l2) b)))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl (@ITLIST2 A B C)). Qed.
Definition ZIP {A B : Type'} : (list A) -> (list B) -> list (prod A B) := @ε ((prod N (prod N N)) -> (list A) -> (list B) -> list (prod A B)) (fun ZIP' : (prod N (prod N N)) -> (list A) -> (list B) -> list (prod A B) => forall _18205 : prod N (prod N N), (forall l2 : list B, (ZIP' _18205 (@nil A) l2) = (@nil (prod A B))) /\ (forall h1' : A, forall t1 : list A, forall l2 : list B, (ZIP' _18205 (@cons A h1' t1) l2) = (@cons (prod A B) (@pair A B h1' (@hd B l2)) (ZIP' _18205 t1 (@tl B l2))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))).
Lemma ZIP_def {A B : Type'} : (@ZIP A B) = (@ε ((prod N (prod N N)) -> (list A) -> (list B) -> list (prod A B)) (fun ZIP' : (prod N (prod N N)) -> (list A) -> (list B) -> list (prod A B) => forall _18205 : prod N (prod N N), (forall l2 : list B, (ZIP' _18205 (@nil A) l2) = (@nil (prod A B))) /\ (forall h1' : A, forall t1 : list A, forall l2 : list B, (ZIP' _18205 (@cons A h1' t1) l2) = (@cons (prod A B) (@pair A B h1' (@hd B l2)) (ZIP' _18205 t1 (@tl B l2))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))).
Proof. exact (eq_refl (@ZIP A B)). Qed.
Definition ALLPAIRS {A B : Type'} : (A -> B -> Prop) -> (list A) -> (list B) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop) (fun ALLPAIRS' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop => forall _18213 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall f : A -> B -> Prop, forall l : list B, (ALLPAIRS' _18213 f (@nil A) l) = True) /\ (forall h : A, forall f : A -> B -> Prop, forall t : list A, forall l : list B, (ALLPAIRS' _18213 f (@cons A h t) l) = ((@List.Forall B (f h) l) /\ (ALLPAIRS' _18213 f t l)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))))))).
Lemma ALLPAIRS_def {A B : Type'} : (@ALLPAIRS A B) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop) (fun ALLPAIRS' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (A -> B -> Prop) -> (list A) -> (list B) -> Prop => forall _18213 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall f : A -> B -> Prop, forall l : list B, (ALLPAIRS' _18213 f (@nil A) l) = True) /\ (forall h : A, forall f : A -> B -> Prop, forall t : list A, forall l : list B, (ALLPAIRS' _18213 f (@cons A h t) l) = ((@List.Forall B (f h) l) /\ (ALLPAIRS' _18213 f t l)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))))))).
Proof. exact (eq_refl (@ALLPAIRS A B)). Qed.
Definition list_of_seq {A : Type'} : (N -> A) -> N -> list A := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (N -> A) -> N -> list A) (fun list_of_seq' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (N -> A) -> N -> list A => forall _18227 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), (forall s : N -> A, (list_of_seq' _18227 s (NUMERAL 0%N)) = (@nil A)) /\ (forall s : N -> A, forall n : N, (list_of_seq' _18227 s (N.succ n)) = (@List.app A (list_of_seq' _18227 s n) (@cons A (s n) (@nil A))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))))).
Lemma list_of_seq_def {A : Type'} : (@list_of_seq A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (N -> A) -> N -> list A) (fun list_of_seq' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (N -> A) -> N -> list A => forall _18227 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), (forall s : N -> A, (list_of_seq' _18227 s (NUMERAL 0%N)) = (@nil A)) /\ (forall s : N -> A, forall n : N, (list_of_seq' _18227 s (N.succ n)) = (@List.app A (list_of_seq' _18227 s n) (@cons A (s n) (@nil A))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))))).
Proof. exact (eq_refl (@list_of_seq A)). Qed.
Definition _22857 : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL 0%N) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : N => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7).
Lemma _22857_def : _22857 = (fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL 0%N) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : N => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7)).
Proof. exact (eq_refl _22857). Qed.
Definition ASCII : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := _22857.
Lemma ASCII_def : ASCII = _22857.
Proof. exact (eq_refl ASCII). Qed.
Lemma dist_def : dist = (fun _22947 : prod N N => N.add (N.sub (@fst N N _22947) (@snd N N _22947)) (N.sub (@snd N N _22947) (@fst N N _22947))).
Proof. exact (eq_refl dist). Qed.
Lemma is_nadd_def : is_nadd = (fun _23257 : N -> N => exists B : N, forall m : N, forall n : N, N.le (dist (@pair N N (N.mul m (_23257 n)) (N.mul n (_23257 m)))) (N.mul B (N.add m n))).
Proof. exact (eq_refl is_nadd). Qed.
Lemma nadd_eq_def : nadd_eq = (fun _23276 : nadd => fun _23277 : nadd => exists B : N, forall n : N, N.le (dist (@pair N N (dest_nadd _23276 n) (dest_nadd _23277 n))) B).
Proof. exact (eq_refl nadd_eq). Qed.
Lemma nadd_of_num_def : nadd_of_num = (fun _23288 : N => mk_nadd (fun n : N => N.mul _23288 n)).
Proof. exact (eq_refl nadd_of_num). Qed.
Lemma nadd_le_def : nadd_le = (fun _23295 : nadd => fun _23296 : nadd => exists B : N, forall n : N, N.le (dest_nadd _23295 n) (N.add (dest_nadd _23296 n) B)).
Proof. exact (eq_refl nadd_le). Qed.
Lemma nadd_add_def : nadd_add = (fun _23311 : nadd => fun _23312 : nadd => mk_nadd (fun n : N => N.add (dest_nadd _23311 n) (dest_nadd _23312 n))).
Proof. exact (eq_refl nadd_add). Qed.
Lemma nadd_mul_def : nadd_mul = (fun _23325 : nadd => fun _23326 : nadd => mk_nadd (fun n : N => dest_nadd _23325 (dest_nadd _23326 n))).
Proof. exact (eq_refl nadd_mul). Qed.
Lemma nadd_rinv_def : nadd_rinv = (fun _23462 : nadd => fun n : N => N.div (N.mul n n) (dest_nadd _23462 n)).
Proof. exact (eq_refl nadd_rinv). Qed.
Lemma nadd_inv_def : nadd_inv = (fun _23476 : nadd => @COND nadd (nadd_eq _23476 (nadd_of_num (NUMERAL 0%N))) (nadd_of_num (NUMERAL 0%N)) (mk_nadd (nadd_rinv _23476))).
Proof. exact (eq_refl nadd_inv). Qed.
Lemma hreal_of_num_def : hreal_of_num = (fun m : N => mk_hreal (fun u : nadd => nadd_eq (nadd_of_num m) u)).
Proof. exact (eq_refl hreal_of_num). Qed.
Lemma hreal_add_def : hreal_add = (fun x : hreal => fun y : hreal => mk_hreal (fun u : nadd => exists x' : nadd, exists y' : nadd, (nadd_eq (nadd_add x' y') u) /\ ((dest_hreal x x') /\ (dest_hreal y y')))).
Proof. exact (eq_refl hreal_add). Qed.
Lemma hreal_mul_def : hreal_mul = (fun x : hreal => fun y : hreal => mk_hreal (fun u : nadd => exists x' : nadd, exists y' : nadd, (nadd_eq (nadd_mul x' y') u) /\ ((dest_hreal x x') /\ (dest_hreal y y')))).
Proof. exact (eq_refl hreal_mul). Qed.
Lemma hreal_le_def : hreal_le = (fun x : hreal => fun y : hreal => @ε Prop (fun u : Prop => exists x' : nadd, exists y' : nadd, ((nadd_le x' y') = u) /\ ((dest_hreal x x') /\ (dest_hreal y y')))).
Proof. exact (eq_refl hreal_le). Qed.
Lemma hreal_inv_def : hreal_inv = (fun x : hreal => mk_hreal (fun u : nadd => exists x' : nadd, (nadd_eq (nadd_inv x') u) /\ (dest_hreal x x'))).
Proof. exact (eq_refl hreal_inv). Qed.
Lemma treal_of_num_def : treal_of_num = (fun _23721 : N => @pair hreal hreal (hreal_of_num _23721) (hreal_of_num (NUMERAL 0%N))).
Proof. exact (eq_refl treal_of_num). Qed.
Lemma treal_neg_def : treal_neg = (fun _23726 : prod hreal hreal => @pair hreal hreal (@snd hreal hreal _23726) (@fst hreal hreal _23726)).
Proof. exact (eq_refl treal_neg). Qed.
Lemma treal_add_def : treal_add = (fun _23735 : prod hreal hreal => fun _23736 : prod hreal hreal => @pair hreal hreal (hreal_add (@fst hreal hreal _23735) (@fst hreal hreal _23736)) (hreal_add (@snd hreal hreal _23735) (@snd hreal hreal _23736))).
Proof. exact (eq_refl treal_add). Qed.
Lemma treal_mul_def : treal_mul = (fun _23757 : prod hreal hreal => fun _23758 : prod hreal hreal => @pair hreal hreal (hreal_add (hreal_mul (@fst hreal hreal _23757) (@fst hreal hreal _23758)) (hreal_mul (@snd hreal hreal _23757) (@snd hreal hreal _23758))) (hreal_add (hreal_mul (@fst hreal hreal _23757) (@snd hreal hreal _23758)) (hreal_mul (@snd hreal hreal _23757) (@fst hreal hreal _23758)))).
Proof. exact (eq_refl treal_mul). Qed.
Lemma treal_le_def : treal_le = (fun _23779 : prod hreal hreal => fun _23780 : prod hreal hreal => hreal_le (hreal_add (@fst hreal hreal _23779) (@snd hreal hreal _23780)) (hreal_add (@fst hreal hreal _23780) (@snd hreal hreal _23779))).
Proof. exact (eq_refl treal_le). Qed.
Lemma treal_inv_def : treal_inv = (fun _23801 : prod hreal hreal => @COND (prod hreal hreal) ((@fst hreal hreal _23801) = (@snd hreal hreal _23801)) (@pair hreal hreal (hreal_of_num (NUMERAL 0%N)) (hreal_of_num (NUMERAL 0%N))) (@COND (prod hreal hreal) (hreal_le (@snd hreal hreal _23801) (@fst hreal hreal _23801)) (@pair hreal hreal (hreal_inv (@ε hreal (fun d : hreal => (@fst hreal hreal _23801) = (hreal_add (@snd hreal hreal _23801) d)))) (hreal_of_num (NUMERAL 0%N))) (@pair hreal hreal (hreal_of_num (NUMERAL 0%N)) (hreal_inv (@ε hreal (fun d : hreal => (@snd hreal hreal _23801) = (hreal_add (@fst hreal hreal _23801) d))))))).
Proof. exact (eq_refl treal_inv). Qed.
Lemma treal_eq_def : treal_eq = (fun _23810 : prod hreal hreal => fun _23811 : prod hreal hreal => (hreal_add (@fst hreal hreal _23810) (@snd hreal hreal _23811)) = (hreal_add (@fst hreal hreal _23811) (@snd hreal hreal _23810))).
Proof. exact (eq_refl treal_eq). Qed.
Definition sqrt : R -> R := fun _27149 : R => @ε R (fun y : R => ((Rsgn y) = (Rsgn _27149)) /\ ((Rpow y (NUMERAL (BIT0 (BIT1 0%N)))) = (Rabs _27149))).
Lemma sqrt_def : sqrt = (fun _27149 : R => @ε R (fun y : R => ((Rsgn y) = (Rsgn _27149)) /\ ((Rpow y (NUMERAL (BIT0 (BIT1 0%N)))) = (Rabs _27149)))).
Proof. exact (eq_refl sqrt). Qed.
Definition DECIMAL : N -> N -> R := fun _27828 : N => fun _27829 : N => Rdiv (R_of_N _27828) (R_of_N _27829).
Lemma DECIMAL_def : DECIMAL = (fun _27828 : N => fun _27829 : N => Rdiv (R_of_N _27828) (R_of_N _27829)).
Proof. exact (eq_refl DECIMAL). Qed.
Definition integer : R -> Prop := fun _28715 : R => exists n : N, (Rabs _28715) = (R_of_N n).
Lemma integer_def : integer = (fun _28715 : R => exists n : N, (Rabs _28715) = (R_of_N n)).
Proof. exact (eq_refl integer). Qed.
Definition eq2 {A : Type'} : A -> A -> (A -> A -> Prop) -> Prop := fun _29602 : A => fun _29603 : A => fun _29604 : A -> A -> Prop => _29604 _29602 _29603.
Lemma eq2_def {A : Type'} : (@eq2 A) = (fun _29602 : A => fun _29603 : A => fun _29604 : A -> A -> Prop => _29604 _29602 _29603).
Proof. exact (eq_refl (@eq2 A)). Qed.
Definition int_mod : Z -> Z -> Z -> Prop := fun _29664 : Z => fun _29665 : Z => fun _29666 : Z => Z.divide _29664 (Z.sub _29665 _29666).
Lemma int_mod_def : int_mod = (fun _29664 : Z => fun _29665 : Z => fun _29666 : Z => Z.divide _29664 (Z.sub _29665 _29666)).
Proof. exact (eq_refl int_mod). Qed.
Definition num_of_int : Z -> N := fun _31234 : Z => @ε N (fun n : N => (Z_of_N n) = _31234).
Lemma num_of_int_def : num_of_int = (fun _31234 : Z => @ε N (fun n : N => (Z_of_N n) = _31234)).
Proof. exact (eq_refl num_of_int). Qed.
Definition num_divides : N -> N -> Prop := fun _31266 : N => fun _31267 : N => Z.divide (Z_of_N _31266) (Z_of_N _31267).
Lemma num_divides_def : num_divides = (fun _31266 : N => fun _31267 : N => Z.divide (Z_of_N _31266) (Z_of_N _31267)).
Proof. exact (eq_refl num_divides). Qed.
Definition num_mod : N -> N -> N -> Prop := fun _31278 : N => fun _31279 : N => fun _31280 : N => int_mod (Z_of_N _31278) (Z_of_N _31279) (Z_of_N _31280).
Lemma num_mod_def : num_mod = (fun _31278 : N => fun _31279 : N => fun _31280 : N => int_mod (Z_of_N _31278) (Z_of_N _31279) (Z_of_N _31280)).
Proof. exact (eq_refl num_mod). Qed.
Definition num_coprime : (prod N N) -> Prop := fun _31299 : prod N N => int_coprime (@pair Z Z (Z_of_N (@fst N N _31299)) (Z_of_N (@snd N N _31299))).
Lemma num_coprime_def : num_coprime = (fun _31299 : prod N N => int_coprime (@pair Z Z (Z_of_N (@fst N N _31299)) (Z_of_N (@snd N N _31299)))).
Proof. exact (eq_refl num_coprime). Qed.
Definition num_gcd : (prod N N) -> N := fun _31308 : prod N N => num_of_int (int_gcd (@pair Z Z (Z_of_N (@fst N N _31308)) (Z_of_N (@snd N N _31308)))).
Lemma num_gcd_def : num_gcd = (fun _31308 : prod N N => num_of_int (int_gcd (@pair Z Z (Z_of_N (@fst N N _31308)) (Z_of_N (@snd N N _31308))))).
Proof. exact (eq_refl num_gcd). Qed.
Definition num_lcm : (prod N N) -> N := fun _31317 : prod N N => num_of_int (int_lcm (@pair Z Z (Z_of_N (@fst N N _31317)) (Z_of_N (@snd N N _31317)))).
Lemma num_lcm_def : num_lcm = (fun _31317 : prod N N => num_of_int (int_lcm (@pair Z Z (Z_of_N (@fst N N _31317)) (Z_of_N (@snd N N _31317))))).
Proof. exact (eq_refl num_lcm). Qed.
Definition prime : N -> Prop := fun _32102 : N => (~ (_32102 = (NUMERAL (BIT1 0%N)))) /\ (forall x : N, (num_divides x _32102) -> (x = (NUMERAL (BIT1 0%N))) \/ (x = _32102)).
Lemma prime_def : prime = (fun _32102 : N => (~ (_32102 = (NUMERAL (BIT1 0%N)))) /\ (forall x : N, (num_divides x _32102) -> (x = (NUMERAL (BIT1 0%N))) \/ (x = _32102))).
Proof. exact (eq_refl prime). Qed.
Definition real_zpow : R -> Z -> R := fun _32260 : R => fun _32261 : Z => @COND R (Z.le (Z_of_N (NUMERAL 0%N)) _32261) (Rpow _32260 (num_of_int _32261)) (Rinv (Rpow _32260 (num_of_int (Z.opp _32261)))).
Lemma real_zpow_def : real_zpow = (fun _32260 : R => fun _32261 : Z => @COND R (Z.le (Z_of_N (NUMERAL 0%N)) _32261) (Rpow _32260 (num_of_int _32261)) (Rinv (Rpow _32260 (num_of_int (Z.opp _32261))))).
Proof. exact (eq_refl real_zpow). Qed.
Definition IN {A : Type'} : A -> (A -> Prop) -> Prop := fun _32317 : A => fun _32318 : A -> Prop => _32318 _32317.
Lemma IN_def {A : Type'} : (@IN A) = (fun _32317 : A => fun _32318 : A -> Prop => _32318 _32317).
Proof. exact (eq_refl (@IN A)). Qed.
Definition GSPEC {A : Type'} : (A -> Prop) -> A -> Prop := fun _32329 : A -> Prop => _32329.
Lemma GSPEC_def {A : Type'} : (@GSPEC A) = (fun _32329 : A -> Prop => _32329).
Proof. exact (eq_refl (@GSPEC A)). Qed.
Definition SETSPEC {A : Type'} : A -> Prop -> A -> Prop := fun _32334 : A => fun _32335 : Prop => fun _32336 : A => _32335 /\ (_32334 = _32336).
Lemma SETSPEC_def {A : Type'} : (@SETSPEC A) = (fun _32334 : A => fun _32335 : Prop => fun _32336 : A => _32335 /\ (_32334 = _32336)).
Proof. exact (eq_refl (@SETSPEC A)). Qed.
Definition EMPTY {A : Type'} : A -> Prop := fun x : A => False.
Lemma EMPTY_def {A : Type'} : (@EMPTY A) = (fun x : A => False).
Proof. exact (eq_refl (@EMPTY A)). Qed.
Definition INSERT {A : Type'} : A -> (A -> Prop) -> A -> Prop := fun _32373 : A => fun _32374 : A -> Prop => fun y : A => (@IN A y _32374) \/ (y = _32373).
Lemma INSERT_def {A : Type'} : (@INSERT A) = (fun _32373 : A => fun _32374 : A -> Prop => fun y : A => (@IN A y _32374) \/ (y = _32373)).
Proof. exact (eq_refl (@INSERT A)). Qed.
Definition UNIV {A : Type'} : A -> Prop := fun x : A => True.
Lemma UNIV_def {A : Type'} : (@UNIV A) = (fun x : A => True).
Proof. exact (eq_refl (@UNIV A)). Qed.
Definition UNION {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _32385 : A -> Prop => fun _32386 : A -> Prop => @GSPEC A (fun GEN_PVAR_0 : A => exists x : A, @SETSPEC A GEN_PVAR_0 ((@IN A x _32385) \/ (@IN A x _32386)) x).
Lemma UNION_def {A : Type'} : (@UNION A) = (fun _32385 : A -> Prop => fun _32386 : A -> Prop => @GSPEC A (fun GEN_PVAR_0 : A => exists x : A, @SETSPEC A GEN_PVAR_0 ((@IN A x _32385) \/ (@IN A x _32386)) x)).
Proof. exact (eq_refl (@UNION A)). Qed.
Definition UNIONS {A : Type'} : ((A -> Prop) -> Prop) -> A -> Prop := fun _32397 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_1 : A => exists x : A, @SETSPEC A GEN_PVAR_1 (exists u : A -> Prop, (@IN (A -> Prop) u _32397) /\ (@IN A x u)) x).
Lemma UNIONS_def {A : Type'} : (@UNIONS A) = (fun _32397 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_1 : A => exists x : A, @SETSPEC A GEN_PVAR_1 (exists u : A -> Prop, (@IN (A -> Prop) u _32397) /\ (@IN A x u)) x)).
Proof. exact (eq_refl (@UNIONS A)). Qed.
Definition INTER {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _32402 : A -> Prop => fun _32403 : A -> Prop => @GSPEC A (fun GEN_PVAR_2 : A => exists x : A, @SETSPEC A GEN_PVAR_2 ((@IN A x _32402) /\ (@IN A x _32403)) x).
Lemma INTER_def {A : Type'} : (@INTER A) = (fun _32402 : A -> Prop => fun _32403 : A -> Prop => @GSPEC A (fun GEN_PVAR_2 : A => exists x : A, @SETSPEC A GEN_PVAR_2 ((@IN A x _32402) /\ (@IN A x _32403)) x)).
Proof. exact (eq_refl (@INTER A)). Qed.
Definition INTERS {A : Type'} : ((A -> Prop) -> Prop) -> A -> Prop := fun _32414 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_3 : A => exists x : A, @SETSPEC A GEN_PVAR_3 (forall u : A -> Prop, (@IN (A -> Prop) u _32414) -> @IN A x u) x).
Lemma INTERS_def {A : Type'} : (@INTERS A) = (fun _32414 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_3 : A => exists x : A, @SETSPEC A GEN_PVAR_3 (forall u : A -> Prop, (@IN (A -> Prop) u _32414) -> @IN A x u) x)).
Proof. exact (eq_refl (@INTERS A)). Qed.
Definition DIFF {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _32419 : A -> Prop => fun _32420 : A -> Prop => @GSPEC A (fun GEN_PVAR_4 : A => exists x : A, @SETSPEC A GEN_PVAR_4 ((@IN A x _32419) /\ (~ (@IN A x _32420))) x).
Lemma DIFF_def {A : Type'} : (@DIFF A) = (fun _32419 : A -> Prop => fun _32420 : A -> Prop => @GSPEC A (fun GEN_PVAR_4 : A => exists x : A, @SETSPEC A GEN_PVAR_4 ((@IN A x _32419) /\ (~ (@IN A x _32420))) x)).
Proof. exact (eq_refl (@DIFF A)). Qed.
Definition DELETE {A : Type'} : (A -> Prop) -> A -> A -> Prop := fun _32431 : A -> Prop => fun _32432 : A => @GSPEC A (fun GEN_PVAR_6 : A => exists y : A, @SETSPEC A GEN_PVAR_6 ((@IN A y _32431) /\ (~ (y = _32432))) y).
Lemma DELETE_def {A : Type'} : (@DELETE A) = (fun _32431 : A -> Prop => fun _32432 : A => @GSPEC A (fun GEN_PVAR_6 : A => exists y : A, @SETSPEC A GEN_PVAR_6 ((@IN A y _32431) /\ (~ (y = _32432))) y)).
Proof. exact (eq_refl (@DELETE A)). Qed.
Definition SUBSET {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _32443 : A -> Prop => fun _32444 : A -> Prop => forall x : A, (@IN A x _32443) -> @IN A x _32444.
Lemma SUBSET_def {A : Type'} : (@SUBSET A) = (fun _32443 : A -> Prop => fun _32444 : A -> Prop => forall x : A, (@IN A x _32443) -> @IN A x _32444).
Proof. exact (eq_refl (@SUBSET A)). Qed.
Definition PSUBSET {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _32455 : A -> Prop => fun _32456 : A -> Prop => (@SUBSET A _32455 _32456) /\ (~ (_32455 = _32456)).
Lemma PSUBSET_def {A : Type'} : (@PSUBSET A) = (fun _32455 : A -> Prop => fun _32456 : A -> Prop => (@SUBSET A _32455 _32456) /\ (~ (_32455 = _32456))).
Proof. exact (eq_refl (@PSUBSET A)). Qed.
Definition DISJOINT {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _32467 : A -> Prop => fun _32468 : A -> Prop => (@INTER A _32467 _32468) = (@EMPTY A).
Lemma DISJOINT_def {A : Type'} : (@DISJOINT A) = (fun _32467 : A -> Prop => fun _32468 : A -> Prop => (@INTER A _32467 _32468) = (@EMPTY A)).
Proof. exact (eq_refl (@DISJOINT A)). Qed.
Definition SING {A : Type'} : (A -> Prop) -> Prop := fun _32479 : A -> Prop => exists x : A, _32479 = (@INSERT A x (@EMPTY A)).
Lemma SING_def {A : Type'} : (@SING A) = (fun _32479 : A -> Prop => exists x : A, _32479 = (@INSERT A x (@EMPTY A))).
Proof. exact (eq_refl (@SING A)). Qed.
Definition FINITE {A : Type'} : (A -> Prop) -> Prop := fun a : A -> Prop => forall FINITE' : (A -> Prop) -> Prop, (forall a' : A -> Prop, ((a' = (@EMPTY A)) \/ (exists x : A, exists s : A -> Prop, (a' = (@INSERT A x s)) /\ (FINITE' s))) -> FINITE' a') -> FINITE' a.
Lemma FINITE_def {A : Type'} : (@FINITE A) = (fun a : A -> Prop => forall FINITE' : (A -> Prop) -> Prop, (forall a' : A -> Prop, ((a' = (@EMPTY A)) \/ (exists x : A, exists s : A -> Prop, (a' = (@INSERT A x s)) /\ (FINITE' s))) -> FINITE' a') -> FINITE' a).
Proof. exact (eq_refl (@FINITE A)). Qed.
Definition INFINITE {A : Type'} : (A -> Prop) -> Prop := fun _32488 : A -> Prop => ~ (@FINITE A _32488).
Lemma INFINITE_def {A : Type'} : (@INFINITE A) = (fun _32488 : A -> Prop => ~ (@FINITE A _32488)).
Proof. exact (eq_refl (@INFINITE A)). Qed.
Definition IMAGE {A B : Type'} : (A -> B) -> (A -> Prop) -> B -> Prop := fun _32493 : A -> B => fun _32494 : A -> Prop => @GSPEC B (fun GEN_PVAR_7 : B => exists y : B, @SETSPEC B GEN_PVAR_7 (exists x : A, (@IN A x _32494) /\ (y = (_32493 x))) y).
Lemma IMAGE_def {A B : Type'} : (@IMAGE A B) = (fun _32493 : A -> B => fun _32494 : A -> Prop => @GSPEC B (fun GEN_PVAR_7 : B => exists y : B, @SETSPEC B GEN_PVAR_7 (exists x : A, (@IN A x _32494) /\ (y = (_32493 x))) y)).
Proof. exact (eq_refl (@IMAGE A B)). Qed.
Definition INJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32505 : A -> B => fun _32506 : A -> Prop => fun _32507 : B -> Prop => (forall x : A, (@IN A x _32506) -> @IN B (_32505 x) _32507) /\ (forall x : A, forall y : A, ((@IN A x _32506) /\ ((@IN A y _32506) /\ ((_32505 x) = (_32505 y)))) -> x = y).
Lemma INJ_def {A B : Type'} : (@INJ A B) = (fun _32505 : A -> B => fun _32506 : A -> Prop => fun _32507 : B -> Prop => (forall x : A, (@IN A x _32506) -> @IN B (_32505 x) _32507) /\ (forall x : A, forall y : A, ((@IN A x _32506) /\ ((@IN A y _32506) /\ ((_32505 x) = (_32505 y)))) -> x = y)).
Proof. exact (eq_refl (@INJ A B)). Qed.
Definition SURJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32526 : A -> B => fun _32527 : A -> Prop => fun _32528 : B -> Prop => (forall x : A, (@IN A x _32527) -> @IN B (_32526 x) _32528) /\ (forall x : B, (@IN B x _32528) -> exists y : A, (@IN A y _32527) /\ ((_32526 y) = x)).
Lemma SURJ_def {A B : Type'} : (@SURJ A B) = (fun _32526 : A -> B => fun _32527 : A -> Prop => fun _32528 : B -> Prop => (forall x : A, (@IN A x _32527) -> @IN B (_32526 x) _32528) /\ (forall x : B, (@IN B x _32528) -> exists y : A, (@IN A y _32527) /\ ((_32526 y) = x))).
Proof. exact (eq_refl (@SURJ A B)). Qed.
Definition BIJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32547 : A -> B => fun _32548 : A -> Prop => fun _32549 : B -> Prop => (@INJ A B _32547 _32548 _32549) /\ (@SURJ A B _32547 _32548 _32549).
Lemma BIJ_def {A B : Type'} : (@BIJ A B) = (fun _32547 : A -> B => fun _32548 : A -> Prop => fun _32549 : B -> Prop => (@INJ A B _32547 _32548 _32549) /\ (@SURJ A B _32547 _32548 _32549)).
Proof. exact (eq_refl (@BIJ A B)). Qed.
Definition CHOICE {A : Type'} : (A -> Prop) -> A := fun _32568 : A -> Prop => @ε A (fun x : A => @IN A x _32568).
Lemma CHOICE_def {A : Type'} : (@CHOICE A) = (fun _32568 : A -> Prop => @ε A (fun x : A => @IN A x _32568)).
Proof. exact (eq_refl (@CHOICE A)). Qed.
Definition REST {A : Type'} : (A -> Prop) -> A -> Prop := fun _32573 : A -> Prop => @DELETE A _32573 (@CHOICE A _32573).
Lemma REST_def {A : Type'} : (@REST A) = (fun _32573 : A -> Prop => @DELETE A _32573 (@CHOICE A _32573)).
Proof. exact (eq_refl (@REST A)). Qed.
Definition FINREC {A B : Type'} : (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop) (fun FINREC' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop => forall _42175 : prod N (prod N (prod N (prod N (prod N N)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42175 f b s a (NUMERAL 0%N)) = ((s = (@EMPTY A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : N, forall a : B, forall f : A -> B -> B, (FINREC' _42175 f b s a (N.succ n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42175 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N))))))))))))).
Lemma FINREC_def {A B : Type'} : (@FINREC A B) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop) (fun FINREC' : (prod N (prod N (prod N (prod N (prod N N))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> N -> Prop => forall _42175 : prod N (prod N (prod N (prod N (prod N N)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42175 f b s a (NUMERAL 0%N)) = ((s = (@EMPTY A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : N, forall a : B, forall f : A -> B -> B, (FINREC' _42175 f b s a (N.succ n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42175 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl (@FINREC A B)). Qed.
Definition ITSET {A B : Type'} : (A -> B -> B) -> (A -> Prop) -> B -> B := fun _43025 : A -> B -> B => fun _43026 : A -> Prop => fun _43027 : B => @ε ((A -> Prop) -> B) (fun g : (A -> Prop) -> B => ((g (@EMPTY A)) = _43027) /\ (forall x : A, forall s : A -> Prop, (@FINITE A s) -> (g (@INSERT A x s)) = (@COND B (@IN A x s) (g s) (_43025 x (g s))))) _43026.
Lemma ITSET_def {A B : Type'} : (@ITSET A B) = (fun _43025 : A -> B -> B => fun _43026 : A -> Prop => fun _43027 : B => @ε ((A -> Prop) -> B) (fun g : (A -> Prop) -> B => ((g (@EMPTY A)) = _43027) /\ (forall x : A, forall s : A -> Prop, (@FINITE A s) -> (g (@INSERT A x s)) = (@COND B (@IN A x s) (g s) (_43025 x (g s))))) _43026).
Proof. exact (eq_refl (@ITSET A B)). Qed.
Definition CARD {A : Type'} : (A -> Prop) -> N := fun _43228 : A -> Prop => @ITSET A N (fun x : A => fun n : N => N.succ n) _43228 (NUMERAL 0%N).
Lemma CARD_def {A : Type'} : (@CARD A) = (fun _43228 : A -> Prop => @ITSET A N (fun x : A => fun n : N => N.succ n) _43228 (NUMERAL 0%N)).
Proof. exact (eq_refl (@CARD A)). Qed.
Definition HAS_SIZE {A : Type'} : (A -> Prop) -> N -> Prop := fun _43403 : A -> Prop => fun _43404 : N => (@FINITE A _43403) /\ ((@CARD A _43403) = _43404).
Lemma HAS_SIZE_def {A : Type'} : (@HAS_SIZE A) = (fun _43403 : A -> Prop => fun _43404 : N => (@FINITE A _43403) /\ ((@CARD A _43403) = _43404)).
Proof. exact (eq_refl (@HAS_SIZE A)). Qed.
Definition CROSS {A B : Type'} : (A -> Prop) -> (B -> Prop) -> (prod A B) -> Prop := fun _47322 : A -> Prop => fun _47323 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47322) /\ (@IN B y _47323)) (@pair A B x y)).
Lemma CROSS_def {A B : Type'} : (@CROSS A B) = (fun _47322 : A -> Prop => fun _47323 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47322) /\ (@IN B y _47323)) (@pair A B x y))).
Proof. exact (eq_refl (@CROSS A B)). Qed.
Definition ARB {A : Type'} : A := @ε A (fun x : A => False).
Lemma ARB_def {A : Type'} : (@ARB A) = (@ε A (fun x : A => False)).
Proof. exact (eq_refl (@ARB A)). Qed.
Definition EXTENSIONAL {A B : Type'} : (A -> Prop) -> (A -> B) -> Prop := fun _48096 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48096)) -> (f x) = (@ARB B)) f).
Lemma EXTENSIONAL_def {A B : Type'} : (@EXTENSIONAL A B) = (fun _48096 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48096)) -> (f x) = (@ARB B)) f)).
Proof. exact (eq_refl (@EXTENSIONAL A B)). Qed.
Definition RESTRICTION {A B : Type'} : (A -> Prop) -> (A -> B) -> A -> B := fun _48148 : A -> Prop => fun _48149 : A -> B => fun _48150 : A => @COND B (@IN A _48150 _48148) (_48149 _48150) (@ARB B).
Lemma RESTRICTION_def {A B : Type'} : (@RESTRICTION A B) = (fun _48148 : A -> Prop => fun _48149 : A -> B => fun _48150 : A => @COND B (@IN A _48150 _48148) (_48149 _48150) (@ARB B)).
Proof. exact (eq_refl (@RESTRICTION A B)). Qed.
Definition cartesian_product {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (K -> A) -> Prop := fun _48343 : K -> Prop => fun _48344 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48343 f) /\ (forall i : K, (@IN K i _48343) -> @IN A (f i) (_48344 i))) f).
Lemma cartesian_product_def {A K : Type'} : (@cartesian_product A K) = (fun _48343 : K -> Prop => fun _48344 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48343 f) /\ (forall i : K, (@IN K i _48343) -> @IN A (f i) (_48344 i))) f)).
Proof. exact (eq_refl (@cartesian_product A K)). Qed.
Definition product_map {A B K : Type'} : (K -> Prop) -> (K -> A -> B) -> (K -> A) -> K -> B := fun _49392 : K -> Prop => fun _49393 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49392 (fun i : K => _49393 i (x i)).
Lemma product_map_def {A B K : Type'} : (@product_map A B K) = (fun _49392 : K -> Prop => fun _49393 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49392 (fun i : K => _49393 i (x i))).
Proof. exact (eq_refl (@product_map A B K)). Qed.
Definition disjoint_union {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (prod K A) -> Prop := fun _49528 : K -> Prop => fun _49529 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49528) /\ (@IN A x (_49529 i))) (@pair K A i x)).
Lemma disjoint_union_def {A K : Type'} : (@disjoint_union A K) = (fun _49528 : K -> Prop => fun _49529 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49528) /\ (@IN A x (_49529 i))) (@pair K A i x))).
Proof. exact (eq_refl (@disjoint_union A K)). Qed.
Definition set_of_list {A : Type'} : (list A) -> A -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (list A) -> A -> Prop) (fun set_of_list' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (list A) -> A -> Prop => forall _56425 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), ((set_of_list' _56425 (@nil A)) = (@EMPTY A)) /\ (forall h : A, forall t : list A, (set_of_list' _56425 (@cons A h t)) = (@INSERT A h (set_of_list' _56425 t)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))))).
Lemma set_of_list_def {A : Type'} : (@set_of_list A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (list A) -> A -> Prop) (fun set_of_list' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (list A) -> A -> Prop => forall _56425 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), ((set_of_list' _56425 (@nil A)) = (@EMPTY A)) /\ (forall h : A, forall t : list A, (set_of_list' _56425 (@cons A h t)) = (@INSERT A h (set_of_list' _56425 t)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))))).
Proof. exact (eq_refl (@set_of_list A)). Qed.
Definition list_of_set {A : Type'} : (A -> Prop) -> list A := fun _56426 : A -> Prop => @ε (list A) (fun l : list A => ((@set_of_list A l) = _56426) /\ ((@LENGTH A l) = (@CARD A _56426))).
Lemma list_of_set_def {A : Type'} : (@list_of_set A) = (fun _56426 : A -> Prop => @ε (list A) (fun l : list A => ((@set_of_list A l) = _56426) /\ ((@LENGTH A l) = (@CARD A _56426)))).
Proof. exact (eq_refl (@list_of_set A)). Qed.
Definition pairwise {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _56616 : A -> A -> Prop => fun _56617 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56617) /\ ((@IN A y _56617) /\ (~ (x = y)))) -> _56616 x y.
Lemma pairwise_def {A : Type'} : (@pairwise A) = (fun _56616 : A -> A -> Prop => fun _56617 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56617) /\ ((@IN A y _56617) /\ (~ (x = y)))) -> _56616 x y).
Proof. exact (eq_refl (@pairwise A)). Qed.
Definition UNION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57329 : ((A -> Prop) -> Prop) -> Prop => fun _57330 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57329 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57330 c) /\ ((@UNIONS A u) = s)).
Lemma UNION_OF_def {A : Type'} : (@UNION_OF A) = (fun _57329 : ((A -> Prop) -> Prop) -> Prop => fun _57330 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57329 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57330 c) /\ ((@UNIONS A u) = s))).
Proof. exact (eq_refl (@UNION_OF A)). Qed.
Definition INTERSECTION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57341 : ((A -> Prop) -> Prop) -> Prop => fun _57342 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57341 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57342 c) /\ ((@INTERS A u) = s)).
Lemma INTERSECTION_OF_def {A : Type'} : (@INTERSECTION_OF A) = (fun _57341 : ((A -> Prop) -> Prop) -> Prop => fun _57342 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57341 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57342 c) /\ ((@INTERS A u) = s))).
Proof. exact (eq_refl (@INTERSECTION_OF A)). Qed.
Definition ARBITRARY {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _57477 : (A -> Prop) -> Prop => True.
Lemma ARBITRARY_def {A : Type'} : (@ARBITRARY A) = (fun _57477 : (A -> Prop) -> Prop => True).
Proof. exact (eq_refl (@ARBITRARY A)). Qed.
Definition le_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64071 : A -> Prop => fun _64072 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64071) -> @IN B (f x) _64072) /\ (forall x : A, forall y : A, ((@IN A x _64071) /\ ((@IN A y _64071) /\ ((f x) = (f y)))) -> x = y).
Lemma le_c_def {A B : Type'} : (@le_c A B) = (fun _64071 : A -> Prop => fun _64072 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64071) -> @IN B (f x) _64072) /\ (forall x : A, forall y : A, ((@IN A x _64071) /\ ((@IN A y _64071) /\ ((f x) = (f y)))) -> x = y)).
Proof. exact (eq_refl (@le_c A B)). Qed.
Definition lt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64083 : A -> Prop => fun _64084 : B -> Prop => (@le_c A B _64083 _64084) /\ (~ (@le_c B A _64084 _64083)).
Lemma lt_c_def {A B : Type'} : (@lt_c A B) = (fun _64083 : A -> Prop => fun _64084 : B -> Prop => (@le_c A B _64083 _64084) /\ (~ (@le_c B A _64084 _64083))).
Proof. exact (eq_refl (@lt_c A B)). Qed.
Definition eq_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64095 : A -> Prop => fun _64096 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64095) -> @IN B (f x) _64096) /\ (forall y : B, (@IN B y _64096) -> @ex1 A (fun x : A => (@IN A x _64095) /\ ((f x) = y))).
Lemma eq_c_def {A B : Type'} : (@eq_c A B) = (fun _64095 : A -> Prop => fun _64096 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64095) -> @IN B (f x) _64096) /\ (forall y : B, (@IN B y _64096) -> @ex1 A (fun x : A => (@IN A x _64095) /\ ((f x) = y)))).
Proof. exact (eq_refl (@eq_c A B)). Qed.
Definition ge_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64107 : A -> Prop => fun _64108 : B -> Prop => @le_c B A _64108 _64107.
Lemma ge_c_def {A B : Type'} : (@ge_c A B) = (fun _64107 : A -> Prop => fun _64108 : B -> Prop => @le_c B A _64108 _64107).
Proof. exact (eq_refl (@ge_c A B)). Qed.
Definition gt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64119 : A -> Prop => fun _64120 : B -> Prop => @lt_c B A _64120 _64119.
Lemma gt_c_def {A B : Type'} : (@gt_c A B) = (fun _64119 : A -> Prop => fun _64120 : B -> Prop => @lt_c B A _64120 _64119).
Proof. exact (eq_refl (@gt_c A B)). Qed.
Definition COUNTABLE {A : Type'} : (A -> Prop) -> Prop := fun _64270 : A -> Prop => @ge_c N A (@UNIV N) _64270.
Lemma COUNTABLE_def {A : Type'} : (@COUNTABLE A) = (fun _64270 : A -> Prop => @ge_c N A (@UNIV N) _64270).
Proof. exact (eq_refl (@COUNTABLE A)). Qed.
Definition sup : (R -> Prop) -> R := fun _64275 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64275) -> Rle x a) /\ (forall b : R, (forall x : R, (@IN R x _64275) -> Rle x b) -> Rle a b)).
Lemma sup_def : sup = (fun _64275 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64275) -> Rle x a) /\ (forall b : R, (forall x : R, (@IN R x _64275) -> Rle x b) -> Rle a b))).
Proof. exact (eq_refl sup). Qed.
Definition inf : (R -> Prop) -> R := fun _65134 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65134) -> Rle a x) /\ (forall b : R, (forall x : R, (@IN R x _65134) -> Rle b x) -> Rle b a)).
Lemma inf_def : inf = (fun _65134 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65134) -> Rle a x) /\ (forall b : R, (forall x : R, (@IN R x _65134) -> Rle b x) -> Rle b a))).
Proof. exact (eq_refl inf). Qed.
Definition has_inf : (R -> Prop) -> R -> Prop := fun _66484 : R -> Prop => fun _66485 : R => forall c : R, (forall x : R, (@IN R x _66484) -> Rle c x) = (Rle c _66485).
Lemma has_inf_def : has_inf = (fun _66484 : R -> Prop => fun _66485 : R => forall c : R, (forall x : R, (@IN R x _66484) -> Rle c x) = (Rle c _66485)).
Proof. exact (eq_refl has_inf). Qed.
Definition has_sup : (R -> Prop) -> R -> Prop := fun _66496 : R -> Prop => fun _66497 : R => forall c : R, (forall x : R, (@IN R x _66496) -> Rle x c) = (Rle _66497 c).
Lemma has_sup_def : has_sup = (fun _66496 : R -> Prop => fun _66497 : R => forall c : R, (forall x : R, (@IN R x _66496) -> Rle x c) = (Rle _66497 c)).
Proof. exact (eq_refl has_sup). Qed.
Definition dotdot : N -> N -> N -> Prop := fun _66922 : N => fun _66923 : N => @GSPEC N (fun GEN_PVAR_231 : N => exists x : N, @SETSPEC N GEN_PVAR_231 ((N.le _66922 x) /\ (N.le x _66923)) x).
Lemma dotdot_def : dotdot = (fun _66922 : N => fun _66923 : N => @GSPEC N (fun GEN_PVAR_231 : N => exists x : N, @SETSPEC N GEN_PVAR_231 ((N.le _66922 x) /\ (N.le x _66923)) x)).
Proof. exact (eq_refl dotdot). Qed.
Definition neutral {A : Type'} : (A -> A -> A) -> A := fun _68834 : A -> A -> A => @ε A (fun x : A => forall y : A, ((_68834 x y) = y) /\ ((_68834 y x) = y)).
Lemma neutral_def {A : Type'} : (@neutral A) = (fun _68834 : A -> A -> A => @ε A (fun x : A => forall y : A, ((_68834 x y) = y) /\ ((_68834 y x) = y))).
Proof. exact (eq_refl (@neutral A)). Qed.
Definition monoidal {A : Type'} : (A -> A -> A) -> Prop := fun _68839 : A -> A -> A => (forall x : A, forall y : A, (_68839 x y) = (_68839 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68839 x (_68839 y z)) = (_68839 (_68839 x y) z)) /\ (forall x : A, (_68839 (@neutral A _68839) x) = x)).
Lemma monoidal_def {A : Type'} : (@monoidal A) = (fun _68839 : A -> A -> A => (forall x : A, forall y : A, (_68839 x y) = (_68839 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68839 x (_68839 y z)) = (_68839 (_68839 x y) z)) /\ (forall x : A, (_68839 (@neutral A _68839) x) = x))).
Proof. exact (eq_refl (@monoidal A)). Qed.
Definition support {A B : Type'} : (B -> B -> B) -> (A -> B) -> (A -> Prop) -> A -> Prop := fun _68924 : B -> B -> B => fun _68925 : A -> B => fun _68926 : A -> Prop => @GSPEC A (fun GEN_PVAR_239 : A => exists x : A, @SETSPEC A GEN_PVAR_239 ((@IN A x _68926) /\ (~ ((_68925 x) = (@neutral B _68924)))) x).
Lemma support_def {A B : Type'} : (@support A B) = (fun _68924 : B -> B -> B => fun _68925 : A -> B => fun _68926 : A -> Prop => @GSPEC A (fun GEN_PVAR_239 : A => exists x : A, @SETSPEC A GEN_PVAR_239 ((@IN A x _68926) /\ (~ ((_68925 x) = (@neutral B _68924)))) x)).
Proof. exact (eq_refl (@support A B)). Qed.
Definition iterate {A B : Type'} : (B -> B -> B) -> (A -> Prop) -> (A -> B) -> B := fun _68945 : B -> B -> B => fun _68946 : A -> Prop => fun _68947 : A -> B => @COND B (@FINITE A (@support A B _68945 _68947 _68946)) (@ITSET A B (fun x : A => fun a : B => _68945 (_68947 x) a) (@support A B _68945 _68947 _68946) (@neutral B _68945)) (@neutral B _68945).
Lemma iterate_def {A B : Type'} : (@iterate A B) = (fun _68945 : B -> B -> B => fun _68946 : A -> Prop => fun _68947 : A -> B => @COND B (@FINITE A (@support A B _68945 _68947 _68946)) (@ITSET A B (fun x : A => fun a : B => _68945 (_68947 x) a) (@support A B _68945 _68947 _68946) (@neutral B _68945)) (@neutral B _68945)).
Proof. exact (eq_refl (@iterate A B)). Qed.
Definition iterato {A K : Type'} : (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A := @ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76701 : prod N (prod N (prod N (prod N (prod N (prod N N))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76701 dom neut op ltle k f) = (@COND A ((@FINITE K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i)) = (@EMPTY K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _76701 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))))) neut)) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))).
Lemma iterato_def {A K : Type'} : (@iterato A K) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76701 : prod N (prod N (prod N (prod N (prod N (prod N N))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76701 dom neut op ltle k f) = (@COND A ((@FINITE K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i)) = (@EMPTY K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _76701 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))))) neut)) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))).
Proof. exact (eq_refl (@iterato A K)). Qed.
Definition nproduct {A : Type'} : (A -> Prop) -> (A -> N) -> N := @iterate A N N.mul.
Lemma nproduct_def {A : Type'} : (@nproduct A) = (@iterate A N N.mul).
Proof. exact (eq_refl (@nproduct A)). Qed.
Definition iproduct {A : Type'} : (A -> Prop) -> (A -> Z) -> Z := @iterate A Z Z.mul.
Lemma iproduct_def {A : Type'} : (@iproduct A) = (@iterate A Z Z.mul).
Proof. exact (eq_refl (@iproduct A)). Qed.
Definition product {A : Type'} : (A -> Prop) -> (A -> R) -> R := @iterate A R Rmult.
Lemma product_def {A : Type'} : (@product A) = (@iterate A R Rmult).
Proof. exact (eq_refl (@product A)). Qed.
Definition isum {A : Type'} : (A -> Prop) -> (A -> Z) -> Z := @iterate A Z Z.add.
Lemma isum_def {A : Type'} : (@isum A) = (@iterate A Z Z.add).
Proof. exact (eq_refl (@isum A)). Qed.
Definition nsum {A : Type'} : (A -> Prop) -> (A -> N) -> N := @iterate A N N.add.
Lemma nsum_def {A : Type'} : (@nsum A) = (@iterate A N N.add).
Proof. exact (eq_refl (@nsum A)). Qed.
Definition sum {A : Type'} : (A -> Prop) -> (A -> R) -> R := @iterate A R Rplus.
Lemma sum_def {A : Type'} : (@sum A) = (@iterate A R Rplus).
Proof. exact (eq_refl (@sum A)). Qed.
Definition polynomial_function : (R -> R) -> Prop := fun _94114 : R -> R => exists m : N, exists c : N -> R, forall x : R, (_94114 x) = (@sum N (dotdot (NUMERAL 0%N) m) (fun i : N => Rmult (c i) (Rpow x i))).
Lemma polynomial_function_def : polynomial_function = (fun _94114 : R -> R => exists m : N, exists c : N -> R, forall x : R, (_94114 x) = (@sum N (dotdot (NUMERAL 0%N) m) (fun i : N => Rmult (c i) (Rpow x i)))).
Proof. exact (eq_refl polynomial_function). Qed.
Definition dimindex {A : Type'} : (A -> Prop) -> N := fun _94156 : A -> Prop => @COND N (@FINITE A (@UNIV A)) (@CARD A (@UNIV A)) (NUMERAL (BIT1 0%N)).
Lemma dimindex_def {A : Type'} : (@dimindex A) = (fun _94156 : A -> Prop => @COND N (@FINITE A (@UNIV A)) (@CARD A (@UNIV A)) (NUMERAL (BIT1 0%N))).
Proof. exact (eq_refl (@dimindex A)). Qed.
Definition dollar {A N' : Type'} : (cart A N') -> N -> A := fun _94566 : cart A N' => fun _94567 : N => @dest_cart A N' _94566 (@finite_index N' _94567).
Lemma dollar_def {A N' : Type'} : (@dollar A N') = (fun _94566 : cart A N' => fun _94567 : N => @dest_cart A N' _94566 (@finite_index N' _94567)).
Proof. exact (eq_refl (@dollar A N')). Qed.
Definition lambda {A B : Type'} : (N -> A) -> cart A B := fun _94602 : N -> A => @ε (cart A B) (fun f : cart A B => forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex B (@UNIV B)))) -> (@dollar A B f i) = (_94602 i)).
Lemma lambda_def {A B : Type'} : (@lambda A B) = (fun _94602 : N -> A => @ε (cart A B) (fun f : cart A B => forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex B (@UNIV B)))) -> (@dollar A B f i) = (_94602 i))).
Proof. exact (eq_refl (@lambda A B)). Qed.
Definition pastecart {A M N' : Type'} : (cart A M) -> (cart A N') -> cart A (finite_sum M N') := fun _94893 : cart A M => fun _94894 : cart A N' => @lambda A (finite_sum M N') (fun i : N => @COND A (N.le i (@dimindex M (@UNIV M))) (@dollar A M _94893 i) (@dollar A N' _94894 (N.sub i (@dimindex M (@UNIV M))))).
Lemma pastecart_def {A M N' : Type'} : (@pastecart A M N') = (fun _94893 : cart A M => fun _94894 : cart A N' => @lambda A (finite_sum M N') (fun i : N => @COND A (N.le i (@dimindex M (@UNIV M))) (@dollar A M _94893 i) (@dollar A N' _94894 (N.sub i (@dimindex M (@UNIV M)))))).
Proof. exact (eq_refl (@pastecart A M N')). Qed.
Definition fstcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A M := fun _94905 : cart A (finite_sum M N') => @lambda A M (fun i : N => @dollar A (finite_sum M N') _94905 i).
Lemma fstcart_def {A M N' : Type'} : (@fstcart A M N') = (fun _94905 : cart A (finite_sum M N') => @lambda A M (fun i : N => @dollar A (finite_sum M N') _94905 i)).
Proof. exact (eq_refl (@fstcart A M N')). Qed.
Definition sndcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A N' := fun _94910 : cart A (finite_sum M N') => @lambda A N' (fun i : N => @dollar A (finite_sum M N') _94910 (N.add i (@dimindex M (@UNIV M)))).
Lemma sndcart_def {A M N' : Type'} : (@sndcart A M N') = (fun _94910 : cart A (finite_sum M N') => @lambda A N' (fun i : N => @dollar A (finite_sum M N') _94910 (N.add i (@dimindex M (@UNIV M))))).
Proof. exact (eq_refl (@sndcart A M N')). Qed.
Definition _100320 {A : Type'} : (finite_sum A A) -> tybit0 A := fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL 0%N) a' (fun n : N => @BOTTOM (finite_sum A A))) a).
Lemma _100320_def {A : Type'} : (@_100320 A) = (fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL 0%N) a' (fun n : N => @BOTTOM (finite_sum A A))) a)).
Proof. exact (eq_refl (@_100320 A)). Qed.
Definition mktybit0 {A : Type'} : (finite_sum A A) -> tybit0 A := @_100320 A.
Lemma mktybit0_def {A : Type'} : (@mktybit0 A) = (@_100320 A).
Proof. exact (eq_refl (@mktybit0 A)). Qed.
Definition _100339 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL 0%N) a' (fun n : N => @BOTTOM (finite_sum (finite_sum A A) unit))) a).
Lemma _100339_def {A : Type'} : (@_100339 A) = (fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL 0%N) a' (fun n : N => @BOTTOM (finite_sum (finite_sum A A) unit))) a)).
Proof. exact (eq_refl (@_100339 A)). Qed.
Definition mktybit1 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := @_100339 A.
Lemma mktybit1_def {A : Type'} : (@mktybit1 A) = (@_100339 A).
Proof. exact (eq_refl (@mktybit1 A)). Qed.
Definition vector {A N' : Type'} : (list A) -> cart A N' := fun _102033 : list A => @lambda A N' (fun i : N => @EL A (N.sub i (NUMERAL (BIT1 0%N))) _102033).
Lemma vector_def {A N' : Type'} : (@vector A N') = (fun _102033 : list A => @lambda A N' (fun i : N => @EL A (N.sub i (NUMERAL (BIT1 0%N))) _102033)).
Proof. exact (eq_refl (@vector A N')). Qed.
Definition PCROSS {A M N' : Type'} : ((cart A M) -> Prop) -> ((cart A N') -> Prop) -> (cart A (finite_sum M N')) -> Prop := fun _102060 : (cart A M) -> Prop => fun _102061 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102060) /\ (@IN (cart A N') y _102061)) (@pastecart A M N' x y)).
Lemma PCROSS_def {A M N' : Type'} : (@PCROSS A M N') = (fun _102060 : (cart A M) -> Prop => fun _102061 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102060) /\ (@IN (cart A N') y _102061)) (@pastecart A M N' x y))).
Proof. exact (eq_refl (@PCROSS A M N')). Qed.
Definition CASEWISE {_137714 _137750 _137754 _137755 : Type'} : (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714 := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714) (fun CASEWISE' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714 => forall _102665 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@nil (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) f x) = (@ε _137714 (fun y : _137714 => True))) /\ (forall h : prod (_137750 -> _137754) (_137755 -> _137750 -> _137714), forall t : list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)), forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@cons (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)) h t) f x) = (@COND _137714 (exists y : _137750, (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x) (@snd (_137750 -> _137754) (_137755 -> _137750 -> _137714) h f (@ε _137750 (fun y : _137750 => (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x))) (CASEWISE' _102665 t f x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N))))))))))))))).
Lemma CASEWISE_def {_137714 _137750 _137754 _137755 : Type'} : (@CASEWISE _137714 _137750 _137754 _137755) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714) (fun CASEWISE' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) -> (list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) -> _137755 -> _137754 -> _137714 => forall _102665 : prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))), (forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@nil (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714))) f x) = (@ε _137714 (fun y : _137714 => True))) /\ (forall h : prod (_137750 -> _137754) (_137755 -> _137750 -> _137714), forall t : list (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)), forall f : _137755, forall x : _137754, (CASEWISE' _102665 (@cons (prod (_137750 -> _137754) (_137755 -> _137750 -> _137714)) h t) f x) = (@COND _137714 (exists y : _137750, (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x) (@snd (_137750 -> _137754) (_137755 -> _137750 -> _137714) h f (@ε _137750 (fun y : _137750 => (@fst (_137750 -> _137754) (_137755 -> _137750 -> _137714) h y) = x))) (CASEWISE' _102665 t f x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))))))))))).
Proof. exact (eq_refl (@CASEWISE _137714 _137750 _137754 _137755)). Qed.
Definition admissible {_138045 _138048 _138052 _138053 _138058 : Type'} : (_138052 -> _138045 -> Prop) -> ((_138052 -> _138048) -> _138058 -> Prop) -> (_138058 -> _138045) -> ((_138052 -> _138048) -> _138058 -> _138053) -> Prop := fun _103732 : _138052 -> _138045 -> Prop => fun _103733 : (_138052 -> _138048) -> _138058 -> Prop => fun _103734 : _138058 -> _138045 => fun _103735 : (_138052 -> _138048) -> _138058 -> _138053 => forall f : _138052 -> _138048, forall g : _138052 -> _138048, forall a : _138058, ((_103733 f a) /\ ((_103733 g a) /\ (forall z : _138052, (_103732 z (_103734 a)) -> (f z) = (g z)))) -> (_103735 f a) = (_103735 g a).
Lemma admissible_def {_138045 _138048 _138052 _138053 _138058 : Type'} : (@admissible _138045 _138048 _138052 _138053 _138058) = (fun _103732 : _138052 -> _138045 -> Prop => fun _103733 : (_138052 -> _138048) -> _138058 -> Prop => fun _103734 : _138058 -> _138045 => fun _103735 : (_138052 -> _138048) -> _138058 -> _138053 => forall f : _138052 -> _138048, forall g : _138052 -> _138048, forall a : _138058, ((_103733 f a) /\ ((_103733 g a) /\ (forall z : _138052, (_103732 z (_103734 a)) -> (f z) = (g z)))) -> (_103735 f a) = (_103735 g a)).
Proof. exact (eq_refl (@admissible _138045 _138048 _138052 _138053 _138058)). Qed.
Definition tailadmissible {A B P : Type'} : (A -> A -> Prop) -> ((A -> B) -> P -> Prop) -> (P -> A) -> ((A -> B) -> P -> B) -> Prop := fun _103764 : A -> A -> Prop => fun _103765 : (A -> B) -> P -> Prop => fun _103766 : P -> A => fun _103767 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103764 y (G f a))) -> _103764 y (_103766 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103764 z (_103766 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103765 f a) -> (_103767 f a) = (@COND B (P' f a) (f (G f a)) (H f a)))).
Lemma tailadmissible_def {A B P : Type'} : (@tailadmissible A B P) = (fun _103764 : A -> A -> Prop => fun _103765 : (A -> B) -> P -> Prop => fun _103766 : P -> A => fun _103767 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103764 y (G f a))) -> _103764 y (_103766 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103764 z (_103766 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103765 f a) -> (_103767 f a) = (@COND B (P' f a) (f (G f a)) (H f a))))).
Proof. exact (eq_refl (@tailadmissible A B P)). Qed.
Definition superadmissible {_138202 _138204 _138210 : Type'} : (_138202 -> _138202 -> Prop) -> ((_138202 -> _138204) -> _138210 -> Prop) -> (_138210 -> _138202) -> ((_138202 -> _138204) -> _138210 -> _138204) -> Prop := fun _103796 : _138202 -> _138202 -> Prop => fun _103797 : (_138202 -> _138204) -> _138210 -> Prop => fun _103798 : _138210 -> _138202 => fun _103799 : (_138202 -> _138204) -> _138210 -> _138204 => (@admissible _138202 _138204 _138202 Prop _138210 _103796 (fun f : _138202 -> _138204 => fun a : _138210 => True) _103798 _103797) -> @tailadmissible _138202 _138204 _138210 _103796 _103797 _103798 _103799.
Lemma superadmissible_def {_138202 _138204 _138210 : Type'} : (@superadmissible _138202 _138204 _138210) = (fun _103796 : _138202 -> _138202 -> Prop => fun _103797 : (_138202 -> _138204) -> _138210 -> Prop => fun _103798 : _138210 -> _138202 => fun _103799 : (_138202 -> _138204) -> _138210 -> _138204 => (@admissible _138202 _138204 _138202 Prop _138210 _103796 (fun f : _138202 -> _138204 => fun a : _138210 => True) _103798 _103797) -> @tailadmissible _138202 _138204 _138210 _103796 _103797 _103798 _103799).
Proof. exact (eq_refl (@superadmissible _138202 _138204 _138210)). Qed.
Definition fld {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _113720 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_372 : A => exists x : A, @SETSPEC A GEN_PVAR_372 (exists y : A, (_113720 x y) \/ (_113720 y x)) x).
Lemma fld_def {A : Type'} : (@fld A) = (fun _113720 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_372 : A => exists x : A, @SETSPEC A GEN_PVAR_372 (exists y : A, (_113720 x y) \/ (_113720 y x)) x)).
Proof. exact (eq_refl (@fld A)). Qed.
Definition qoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113775 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113775)) -> _113775 x x) /\ (forall x : A, forall y : A, forall z : A, ((_113775 x y) /\ (_113775 y z)) -> _113775 x z).
Lemma qoset_def {A : Type'} : (@qoset A) = (fun _113775 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113775)) -> _113775 x x) /\ (forall x : A, forall y : A, forall z : A, ((_113775 x y) /\ (_113775 y z)) -> _113775 x z)).
Proof. exact (eq_refl (@qoset A)). Qed.
Definition poset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113780 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113780)) -> _113780 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113780 x y) /\ (_113780 y z)) -> _113780 x z) /\ (forall x : A, forall y : A, ((_113780 x y) /\ (_113780 y x)) -> x = y)).
Lemma poset_def {A : Type'} : (@poset A) = (fun _113780 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113780)) -> _113780 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113780 x y) /\ (_113780 y z)) -> _113780 x z) /\ (forall x : A, forall y : A, ((_113780 x y) /\ (_113780 y x)) -> x = y))).
Proof. exact (eq_refl (@poset A)). Qed.
Definition toset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113785 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113785)) -> _113785 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113785 x y) /\ (_113785 y z)) -> _113785 x z) /\ ((forall x : A, forall y : A, ((_113785 x y) /\ (_113785 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _113785)) /\ (@IN A y (@fld A _113785))) -> (_113785 x y) \/ (_113785 y x)))).
Lemma toset_def {A : Type'} : (@toset A) = (fun _113785 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113785)) -> _113785 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113785 x y) /\ (_113785 y z)) -> _113785 x z) /\ ((forall x : A, forall y : A, ((_113785 x y) /\ (_113785 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _113785)) /\ (@IN A y (@fld A _113785))) -> (_113785 x y) \/ (_113785 y x))))).
Proof. exact (eq_refl (@toset A)). Qed.
Definition woset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113790 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113790)) -> _113790 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113790 x y) /\ (_113790 y z)) -> _113790 x z) /\ ((forall x : A, forall y : A, ((_113790 x y) /\ (_113790 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _113790)) /\ (@IN A y (@fld A _113790))) -> (_113790 x y) \/ (_113790 y x)) /\ (forall s : A -> Prop, ((@SUBSET A s (@fld A _113790)) /\ (~ (s = (@EMPTY A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _113790 x y))))).
Lemma woset_def {A : Type'} : (@woset A) = (fun _113790 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113790)) -> _113790 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113790 x y) /\ (_113790 y z)) -> _113790 x z) /\ ((forall x : A, forall y : A, ((_113790 x y) /\ (_113790 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _113790)) /\ (@IN A y (@fld A _113790))) -> (_113790 x y) \/ (_113790 y x)) /\ (forall s : A -> Prop, ((@SUBSET A s (@fld A _113790)) /\ (~ (s = (@EMPTY A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _113790 x y)))))).
Proof. exact (eq_refl (@woset A)). Qed.
Definition wqoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113795 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113795)) -> _113795 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113795 x y) /\ (_113795 y z)) -> _113795 x z) /\ (forall s : A -> Prop, (@SUBSET A s (@fld A _113795)) -> exists t : A -> Prop, (@FINITE A t) /\ ((@SUBSET A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_113795 x y))))).
Lemma wqoset_def {A : Type'} : (@wqoset A) = (fun _113795 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113795)) -> _113795 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113795 x y) /\ (_113795 y z)) -> _113795 x z) /\ (forall s : A -> Prop, (@SUBSET A s (@fld A _113795)) -> exists t : A -> Prop, (@FINITE A t) /\ ((@SUBSET A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_113795 x y)))))).
Proof. exact (eq_refl (@wqoset A)). Qed.
Definition chain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _113800 : A -> A -> Prop => fun _113801 : A -> Prop => forall x : A, forall y : A, ((@IN A x _113801) /\ (@IN A y _113801)) -> (_113800 x y) \/ (_113800 y x).
Lemma chain_def {A : Type'} : (@chain A) = (fun _113800 : A -> A -> Prop => fun _113801 : A -> Prop => forall x : A, forall y : A, ((@IN A x _113801) /\ (@IN A y _113801)) -> (_113800 x y) \/ (_113800 y x)).
Proof. exact (eq_refl (@chain A)). Qed.
Definition antichain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _113812 : A -> A -> Prop => fun _113813 : A -> Prop => (@SUBSET A _113813 (@fld A _113812)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_113812 x y)) _113813).
Lemma antichain_def {A : Type'} : (@antichain A) = (fun _113812 : A -> A -> Prop => fun _113813 : A -> Prop => (@SUBSET A _113813 (@fld A _113812)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_113812 x y)) _113813)).
Proof. exact (eq_refl (@antichain A)). Qed.
Definition strictly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _114465 : A -> A -> Prop => fun x : A => fun y : A => (_114465 x y) /\ (~ (_114465 y x)).
Lemma strictly_def {A : Type'} : (@strictly A) = (fun _114465 : A -> A -> Prop => fun x : A => fun y : A => (_114465 x y) /\ (~ (_114465 y x))).
Proof. exact (eq_refl (@strictly A)). Qed.
Definition properly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _114470 : A -> A -> Prop => fun x : A => fun y : A => (_114470 x y) /\ (~ (x = y)).
Lemma properly_def {A : Type'} : (@properly A) = (fun _114470 : A -> A -> Prop => fun x : A => fun y : A => (_114470 x y) /\ (~ (x = y))).
Proof. exact (eq_refl (@properly A)). Qed.
Definition inseg {A : Type'} : (A -> A -> Prop) -> (A -> A -> Prop) -> Prop := fun _118731 : A -> A -> Prop => fun _118732 : A -> A -> Prop => forall x : A, forall y : A, (_118731 x y) = ((_118732 x y) /\ (@fld A _118731 y)).
Lemma inseg_def {A : Type'} : (@inseg A) = (fun _118731 : A -> A -> Prop => fun _118732 : A -> A -> Prop => forall x : A, forall y : A, (_118731 x y) = ((_118732 x y) /\ (@fld A _118731 y))).
Proof. exact (eq_refl (@inseg A)). Qed.
Definition linseg {A : Type'} : (A -> A -> Prop) -> A -> A -> A -> Prop := fun _118803 : A -> A -> Prop => fun _118804 : A => fun x : A => fun y : A => (_118803 x y) /\ (@properly A _118803 y _118804).
Lemma linseg_def {A : Type'} : (@linseg A) = (fun _118803 : A -> A -> Prop => fun _118804 : A => fun x : A => fun y : A => (_118803 x y) /\ (@properly A _118803 y _118804)).
Proof. exact (eq_refl (@linseg A)). Qed.
Definition ordinal {A : Type'} : (A -> A -> Prop) -> Prop := fun _118815 : A -> A -> Prop => (@woset A _118815) /\ (forall x : A, (@fld A _118815 x) -> x = (@ε A (fun y : A => ~ (@properly A _118815 y x)))).
Lemma ordinal_def {A : Type'} : (@ordinal A) = (fun _118815 : A -> A -> Prop => (@woset A _118815) /\ (forall x : A, (@fld A _118815 x) -> x = (@ε A (fun y : A => ~ (@properly A _118815 y x))))).
Proof. exact (eq_refl (@ordinal A)). Qed.
Definition add_c {_154958 _154959 : Type'} : (_154959 -> Prop) -> (_154958 -> Prop) -> (Datatypes.sum _154959 _154958) -> Prop := fun _201284 : _154959 -> Prop => fun _201285 : _154958 -> Prop => @UNION (Datatypes.sum _154959 _154958) (@GSPEC (Datatypes.sum _154959 _154958) (fun GEN_PVAR_406 : Datatypes.sum _154959 _154958 => exists x : _154959, @SETSPEC (Datatypes.sum _154959 _154958) GEN_PVAR_406 (@IN _154959 x _201284) (@inl _154959 _154958 x))) (@GSPEC (Datatypes.sum _154959 _154958) (fun GEN_PVAR_407 : Datatypes.sum _154959 _154958 => exists y : _154958, @SETSPEC (Datatypes.sum _154959 _154958) GEN_PVAR_407 (@IN _154958 y _201285) (@inr _154959 _154958 y))).
Lemma add_c_def {_154958 _154959 : Type'} : (@add_c _154958 _154959) = (fun _201284 : _154959 -> Prop => fun _201285 : _154958 -> Prop => @UNION (Datatypes.sum _154959 _154958) (@GSPEC (Datatypes.sum _154959 _154958) (fun GEN_PVAR_406 : Datatypes.sum _154959 _154958 => exists x : _154959, @SETSPEC (Datatypes.sum _154959 _154958) GEN_PVAR_406 (@IN _154959 x _201284) (@inl _154959 _154958 x))) (@GSPEC (Datatypes.sum _154959 _154958) (fun GEN_PVAR_407 : Datatypes.sum _154959 _154958 => exists y : _154958, @SETSPEC (Datatypes.sum _154959 _154958) GEN_PVAR_407 (@IN _154958 y _201285) (@inr _154959 _154958 y)))).
Proof. exact (eq_refl (@add_c _154958 _154959)). Qed.
Definition mul_c {_154991 _154992 : Type'} : (_154992 -> Prop) -> (_154991 -> Prop) -> (prod _154992 _154991) -> Prop := fun _201296 : _154992 -> Prop => fun _201297 : _154991 -> Prop => @GSPEC (prod _154992 _154991) (fun GEN_PVAR_408 : prod _154992 _154991 => exists x : _154992, exists y : _154991, @SETSPEC (prod _154992 _154991) GEN_PVAR_408 ((@IN _154992 x _201296) /\ (@IN _154991 y _201297)) (@pair _154992 _154991 x y)).
Lemma mul_c_def {_154991 _154992 : Type'} : (@mul_c _154991 _154992) = (fun _201296 : _154992 -> Prop => fun _201297 : _154991 -> Prop => @GSPEC (prod _154992 _154991) (fun GEN_PVAR_408 : prod _154992 _154991 => exists x : _154992, exists y : _154991, @SETSPEC (prod _154992 _154991) GEN_PVAR_408 ((@IN _154992 x _201296) /\ (@IN _154991 y _201297)) (@pair _154992 _154991 x y))).
Proof. exact (eq_refl (@mul_c _154991 _154992)). Qed.
Definition pow_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> (B -> A) -> Prop := fun _237577 : A -> Prop => fun _237578 : B -> Prop => @GSPEC (B -> A) (fun GEN_PVAR_450 : B -> A => exists f : B -> A, @SETSPEC (B -> A) GEN_PVAR_450 ((forall x : B, (@IN B x _237578) -> @IN A (f x) _237577) /\ (forall x : B, (~ (@IN B x _237578)) -> (f x) = (@ε A (fun y : A => False)))) f).
Lemma pow_c_def {A B : Type'} : (@pow_c A B) = (fun _237577 : A -> Prop => fun _237578 : B -> Prop => @GSPEC (B -> A) (fun GEN_PVAR_450 : B -> A => exists f : B -> A, @SETSPEC (B -> A) GEN_PVAR_450 ((forall x : B, (@IN B x _237578) -> @IN A (f x) _237577) /\ (forall x : B, (~ (@IN B x _237578)) -> (f x) = (@ε A (fun y : A => False)))) f)).
Proof. exact (eq_refl (@pow_c A B)). Qed.
Definition permutes {_172930 : Type'} : (_172930 -> _172930) -> (_172930 -> Prop) -> Prop := fun _245176 : _172930 -> _172930 => fun _245177 : _172930 -> Prop => (forall x : _172930, (~ (@IN _172930 x _245177)) -> (_245176 x) = x) /\ (forall y : _172930, @ex1 _172930 (fun x : _172930 => (_245176 x) = y)).
Lemma permutes_def {_172930 : Type'} : (@permutes _172930) = (fun _245176 : _172930 -> _172930 => fun _245177 : _172930 -> Prop => (forall x : _172930, (~ (@IN _172930 x _245177)) -> (_245176 x) = x) /\ (forall y : _172930, @ex1 _172930 (fun x : _172930 => (_245176 x) = y))).
Proof. exact (eq_refl (@permutes _172930)). Qed.
Definition inverse {_172945 _172948 : Type'} : (_172948 -> _172945) -> _172945 -> _172948 := fun _245188 : _172948 -> _172945 => fun y : _172945 => @ε _172948 (fun x : _172948 => (_245188 x) = y).
Lemma inverse_def {_172945 _172948 : Type'} : (@inverse _172945 _172948) = (fun _245188 : _172948 -> _172945 => fun y : _172945 => @ε _172948 (fun x : _172948 => (_245188 x) = y)).
Proof. exact (eq_refl (@inverse _172945 _172948)). Qed.
Definition swap {_173152 : Type'} : (prod _173152 _173152) -> _173152 -> _173152 := fun _245602 : prod _173152 _173152 => fun _245603 : _173152 => @COND _173152 (_245603 = (@fst _173152 _173152 _245602)) (@snd _173152 _173152 _245602) (@COND _173152 (_245603 = (@snd _173152 _173152 _245602)) (@fst _173152 _173152 _245602) _245603).
Lemma swap_def {_173152 : Type'} : (@swap _173152) = (fun _245602 : prod _173152 _173152 => fun _245603 : _173152 => @COND _173152 (_245603 = (@fst _173152 _173152 _245602)) (@snd _173152 _173152 _245602) (@COND _173152 (_245603 = (@snd _173152 _173152 _245602)) (@fst _173152 _173152 _245602) _245603)).
Proof. exact (eq_refl (@swap _173152)). Qed.
Definition swapseq {_196374 : Type'} : N -> (_196374 -> _196374) -> Prop := fun a0 : N => fun a1 : _196374 -> _196374 => forall swapseq' : N -> (_196374 -> _196374) -> Prop, (forall a0' : N, forall a1' : _196374 -> _196374, (((a0' = (NUMERAL 0%N)) /\ (a1' = (@I _196374))) \/ (exists a : _196374, exists b : _196374, exists p : _196374 -> _196374, exists n : N, (a0' = (N.succ n)) /\ ((a1' = (@o _196374 _196374 _196374 (@swap _196374 (@pair _196374 _196374 a b)) p)) /\ ((swapseq' n p) /\ (~ (a = b)))))) -> swapseq' a0' a1') -> swapseq' a0 a1.
Lemma swapseq_def {_196374 : Type'} : (@swapseq _196374) = (fun a0 : N => fun a1 : _196374 -> _196374 => forall swapseq' : N -> (_196374 -> _196374) -> Prop, (forall a0' : N, forall a1' : _196374 -> _196374, (((a0' = (NUMERAL 0%N)) /\ (a1' = (@I _196374))) \/ (exists a : _196374, exists b : _196374, exists p : _196374 -> _196374, exists n : N, (a0' = (N.succ n)) /\ ((a1' = (@o _196374 _196374 _196374 (@swap _196374 (@pair _196374 _196374 a b)) p)) /\ ((swapseq' n p) /\ (~ (a = b)))))) -> swapseq' a0' a1') -> swapseq' a0 a1).
Proof. exact (eq_refl (@swapseq _196374)). Qed.
Definition permutation {_196388 : Type'} : (_196388 -> _196388) -> Prop := fun _253246 : _196388 -> _196388 => exists n : N, @swapseq _196388 n _253246.
Lemma permutation_def {_196388 : Type'} : (@permutation _196388) = (fun _253246 : _196388 -> _196388 => exists n : N, @swapseq _196388 n _253246).
Proof. exact (eq_refl (@permutation _196388)). Qed.
Definition evenperm {_197091 : Type'} : (_197091 -> _197091) -> Prop := fun _256183 : _197091 -> _197091 => EVEN (@ε N (fun n : N => @swapseq _197091 n _256183)).
Lemma evenperm_def {_197091 : Type'} : (@evenperm _197091) = (fun _256183 : _197091 -> _197091 => EVEN (@ε N (fun n : N => @swapseq _197091 n _256183))).
Proof. exact (eq_refl (@evenperm _197091)). Qed.
Definition sign {_198015 : Type'} : (_198015 -> _198015) -> R := fun _258425 : _198015 -> _198015 => @COND R (@evenperm _198015 _258425) (R_of_N (NUMERAL (BIT1 0%N))) (Ropp (R_of_N (NUMERAL (BIT1 0%N)))).
Lemma sign_def {_198015 : Type'} : (@sign _198015) = (fun _258425 : _198015 -> _198015 => @COND R (@evenperm _198015 _258425) (R_of_N (NUMERAL (BIT1 0%N))) (Ropp (R_of_N (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl (@sign _198015)). Qed.
Definition rational : R -> Prop := fun _268901 : R => exists m : R, exists n : R, (integer m) /\ ((integer n) /\ ((~ (n = (R_of_N (NUMERAL 0%N)))) /\ (_268901 = (Rdiv m n)))).
Lemma rational_def : rational = (fun _268901 : R => exists m : R, exists n : R, (integer m) /\ ((integer n) /\ ((~ (n = (R_of_N (NUMERAL 0%N)))) /\ (_268901 = (Rdiv m n))))).
Proof. exact (eq_refl rational). Qed.
Definition floor : R -> R := @ε ((prod N (prod N (prod N (prod N N)))) -> R -> R) (fun n : (prod N (prod N (prod N (prod N N)))) -> R -> R => forall _269283 : prod N (prod N (prod N (prod N N))), exists r : R -> R, forall x : R, (integer (n _269283 x)) /\ ((Rle (R_of_N (NUMERAL 0%N)) (r x)) /\ ((Rlt (r x) (R_of_N (NUMERAL (BIT1 0%N)))) /\ (x = (Rplus (n _269283 x) (r x)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))).
Lemma floor_def : floor = (@ε ((prod N (prod N (prod N (prod N N)))) -> R -> R) (fun n : (prod N (prod N (prod N (prod N N)))) -> R -> R => forall _269283 : prod N (prod N (prod N (prod N N))), exists r : R -> R, forall x : R, (integer (n _269283 x)) /\ ((Rle (R_of_N (NUMERAL 0%N)) (r x)) /\ ((Rlt (r x) (R_of_N (NUMERAL (BIT1 0%N)))) /\ (x = (Rplus (n _269283 x) (r x)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))).
Proof. exact (eq_refl floor). Qed.
Definition frac : R -> R := @ε ((prod N (prod N (prod N N))) -> R -> R) (fun r : (prod N (prod N (prod N N))) -> R -> R => forall _269284 : prod N (prod N (prod N N)), forall x : R, (integer (floor x)) /\ ((Rle (R_of_N (NUMERAL 0%N)) (r _269284 x)) /\ ((Rlt (r _269284 x) (R_of_N (NUMERAL (BIT1 0%N)))) /\ (x = (Rplus (floor x) (r _269284 x)))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))).
Lemma frac_def : frac = (@ε ((prod N (prod N (prod N N))) -> R -> R) (fun r : (prod N (prod N (prod N N))) -> R -> R => forall _269284 : prod N (prod N (prod N N)), forall x : R, (integer (floor x)) /\ ((Rle (R_of_N (NUMERAL 0%N)) (r _269284 x)) /\ ((Rlt (r _269284 x) (R_of_N (NUMERAL (BIT1 0%N)))) /\ (x = (Rplus (floor x) (r _269284 x)))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl frac). Qed.
Definition is_realinterval : (R -> Prop) -> Prop := fun _271022 : R -> Prop => forall a : R, forall b : R, forall c : R, ((@IN R a _271022) /\ ((@IN R b _271022) /\ ((Rle a c) /\ (Rle c b)))) -> @IN R c _271022.
Lemma is_realinterval_def : is_realinterval = (fun _271022 : R -> Prop => forall a : R, forall b : R, forall c : R, ((@IN R a _271022) /\ ((@IN R b _271022) /\ ((Rle a c) /\ (Rle c b)))) -> @IN R c _271022).
Proof. exact (eq_refl is_realinterval). Qed.
Definition open_real_interval : (prod R R) -> R -> Prop := fun _271083 : prod R R => @GSPEC R (fun GEN_PVAR_630 : R => exists x : R, @SETSPEC R GEN_PVAR_630 ((Rlt (@fst R R _271083) x) /\ (Rlt x (@snd R R _271083))) x).
Lemma open_real_interval_def : open_real_interval = (fun _271083 : prod R R => @GSPEC R (fun GEN_PVAR_630 : R => exists x : R, @SETSPEC R GEN_PVAR_630 ((Rlt (@fst R R _271083) x) /\ (Rlt x (@snd R R _271083))) x)).
Proof. exact (eq_refl open_real_interval). Qed.
Definition closed_real_interval : (list (prod R R)) -> R -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) -> (list (prod R R)) -> R -> Prop) (fun closed_real_interval' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) -> (list (prod R R)) -> R -> Prop => forall _271202 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))), forall a : R, forall b : R, (closed_real_interval' _271202 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_631 : R => exists x : R, @SETSPEC R GEN_PVAR_631 ((Rle a x) /\ (Rle x b)) x))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))))).
Lemma closed_real_interval_def : closed_real_interval = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) -> (list (prod R R)) -> R -> Prop) (fun closed_real_interval' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) -> (list (prod R R)) -> R -> Prop => forall _271202 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))), forall a : R, forall b : R, (closed_real_interval' _271202 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_631 : R => exists x : R, @SETSPEC R GEN_PVAR_631 ((Rle a x) /\ (Rle x b)) x))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))))))).
Proof. exact (eq_refl closed_real_interval). Qed.
Definition vectorize {A M N' : Type'} : (cart (cart A N') M) -> cart A (finite_prod M N') := fun x : cart (cart A N') M => @lambda A (finite_prod M N') (fun i : N => @dollar A N' (@dollar (cart A N') M x (N.add (NUMERAL (BIT1 0%N)) (N.div (N.sub i (NUMERAL (BIT1 0%N))) (@dimindex N' (@UNIV N'))))) (N.add (NUMERAL (BIT1 0%N)) (N.modulo (N.sub i (NUMERAL (BIT1 0%N))) (@dimindex N' (@UNIV N'))))).
Lemma vectorize_def {A M N' : Type'} : (@vectorize A M N') = (fun x : cart (cart A N') M => @lambda A (finite_prod M N') (fun i : N => @dollar A N' (@dollar (cart A N') M x (N.add (NUMERAL (BIT1 0%N)) (N.div (N.sub i (NUMERAL (BIT1 0%N))) (@dimindex N' (@UNIV N'))))) (N.add (NUMERAL (BIT1 0%N)) (N.modulo (N.sub i (NUMERAL (BIT1 0%N))) (@dimindex N' (@UNIV N')))))).
Proof. exact (eq_refl (@vectorize A M N')). Qed.
Definition matrify {A M N' : Type'} : (cart A (finite_prod M N')) -> cart (cart A N') M := fun x : cart A (finite_prod M N') => @lambda (cart A N') M (fun i : N => @lambda A N' (fun j : N => @dollar A (finite_prod M N') x (N.add (N.mul (N.sub i (NUMERAL (BIT1 0%N))) (@dimindex N' (@UNIV N'))) j))).
Lemma matrify_def {A M N' : Type'} : (@matrify A M N') = (fun x : cart A (finite_prod M N') => @lambda (cart A N') M (fun i : N => @lambda A N' (fun j : N => @dollar A (finite_prod M N') x (N.add (N.mul (N.sub i (NUMERAL (BIT1 0%N))) (@dimindex N' (@UNIV N'))) j)))).
Proof. exact (eq_refl (@matrify A M N')). Qed.
Definition hull {_219255 : Type'} : ((_219255 -> Prop) -> Prop) -> (_219255 -> Prop) -> _219255 -> Prop := fun _272381 : (_219255 -> Prop) -> Prop => fun _272382 : _219255 -> Prop => @INTERS _219255 (@GSPEC (_219255 -> Prop) (fun GEN_PVAR_636 : _219255 -> Prop => exists t : _219255 -> Prop, @SETSPEC (_219255 -> Prop) GEN_PVAR_636 ((_272381 t) /\ (@SUBSET _219255 _272382 t)) t)).
Lemma hull_def {_219255 : Type'} : (@hull _219255) = (fun _272381 : (_219255 -> Prop) -> Prop => fun _272382 : _219255 -> Prop => @INTERS _219255 (@GSPEC (_219255 -> Prop) (fun GEN_PVAR_636 : _219255 -> Prop => exists t : _219255 -> Prop, @SETSPEC (_219255 -> Prop) GEN_PVAR_636 ((_272381 t) /\ (@SUBSET _219255 _272382 t)) t))).
Proof. exact (eq_refl (@hull _219255)). Qed.
Definition from : N -> N -> Prop := fun _273299 : N => @GSPEC N (fun GEN_PVAR_641 : N => exists m : N, @SETSPEC N GEN_PVAR_641 (N.le _273299 m) m).
Lemma from_def : from = (fun _273299 : N => @GSPEC N (fun GEN_PVAR_641 : N => exists m : N, @SETSPEC N GEN_PVAR_641 (N.le _273299 m) m)).
Proof. exact (eq_refl from). Qed.
Definition relative_to {_231294 : Type'} : ((_231294 -> Prop) -> Prop) -> (_231294 -> Prop) -> (_231294 -> Prop) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> ((_231294 -> Prop) -> Prop) -> (_231294 -> Prop) -> (_231294 -> Prop) -> Prop) (fun relative_to' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> ((_231294 -> Prop) -> Prop) -> (_231294 -> Prop) -> (_231294 -> Prop) -> Prop => forall _276925 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), forall P : (_231294 -> Prop) -> Prop, forall s : _231294 -> Prop, forall t : _231294 -> Prop, (relative_to' _276925 P s t) = (exists u : _231294 -> Prop, (P u) /\ ((@INTER _231294 s u) = t))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))).
Lemma relative_to_def {_231294 : Type'} : (@relative_to _231294) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> ((_231294 -> Prop) -> Prop) -> (_231294 -> Prop) -> (_231294 -> Prop) -> Prop) (fun relative_to' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> ((_231294 -> Prop) -> Prop) -> (_231294 -> Prop) -> (_231294 -> Prop) -> Prop => forall _276925 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), forall P : (_231294 -> Prop) -> Prop, forall s : _231294 -> Prop, forall t : _231294 -> Prop, (relative_to' _276925 P s t) = (exists u : _231294 -> Prop, (P u) /\ ((@INTER _231294 s u) = t))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))).
Proof. exact (eq_refl (@relative_to _231294)). Qed.
Definition suslin_operation {A : Type'} : ((list N) -> A -> Prop) -> A -> Prop := fun _305416 : (list N) -> A -> Prop => @UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_682 : A -> Prop => exists s : N -> N, @SETSPEC (A -> Prop) GEN_PVAR_682 (@IN (N -> N) s (@UNIV (N -> N))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_681 : A -> Prop => exists n : N, @SETSPEC (A -> Prop) GEN_PVAR_681 (N.le (NUMERAL (BIT1 0%N)) n) (_305416 (@list_of_seq N s n))))))).
Lemma suslin_operation_def {A : Type'} : (@suslin_operation A) = (fun _305416 : (list N) -> A -> Prop => @UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_682 : A -> Prop => exists s : N -> N, @SETSPEC (A -> Prop) GEN_PVAR_682 (@IN (N -> N) s (@UNIV (N -> N))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_681 : A -> Prop => exists n : N, @SETSPEC (A -> Prop) GEN_PVAR_681 (N.le (NUMERAL (BIT1 0%N)) n) (_305416 (@list_of_seq N s n)))))))).
Proof. exact (eq_refl (@suslin_operation A)). Qed.
Definition suslin {_235636 : Type'} : ((_235636 -> Prop) -> Prop) -> (_235636 -> Prop) -> Prop := fun _305421 : (_235636 -> Prop) -> Prop => @GSPEC (_235636 -> Prop) (fun GEN_PVAR_683 : _235636 -> Prop => exists f : (list N) -> _235636 -> Prop, @SETSPEC (_235636 -> Prop) GEN_PVAR_683 (forall l : list N, (~ (l = (@nil N))) -> @IN (_235636 -> Prop) (f l) _305421) (@suslin_operation _235636 f)).
Lemma suslin_def {_235636 : Type'} : (@suslin _235636) = (fun _305421 : (_235636 -> Prop) -> Prop => @GSPEC (_235636 -> Prop) (fun GEN_PVAR_683 : _235636 -> Prop => exists f : (list N) -> _235636 -> Prop, @SETSPEC (_235636 -> Prop) GEN_PVAR_683 (forall l : list N, (~ (l = (@nil N))) -> @IN (_235636 -> Prop) (f l) _305421) (@suslin_operation _235636 f))).
Proof. exact (eq_refl (@suslin _235636)). Qed.
Definition ITER {_237857 : Type'} : N -> (_237857 -> _237857) -> _237857 -> _237857 := @ε ((prod N (prod N (prod N N))) -> N -> (_237857 -> _237857) -> _237857 -> _237857) (fun ITER' : (prod N (prod N (prod N N))) -> N -> (_237857 -> _237857) -> _237857 -> _237857 => forall _337618 : prod N (prod N (prod N N)), (forall x : _237857, forall f : _237857 -> _237857, (ITER' _337618 (NUMERAL 0%N) f x) = x) /\ (forall x : _237857, forall f : _237857 -> _237857, forall n : N, (ITER' _337618 (N.succ n) f x) = (f (ITER' _337618 n f x)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N))))))))))).
Lemma ITER_def {_237857 : Type'} : (@ITER _237857) = (@ε ((prod N (prod N (prod N N))) -> N -> (_237857 -> _237857) -> _237857 -> _237857) (fun ITER' : (prod N (prod N (prod N N))) -> N -> (_237857 -> _237857) -> _237857 -> _237857 => forall _337618 : prod N (prod N (prod N N)), (forall x : _237857, forall f : _237857 -> _237857, (ITER' _337618 (NUMERAL 0%N) f x) = x) /\ (forall x : _237857, forall f : _237857 -> _237857, forall n : N, (ITER' _337618 (N.succ n) f x) = (f (ITER' _337618 n f x)))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0%N)))))))))))).
Proof. exact (eq_refl (@ITER _237857)). Qed.
Definition frag_support {A : Type'} : (frag A) -> A -> Prop := fun _338801 : frag A => @GSPEC A (fun GEN_PVAR_710 : A => exists a : A, @SETSPEC A GEN_PVAR_710 (~ ((@dest_frag A _338801 a) = (Z_of_N (NUMERAL 0%N)))) a).
Lemma frag_support_def {A : Type'} : (@frag_support A) = (fun _338801 : frag A => @GSPEC A (fun GEN_PVAR_710 : A => exists a : A, @SETSPEC A GEN_PVAR_710 (~ ((@dest_frag A _338801 a) = (Z_of_N (NUMERAL 0%N)))) a)).
Proof. exact (eq_refl (@frag_support A)). Qed.
Definition frag_0 {A : Type'} : frag A := @mk_frag A (fun x : A => Z_of_N (NUMERAL 0%N)).
Lemma frag_0_def {A : Type'} : (@frag_0 A) = (@mk_frag A (fun x : A => Z_of_N (NUMERAL 0%N))).
Proof. exact (eq_refl (@frag_0 A)). Qed.
Definition frag_of {A : Type'} : A -> frag A := fun _338806 : A => @mk_frag A (fun a : A => @COND Z (a = _338806) (Z_of_N (NUMERAL (BIT1 0%N))) (Z_of_N (NUMERAL 0%N))).
Lemma frag_of_def {A : Type'} : (@frag_of A) = (fun _338806 : A => @mk_frag A (fun a : A => @COND Z (a = _338806) (Z_of_N (NUMERAL (BIT1 0%N))) (Z_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl (@frag_of A)). Qed.
Definition frag_neg {A : Type'} : (frag A) -> frag A := fun _338811 : frag A => @mk_frag A (fun a : A => Z.opp (@dest_frag A _338811 a)).
Lemma frag_neg_def {A : Type'} : (@frag_neg A) = (fun _338811 : frag A => @mk_frag A (fun a : A => Z.opp (@dest_frag A _338811 a))).
Proof. exact (eq_refl (@frag_neg A)). Qed.
Definition frag_cmul {A : Type'} : Z -> (frag A) -> frag A := fun _338816 : Z => fun _338817 : frag A => @mk_frag A (fun a : A => Z.mul _338816 (@dest_frag A _338817 a)).
Lemma frag_cmul_def {A : Type'} : (@frag_cmul A) = (fun _338816 : Z => fun _338817 : frag A => @mk_frag A (fun a : A => Z.mul _338816 (@dest_frag A _338817 a))).
Proof. exact (eq_refl (@frag_cmul A)). Qed.
Definition frag_add {A : Type'} : (frag A) -> (frag A) -> frag A := fun _338828 : frag A => fun _338829 : frag A => @mk_frag A (fun a : A => Z.add (@dest_frag A _338828 a) (@dest_frag A _338829 a)).
Lemma frag_add_def {A : Type'} : (@frag_add A) = (fun _338828 : frag A => fun _338829 : frag A => @mk_frag A (fun a : A => Z.add (@dest_frag A _338828 a) (@dest_frag A _338829 a))).
Proof. exact (eq_refl (@frag_add A)). Qed.
Definition frag_sub {A : Type'} : (frag A) -> (frag A) -> frag A := fun _338840 : frag A => fun _338841 : frag A => @mk_frag A (fun a : A => Z.sub (@dest_frag A _338840 a) (@dest_frag A _338841 a)).
Lemma frag_sub_def {A : Type'} : (@frag_sub A) = (fun _338840 : frag A => fun _338841 : frag A => @mk_frag A (fun a : A => Z.sub (@dest_frag A _338840 a) (@dest_frag A _338841 a))).
Proof. exact (eq_refl (@frag_sub A)). Qed.
Definition frag_extend {A B : Type'} : (A -> frag B) -> (frag A) -> frag B := fun _339446 : A -> frag B => fun _339447 : frag A => @iterate A (frag B) (@frag_add B) (@frag_support A _339447) (fun a : A => @frag_cmul B (@dest_frag A _339447 a) (_339446 a)).
Lemma frag_extend_def {A B : Type'} : (@frag_extend A B) = (fun _339446 : A -> frag B => fun _339447 : frag A => @iterate A (frag B) (@frag_add B) (@frag_support A _339447) (fun a : A => @frag_cmul B (@dest_frag A _339447 a) (_339446 a))).
Proof. exact (eq_refl (@frag_extend A B)). Qed.
Definition index : N -> N -> N := fun _346634 : N => fun _346635 : N => @COND N ((N.le _346634 (NUMERAL (BIT1 0%N))) \/ (_346635 = (NUMERAL 0%N))) (NUMERAL 0%N) (@CARD N (@GSPEC N (fun GEN_PVAR_729 : N => exists j : N, @SETSPEC N GEN_PVAR_729 ((N.le (NUMERAL (BIT1 0%N)) j) /\ (num_divides (N.pow _346634 j) _346635)) j))).
Lemma index_def : index = (fun _346634 : N => fun _346635 : N => @COND N ((N.le _346634 (NUMERAL (BIT1 0%N))) \/ (_346635 = (NUMERAL 0%N))) (NUMERAL 0%N) (@CARD N (@GSPEC N (fun GEN_PVAR_729 : N => exists j : N, @SETSPEC N GEN_PVAR_729 ((N.le (NUMERAL (BIT1 0%N)) j) /\ (num_divides (N.pow _346634 j) _346635)) j)))).
Proof. exact (eq_refl index). Qed.
Definition group_carrier {A : Type'} : (Group A) -> A -> Prop := fun g : Group A => @fst (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g).
Lemma group_carrier_def {A : Type'} : (@group_carrier A) = (fun g : Group A => @fst (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g)).
Proof. exact (eq_refl (@group_carrier A)). Qed.
Definition group_id {A : Type'} : (Group A) -> A := fun g : Group A => @fst A (prod (A -> A) (A -> A -> A)) (@snd (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g)).
Lemma group_id_def {A : Type'} : (@group_id A) = (fun g : Group A => @fst A (prod (A -> A) (A -> A -> A)) (@snd (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g))).
Proof. exact (eq_refl (@group_id A)). Qed.
Definition group_inv {A : Type'} : (Group A) -> A -> A := fun g : Group A => @fst (A -> A) (A -> A -> A) (@snd A (prod (A -> A) (A -> A -> A)) (@snd (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g))).
Lemma group_inv_def {A : Type'} : (@group_inv A) = (fun g : Group A => @fst (A -> A) (A -> A -> A) (@snd A (prod (A -> A) (A -> A -> A)) (@snd (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g)))).
Proof. exact (eq_refl (@group_inv A)). Qed.
Definition group_mul {A : Type'} : (Group A) -> A -> A -> A := fun g : Group A => @snd (A -> A) (A -> A -> A) (@snd A (prod (A -> A) (A -> A -> A)) (@snd (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g))).
Lemma group_mul_def {A : Type'} : (@group_mul A) = (fun g : Group A => @snd (A -> A) (A -> A -> A) (@snd A (prod (A -> A) (A -> A -> A)) (@snd (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_operations A g)))).
Proof. exact (eq_refl (@group_mul A)). Qed.
Definition singleton_group {A : Type'} : A -> Group A := fun _354213 : A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INSERT A _354213 (@EMPTY A)) (@pair A (prod (A -> A) (A -> A -> A)) _354213 (@pair (A -> A) (A -> A -> A) (fun x : A => _354213) (fun x : A => fun y : A => _354213)))).
Lemma singleton_group_def {A : Type'} : (@singleton_group A) = (fun _354213 : A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INSERT A _354213 (@EMPTY A)) (@pair A (prod (A -> A) (A -> A -> A)) _354213 (@pair (A -> A) (A -> A -> A) (fun x : A => _354213) (fun x : A => fun y : A => _354213))))).
Proof. exact (eq_refl (@singleton_group A)). Qed.
Definition trivial_group {_255474 : Type'} : (Group _255474) -> Prop := fun _354218 : Group _255474 => (@group_carrier _255474 _354218) = (@INSERT _255474 (@group_id _255474 _354218) (@EMPTY _255474)).
Lemma trivial_group_def {_255474 : Type'} : (@trivial_group _255474) = (fun _354218 : Group _255474 => (@group_carrier _255474 _354218) = (@INSERT _255474 (@group_id _255474 _354218) (@EMPTY _255474))).
Proof. exact (eq_refl (@trivial_group _255474)). Qed.
Definition opposite_group {A : Type'} : (Group A) -> Group A := fun _354284 : Group A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_carrier A _354284) (@pair A (prod (A -> A) (A -> A -> A)) (@group_id A _354284) (@pair (A -> A) (A -> A -> A) (@group_inv A _354284) (fun x : A => fun y : A => @group_mul A _354284 y x)))).
Lemma opposite_group_def {A : Type'} : (@opposite_group A) = (fun _354284 : Group A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@group_carrier A _354284) (@pair A (prod (A -> A) (A -> A -> A)) (@group_id A _354284) (@pair (A -> A) (A -> A -> A) (@group_inv A _354284) (fun x : A => fun y : A => @group_mul A _354284 y x))))).
Proof. exact (eq_refl (@opposite_group A)). Qed.
Definition group_div {_255847 : Type'} : (Group _255847) -> _255847 -> _255847 -> _255847 := fun _354289 : Group _255847 => fun _354290 : _255847 => fun _354291 : _255847 => @group_mul _255847 _354289 _354290 (@group_inv _255847 _354289 _354291).
Lemma group_div_def {_255847 : Type'} : (@group_div _255847) = (fun _354289 : Group _255847 => fun _354290 : _255847 => fun _354291 : _255847 => @group_mul _255847 _354289 _354290 (@group_inv _255847 _354289 _354291)).
Proof. exact (eq_refl (@group_div _255847)). Qed.
Definition group_pow {_257039 : Type'} : (Group _257039) -> _257039 -> N -> _257039 := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (Group _257039) -> _257039 -> N -> _257039) (fun group_pow' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (Group _257039) -> _257039 -> N -> _257039 => forall _354924 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall x : _257039, forall G : Group _257039, (group_pow' _354924 G x (NUMERAL 0%N)) = (@group_id _257039 G)) /\ (forall G : Group _257039, forall x : _257039, forall n : N, (group_pow' _354924 G x (N.succ n)) = (@group_mul _257039 G x (group_pow' _354924 G x n)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))).
Lemma group_pow_def {_257039 : Type'} : (@group_pow _257039) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (Group _257039) -> _257039 -> N -> _257039) (fun group_pow' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> (Group _257039) -> _257039 -> N -> _257039 => forall _354924 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall x : _257039, forall G : Group _257039, (group_pow' _354924 G x (NUMERAL 0%N)) = (@group_id _257039 G)) /\ (forall G : Group _257039, forall x : _257039, forall n : N, (group_pow' _354924 G x (N.succ n)) = (@group_mul _257039 G x (group_pow' _354924 G x n)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))).
Proof. exact (eq_refl (@group_pow _257039)). Qed.
Definition group_zpow {A : Type'} : (Group A) -> A -> Z -> A := fun _354984 : Group A => fun _354985 : A => fun _354986 : Z => @COND A (Z.le (Z_of_N (NUMERAL 0%N)) _354986) (@group_pow A _354984 _354985 (num_of_int _354986)) (@group_inv A _354984 (@group_pow A _354984 _354985 (num_of_int (Z.opp _354986)))).
Lemma group_zpow_def {A : Type'} : (@group_zpow A) = (fun _354984 : Group A => fun _354985 : A => fun _354986 : Z => @COND A (Z.le (Z_of_N (NUMERAL 0%N)) _354986) (@group_pow A _354984 _354985 (num_of_int _354986)) (@group_inv A _354984 (@group_pow A _354984 _354985 (num_of_int (Z.opp _354986))))).
Proof. exact (eq_refl (@group_zpow A)). Qed.
Definition abelian_group {A : Type'} : (Group A) -> Prop := fun _355172 : Group A => forall x : A, forall y : A, ((@IN A x (@group_carrier A _355172)) /\ (@IN A y (@group_carrier A _355172))) -> (@group_mul A _355172 x y) = (@group_mul A _355172 y x).
Lemma abelian_group_def {A : Type'} : (@abelian_group A) = (fun _355172 : Group A => forall x : A, forall y : A, ((@IN A x (@group_carrier A _355172)) /\ (@IN A y (@group_carrier A _355172))) -> (@group_mul A _355172 x y) = (@group_mul A _355172 y x)).
Proof. exact (eq_refl (@abelian_group A)). Qed.
Definition group_neg {_258875 : Type'} : (Group _258875) -> _258875 -> _258875 := fun _355389 : Group _258875 => fun _355390 : _258875 => @COND _258875 (@IN _258875 _355390 (@group_carrier _258875 _355389)) (@group_inv _258875 _355389 _355390) _355390.
Lemma group_neg_def {_258875 : Type'} : (@group_neg _258875) = (fun _355389 : Group _258875 => fun _355390 : _258875 => @COND _258875 (@IN _258875 _355390 (@group_carrier _258875 _355389)) (@group_inv _258875 _355389 _355390) _355390).
Proof. exact (eq_refl (@group_neg _258875)). Qed.
Definition group_add {A : Type'} : (Group A) -> A -> A -> A := fun _355401 : Group A => fun _355402 : A => fun _355403 : A => @COND A ((@IN A _355402 (@group_carrier A _355401)) /\ (@IN A _355403 (@group_carrier A _355401))) (@group_mul A _355401 _355402 _355403) (@COND A (@IN A _355402 (@group_carrier A _355401)) _355403 (@COND A (@IN A _355403 (@group_carrier A _355401)) _355402 (@ε A (fun w : A => ~ (@IN A w (@group_carrier A _355401)))))).
Lemma group_add_def {A : Type'} : (@group_add A) = (fun _355401 : Group A => fun _355402 : A => fun _355403 : A => @COND A ((@IN A _355402 (@group_carrier A _355401)) /\ (@IN A _355403 (@group_carrier A _355401))) (@group_mul A _355401 _355402 _355403) (@COND A (@IN A _355402 (@group_carrier A _355401)) _355403 (@COND A (@IN A _355403 (@group_carrier A _355401)) _355402 (@ε A (fun w : A => ~ (@IN A w (@group_carrier A _355401))))))).
Proof. exact (eq_refl (@group_add A)). Qed.
Definition group_nmul {_258956 : Type'} : (Group _258956) -> N -> _258956 -> _258956 := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Group _258956) -> N -> _258956 -> _258956) (fun group_nmul' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Group _258956) -> N -> _258956 -> _258956 => forall _355429 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))), (forall x : _258956, forall G : Group _258956, (group_nmul' _355429 G (NUMERAL 0%N) x) = (@group_id _258956 G)) /\ (forall G : Group _258956, forall n : N, forall x : _258956, (group_nmul' _355429 G (N.succ n) x) = (@group_add _258956 G x (group_nmul' _355429 G n x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))).
Lemma group_nmul_def {_258956 : Type'} : (@group_nmul _258956) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Group _258956) -> N -> _258956 -> _258956) (fun group_nmul' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Group _258956) -> N -> _258956 -> _258956 => forall _355429 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))), (forall x : _258956, forall G : Group _258956, (group_nmul' _355429 G (NUMERAL 0%N) x) = (@group_id _258956 G)) /\ (forall G : Group _258956, forall n : N, forall x : _258956, (group_nmul' _355429 G (N.succ n) x) = (@group_add _258956 G x (group_nmul' _355429 G n x)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))).
Proof. exact (eq_refl (@group_nmul _258956)). Qed.
Definition group_product {_260068 A : Type'} : (Group A) -> (_260068 -> _260068 -> Prop) -> (_260068 -> Prop) -> (_260068 -> A) -> A := fun _355791 : Group A => @iterato A _260068 (@group_carrier A _355791) (@group_id A _355791) (@group_mul A _355791).
Lemma group_product_def {_260068 A : Type'} : (@group_product _260068 A) = (fun _355791 : Group A => @iterato A _260068 (@group_carrier A _355791) (@group_id A _355791) (@group_mul A _355791)).
Proof. exact (eq_refl (@group_product _260068 A)). Qed.
Definition group_sum {A K : Type'} : (Group A) -> (K -> Prop) -> (K -> A) -> A := fun _355796 : Group A => @group_product K A _355796 (@ε (K -> K -> Prop) (fun l : K -> K -> Prop => (@woset K l) /\ ((@fld K l) = (@UNIV K)))).
Lemma group_sum_def {A K : Type'} : (@group_sum A K) = (fun _355796 : Group A => @group_product K A _355796 (@ε (K -> K -> Prop) (fun l : K -> K -> Prop => (@woset K l) /\ ((@fld K l) = (@UNIV K))))).
Proof. exact (eq_refl (@group_sum A K)). Qed.
Definition group_conjugation {_265504 : Type'} : (Group _265504) -> _265504 -> _265504 -> _265504 := fun _371034 : Group _265504 => fun _371035 : _265504 => fun _371036 : _265504 => @group_mul _265504 _371034 _371035 (@group_mul _265504 _371034 _371036 (@group_inv _265504 _371034 _371035)).
Lemma group_conjugation_def {_265504 : Type'} : (@group_conjugation _265504) = (fun _371034 : Group _265504 => fun _371035 : _265504 => fun _371036 : _265504 => @group_mul _265504 _371034 _371035 (@group_mul _265504 _371034 _371036 (@group_inv _265504 _371034 _371035))).
Proof. exact (eq_refl (@group_conjugation _265504)). Qed.
Definition subgroup_of {A : Type'} : (A -> Prop) -> (Group A) -> Prop := fun _371742 : A -> Prop => fun _371743 : Group A => (@SUBSET A _371742 (@group_carrier A _371743)) /\ ((@IN A (@group_id A _371743) _371742) /\ ((forall x : A, (@IN A x _371742) -> @IN A (@group_inv A _371743 x) _371742) /\ (forall x : A, forall y : A, ((@IN A x _371742) /\ (@IN A y _371742)) -> @IN A (@group_mul A _371743 x y) _371742))).
Lemma subgroup_of_def {A : Type'} : (@subgroup_of A) = (fun _371742 : A -> Prop => fun _371743 : Group A => (@SUBSET A _371742 (@group_carrier A _371743)) /\ ((@IN A (@group_id A _371743) _371742) /\ ((forall x : A, (@IN A x _371742) -> @IN A (@group_inv A _371743 x) _371742) /\ (forall x : A, forall y : A, ((@IN A x _371742) /\ (@IN A y _371742)) -> @IN A (@group_mul A _371743 x y) _371742)))).
Proof. exact (eq_refl (@subgroup_of A)). Qed.
Definition subgroup_generated {A : Type'} : (Group A) -> (A -> Prop) -> Group A := fun _372584 : Group A => fun _372585 : A -> Prop => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_810 : A -> Prop => exists h : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_810 ((@subgroup_of A h _372584) /\ (@SUBSET A (@INTER A (@group_carrier A _372584) _372585) h)) h))) (@pair A (prod (A -> A) (A -> A -> A)) (@group_id A _372584) (@pair (A -> A) (A -> A -> A) (@group_inv A _372584) (@group_mul A _372584)))).
Lemma subgroup_generated_def {A : Type'} : (@subgroup_generated A) = (fun _372584 : Group A => fun _372585 : A -> Prop => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_810 : A -> Prop => exists h : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_810 ((@subgroup_of A h _372584) /\ (@SUBSET A (@INTER A (@group_carrier A _372584) _372585) h)) h))) (@pair A (prod (A -> A) (A -> A -> A)) (@group_id A _372584) (@pair (A -> A) (A -> A -> A) (@group_inv A _372584) (@group_mul A _372584))))).
Proof. exact (eq_refl (@subgroup_generated A)). Qed.
Definition prod_group {A B : Type'} : (Group A) -> (Group B) -> Group (prod A B) := fun _374544 : Group A => fun _374545 : Group B => @group (prod A B) (@pair ((prod A B) -> Prop) (prod (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B))) (@CROSS A B (@group_carrier A _374544) (@group_carrier B _374545)) (@pair (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B)) (@pair A B (@group_id A _374544) (@group_id B _374545)) (@pair ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B) (@GABS ((prod A B) -> prod A B) (fun f : (prod A B) -> prod A B => forall x : A, forall x' : B, @GEQ (prod A B) (f (@pair A B x x')) (@pair A B (@group_inv A _374544 x) (@group_inv B _374545 x')))) (@GABS ((prod A B) -> (prod A B) -> prod A B) (fun f : (prod A B) -> (prod A B) -> prod A B => forall x : A, forall x' : B, @GEQ ((prod A B) -> prod A B) (f (@pair A B x x')) (@GABS ((prod A B) -> prod A B) (fun f' : (prod A B) -> prod A B => forall y : A, forall y' : B, @GEQ (prod A B) (f' (@pair A B y y')) (@pair A B (@group_mul A _374544 x y) (@group_mul B _374545 x' y'))))))))).
Lemma prod_group_def {A B : Type'} : (@prod_group A B) = (fun _374544 : Group A => fun _374545 : Group B => @group (prod A B) (@pair ((prod A B) -> Prop) (prod (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B))) (@CROSS A B (@group_carrier A _374544) (@group_carrier B _374545)) (@pair (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B)) (@pair A B (@group_id A _374544) (@group_id B _374545)) (@pair ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B) (@GABS ((prod A B) -> prod A B) (fun f : (prod A B) -> prod A B => forall x : A, forall x' : B, @GEQ (prod A B) (f (@pair A B x x')) (@pair A B (@group_inv A _374544 x) (@group_inv B _374545 x')))) (@GABS ((prod A B) -> (prod A B) -> prod A B) (fun f : (prod A B) -> (prod A B) -> prod A B => forall x : A, forall x' : B, @GEQ ((prod A B) -> prod A B) (f (@pair A B x x')) (@GABS ((prod A B) -> prod A B) (fun f' : (prod A B) -> prod A B => forall y : A, forall y' : B, @GEQ (prod A B) (f' (@pair A B y y')) (@pair A B (@group_mul A _374544 x y) (@group_mul B _374545 x' y')))))))))).
Proof. exact (eq_refl (@prod_group A B)). Qed.
Definition product_group {A K : Type'} : (K -> Prop) -> (K -> Group A) -> Group (K -> A) := fun _375306 : K -> Prop => fun _375307 : K -> Group A => @group (K -> A) (@pair ((K -> A) -> Prop) (prod (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A))) (@cartesian_product A K _375306 (fun i : K => @group_carrier A (_375307 i))) (@pair (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A)) (@RESTRICTION K A _375306 (fun i : K => @group_id A (_375307 i))) (@pair ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A) (fun x : K -> A => @RESTRICTION K A _375306 (fun i : K => @group_inv A (_375307 i) (x i))) (fun x : K -> A => fun y : K -> A => @RESTRICTION K A _375306 (fun i : K => @group_mul A (_375307 i) (x i) (y i)))))).
Lemma product_group_def {A K : Type'} : (@product_group A K) = (fun _375306 : K -> Prop => fun _375307 : K -> Group A => @group (K -> A) (@pair ((K -> A) -> Prop) (prod (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A))) (@cartesian_product A K _375306 (fun i : K => @group_carrier A (_375307 i))) (@pair (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A)) (@RESTRICTION K A _375306 (fun i : K => @group_id A (_375307 i))) (@pair ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A) (fun x : K -> A => @RESTRICTION K A _375306 (fun i : K => @group_inv A (_375307 i) (x i))) (fun x : K -> A => fun y : K -> A => @RESTRICTION K A _375306 (fun i : K => @group_mul A (_375307 i) (x i) (y i))))))).
Proof. exact (eq_refl (@product_group A K)). Qed.
Definition sum_group {A K : Type'} : (K -> Prop) -> (K -> Group A) -> Group (K -> A) := fun _375648 : K -> Prop => fun _375649 : K -> Group A => @subgroup_generated (K -> A) (@product_group A K _375648 _375649) (@GSPEC (K -> A) (fun GEN_PVAR_820 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_820 ((@IN (K -> A) x (@cartesian_product A K _375648 (fun i : K => @group_carrier A (_375649 i)))) /\ (@FINITE K (@GSPEC K (fun GEN_PVAR_819 : K => exists i : K, @SETSPEC K GEN_PVAR_819 ((@IN K i _375648) /\ (~ ((x i) = (@group_id A (_375649 i))))) i)))) x)).
Lemma sum_group_def {A K : Type'} : (@sum_group A K) = (fun _375648 : K -> Prop => fun _375649 : K -> Group A => @subgroup_generated (K -> A) (@product_group A K _375648 _375649) (@GSPEC (K -> A) (fun GEN_PVAR_820 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_820 ((@IN (K -> A) x (@cartesian_product A K _375648 (fun i : K => @group_carrier A (_375649 i)))) /\ (@FINITE K (@GSPEC K (fun GEN_PVAR_819 : K => exists i : K, @SETSPEC K GEN_PVAR_819 ((@IN K i _375648) /\ (~ ((x i) = (@group_id A (_375649 i))))) i)))) x))).
Proof. exact (eq_refl (@sum_group A K)). Qed.
Definition group_homomorphism {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> Prop := fun _376175 : prod (Group A) (Group B) => fun _376176 : A -> B => (@SUBSET B (@IMAGE A B _376176 (@group_carrier A (@fst (Group A) (Group B) _376175))) (@group_carrier B (@snd (Group A) (Group B) _376175))) /\ (((_376176 (@group_id A (@fst (Group A) (Group B) _376175))) = (@group_id B (@snd (Group A) (Group B) _376175))) /\ ((forall x : A, (@IN A x (@group_carrier A (@fst (Group A) (Group B) _376175))) -> (_376176 (@group_inv A (@fst (Group A) (Group B) _376175) x)) = (@group_inv B (@snd (Group A) (Group B) _376175) (_376176 x))) /\ (forall x : A, forall y : A, ((@IN A x (@group_carrier A (@fst (Group A) (Group B) _376175))) /\ (@IN A y (@group_carrier A (@fst (Group A) (Group B) _376175)))) -> (_376176 (@group_mul A (@fst (Group A) (Group B) _376175) x y)) = (@group_mul B (@snd (Group A) (Group B) _376175) (_376176 x) (_376176 y))))).
Lemma group_homomorphism_def {A B : Type'} : (@group_homomorphism A B) = (fun _376175 : prod (Group A) (Group B) => fun _376176 : A -> B => (@SUBSET B (@IMAGE A B _376176 (@group_carrier A (@fst (Group A) (Group B) _376175))) (@group_carrier B (@snd (Group A) (Group B) _376175))) /\ (((_376176 (@group_id A (@fst (Group A) (Group B) _376175))) = (@group_id B (@snd (Group A) (Group B) _376175))) /\ ((forall x : A, (@IN A x (@group_carrier A (@fst (Group A) (Group B) _376175))) -> (_376176 (@group_inv A (@fst (Group A) (Group B) _376175) x)) = (@group_inv B (@snd (Group A) (Group B) _376175) (_376176 x))) /\ (forall x : A, forall y : A, ((@IN A x (@group_carrier A (@fst (Group A) (Group B) _376175))) /\ (@IN A y (@group_carrier A (@fst (Group A) (Group B) _376175)))) -> (_376176 (@group_mul A (@fst (Group A) (Group B) _376175) x y)) = (@group_mul B (@snd (Group A) (Group B) _376175) (_376176 x) (_376176 y)))))).
Proof. exact (eq_refl (@group_homomorphism A B)). Qed.
Definition group_monomorphism {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> Prop := fun _376192 : prod (Group A) (Group B) => fun _376193 : A -> B => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376192) (@snd (Group A) (Group B) _376192)) _376193) /\ (forall x : A, forall y : A, ((@IN A x (@group_carrier A (@fst (Group A) (Group B) _376192))) /\ ((@IN A y (@group_carrier A (@fst (Group A) (Group B) _376192))) /\ ((_376193 x) = (_376193 y)))) -> x = y).
Lemma group_monomorphism_def {A B : Type'} : (@group_monomorphism A B) = (fun _376192 : prod (Group A) (Group B) => fun _376193 : A -> B => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376192) (@snd (Group A) (Group B) _376192)) _376193) /\ (forall x : A, forall y : A, ((@IN A x (@group_carrier A (@fst (Group A) (Group B) _376192))) /\ ((@IN A y (@group_carrier A (@fst (Group A) (Group B) _376192))) /\ ((_376193 x) = (_376193 y)))) -> x = y)).
Proof. exact (eq_refl (@group_monomorphism A B)). Qed.
Definition group_epimorphism {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> Prop := fun _376209 : prod (Group A) (Group B) => fun _376210 : A -> B => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376209) (@snd (Group A) (Group B) _376209)) _376210) /\ ((@IMAGE A B _376210 (@group_carrier A (@fst (Group A) (Group B) _376209))) = (@group_carrier B (@snd (Group A) (Group B) _376209))).
Lemma group_epimorphism_def {A B : Type'} : (@group_epimorphism A B) = (fun _376209 : prod (Group A) (Group B) => fun _376210 : A -> B => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376209) (@snd (Group A) (Group B) _376209)) _376210) /\ ((@IMAGE A B _376210 (@group_carrier A (@fst (Group A) (Group B) _376209))) = (@group_carrier B (@snd (Group A) (Group B) _376209)))).
Proof. exact (eq_refl (@group_epimorphism A B)). Qed.
Definition group_endomorphism {A : Type'} : (Group A) -> (A -> A) -> Prop := fun _376226 : Group A => fun _376227 : A -> A => @group_homomorphism A A (@pair (Group A) (Group A) _376226 _376226) _376227.
Lemma group_endomorphism_def {A : Type'} : (@group_endomorphism A) = (fun _376226 : Group A => fun _376227 : A -> A => @group_homomorphism A A (@pair (Group A) (Group A) _376226 _376226) _376227).
Proof. exact (eq_refl (@group_endomorphism A)). Qed.
Definition group_isomorphisms {A B : Type'} : (prod (Group A) (Group B)) -> (prod (A -> B) (B -> A)) -> Prop := fun _376238 : prod (Group A) (Group B) => fun _376239 : prod (A -> B) (B -> A) => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376238) (@snd (Group A) (Group B) _376238)) (@fst (A -> B) (B -> A) _376239)) /\ ((@group_homomorphism B A (@pair (Group B) (Group A) (@snd (Group A) (Group B) _376238) (@fst (Group A) (Group B) _376238)) (@snd (A -> B) (B -> A) _376239)) /\ ((forall x : A, (@IN A x (@group_carrier A (@fst (Group A) (Group B) _376238))) -> (@snd (A -> B) (B -> A) _376239 (@fst (A -> B) (B -> A) _376239 x)) = x) /\ (forall y : B, (@IN B y (@group_carrier B (@snd (Group A) (Group B) _376238))) -> (@fst (A -> B) (B -> A) _376239 (@snd (A -> B) (B -> A) _376239 y)) = y))).
Lemma group_isomorphisms_def {A B : Type'} : (@group_isomorphisms A B) = (fun _376238 : prod (Group A) (Group B) => fun _376239 : prod (A -> B) (B -> A) => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376238) (@snd (Group A) (Group B) _376238)) (@fst (A -> B) (B -> A) _376239)) /\ ((@group_homomorphism B A (@pair (Group B) (Group A) (@snd (Group A) (Group B) _376238) (@fst (Group A) (Group B) _376238)) (@snd (A -> B) (B -> A) _376239)) /\ ((forall x : A, (@IN A x (@group_carrier A (@fst (Group A) (Group B) _376238))) -> (@snd (A -> B) (B -> A) _376239 (@fst (A -> B) (B -> A) _376239 x)) = x) /\ (forall y : B, (@IN B y (@group_carrier B (@snd (Group A) (Group B) _376238))) -> (@fst (A -> B) (B -> A) _376239 (@snd (A -> B) (B -> A) _376239 y)) = y)))).
Proof. exact (eq_refl (@group_isomorphisms A B)). Qed.
Definition group_isomorphism {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> Prop := fun _376260 : prod (Group A) (Group B) => fun _376261 : A -> B => exists g : B -> A, @group_isomorphisms A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376260) (@snd (Group A) (Group B) _376260)) (@pair (A -> B) (B -> A) _376261 g).
Lemma group_isomorphism_def {A B : Type'} : (@group_isomorphism A B) = (fun _376260 : prod (Group A) (Group B) => fun _376261 : A -> B => exists g : B -> A, @group_isomorphisms A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _376260) (@snd (Group A) (Group B) _376260)) (@pair (A -> B) (B -> A) _376261 g)).
Proof. exact (eq_refl (@group_isomorphism A B)). Qed.
Definition group_automorphism {A : Type'} : (Group A) -> (A -> A) -> Prop := fun _376277 : Group A => fun _376278 : A -> A => @group_isomorphism A A (@pair (Group A) (Group A) _376277 _376277) _376278.
Lemma group_automorphism_def {A : Type'} : (@group_automorphism A) = (fun _376277 : Group A => fun _376278 : A -> A => @group_isomorphism A A (@pair (Group A) (Group A) _376277 _376277) _376278).
Proof. exact (eq_refl (@group_automorphism A)). Qed.
Definition isomorphic_group {A B : Type'} : (Group A) -> (Group B) -> Prop := fun _399100 : Group A => fun _399101 : Group B => exists f : A -> B, @group_isomorphism A B (@pair (Group A) (Group B) _399100 _399101) f.
Lemma isomorphic_group_def {A B : Type'} : (@isomorphic_group A B) = (fun _399100 : Group A => fun _399101 : Group B => exists f : A -> B, @group_isomorphism A B (@pair (Group A) (Group B) _399100 _399101) f).
Proof. exact (eq_refl (@isomorphic_group A B)). Qed.
Definition group_setinv {_281127 : Type'} : (Group _281127) -> (_281127 -> Prop) -> _281127 -> Prop := fun _403173 : Group _281127 => fun _403174 : _281127 -> Prop => @GSPEC _281127 (fun GEN_PVAR_842 : _281127 => exists x : _281127, @SETSPEC _281127 GEN_PVAR_842 (@IN _281127 x _403174) (@group_inv _281127 _403173 x)).
Lemma group_setinv_def {_281127 : Type'} : (@group_setinv _281127) = (fun _403173 : Group _281127 => fun _403174 : _281127 -> Prop => @GSPEC _281127 (fun GEN_PVAR_842 : _281127 => exists x : _281127, @SETSPEC _281127 GEN_PVAR_842 (@IN _281127 x _403174) (@group_inv _281127 _403173 x))).
Proof. exact (eq_refl (@group_setinv _281127)). Qed.
Definition group_setmul {_281156 : Type'} : (Group _281156) -> (_281156 -> Prop) -> (_281156 -> Prop) -> _281156 -> Prop := fun _403185 : Group _281156 => fun _403186 : _281156 -> Prop => fun _403187 : _281156 -> Prop => @GSPEC _281156 (fun GEN_PVAR_843 : _281156 => exists x : _281156, exists y : _281156, @SETSPEC _281156 GEN_PVAR_843 ((@IN _281156 x _403186) /\ (@IN _281156 y _403187)) (@group_mul _281156 _403185 x y)).
Lemma group_setmul_def {_281156 : Type'} : (@group_setmul _281156) = (fun _403185 : Group _281156 => fun _403186 : _281156 -> Prop => fun _403187 : _281156 -> Prop => @GSPEC _281156 (fun GEN_PVAR_843 : _281156 => exists x : _281156, exists y : _281156, @SETSPEC _281156 GEN_PVAR_843 ((@IN _281156 x _403186) /\ (@IN _281156 y _403187)) (@group_mul _281156 _403185 x y))).
Proof. exact (eq_refl (@group_setmul _281156)). Qed.
Definition group_action {A X : Type'} : (Group A) -> (X -> Prop) -> (A -> X -> X) -> Prop := fun _405403 : Group A => fun _405404 : X -> Prop => fun _405405 : A -> X -> X => (forall g : A, forall x : X, ((@IN A g (@group_carrier A _405403)) /\ (@IN X x _405404)) -> @IN X (_405405 g x) _405404) /\ ((forall x : X, (@IN X x _405404) -> (_405405 (@group_id A _405403) x) = x) /\ (forall g : A, forall h : A, forall x : X, ((@IN A g (@group_carrier A _405403)) /\ ((@IN A h (@group_carrier A _405403)) /\ (@IN X x _405404))) -> (_405405 (@group_mul A _405403 g h) x) = (_405405 g (_405405 h x)))).
Lemma group_action_def {A X : Type'} : (@group_action A X) = (fun _405403 : Group A => fun _405404 : X -> Prop => fun _405405 : A -> X -> X => (forall g : A, forall x : X, ((@IN A g (@group_carrier A _405403)) /\ (@IN X x _405404)) -> @IN X (_405405 g x) _405404) /\ ((forall x : X, (@IN X x _405404) -> (_405405 (@group_id A _405403) x) = x) /\ (forall g : A, forall h : A, forall x : X, ((@IN A g (@group_carrier A _405403)) /\ ((@IN A h (@group_carrier A _405403)) /\ (@IN X x _405404))) -> (_405405 (@group_mul A _405403 g h) x) = (_405405 g (_405405 h x))))).
Proof. exact (eq_refl (@group_action A X)). Qed.
Definition group_stabilizer {A X : Type'} : (Group A) -> (A -> X -> X) -> X -> A -> Prop := fun _408336 : Group A => fun _408337 : A -> X -> X => fun _408338 : X => @GSPEC A (fun GEN_PVAR_855 : A => exists g : A, @SETSPEC A GEN_PVAR_855 ((@IN A g (@group_carrier A _408336)) /\ ((_408337 g _408338) = _408338)) g).
Lemma group_stabilizer_def {A X : Type'} : (@group_stabilizer A X) = (fun _408336 : Group A => fun _408337 : A -> X -> X => fun _408338 : X => @GSPEC A (fun GEN_PVAR_855 : A => exists g : A, @SETSPEC A GEN_PVAR_855 ((@IN A g (@group_carrier A _408336)) /\ ((_408337 g _408338) = _408338)) g)).
Proof. exact (eq_refl (@group_stabilizer A X)). Qed.
Definition group_orbit {A X : Type'} : (Group A) -> (X -> Prop) -> (A -> X -> X) -> X -> X -> Prop := fun _409004 : Group A => fun _409005 : X -> Prop => fun _409006 : A -> X -> X => fun _409007 : X => fun _409008 : X => (@IN X _409007 _409005) /\ ((@IN X _409008 _409005) /\ (exists g : A, (@IN A g (@group_carrier A _409004)) /\ ((_409006 g _409007) = _409008))).
Lemma group_orbit_def {A X : Type'} : (@group_orbit A X) = (fun _409004 : Group A => fun _409005 : X -> Prop => fun _409006 : A -> X -> X => fun _409007 : X => fun _409008 : X => (@IN X _409007 _409005) /\ ((@IN X _409008 _409005) /\ (exists g : A, (@IN A g (@group_carrier A _409004)) /\ ((_409006 g _409007) = _409008)))).
Proof. exact (eq_refl (@group_orbit A X)). Qed.
Definition right_coset {_287922 : Type'} : (Group _287922) -> (_287922 -> Prop) -> _287922 -> _287922 -> Prop := fun _414508 : Group _287922 => fun _414509 : _287922 -> Prop => fun _414510 : _287922 => @group_setmul _287922 _414508 _414509 (@INSERT _287922 _414510 (@EMPTY _287922)).
Lemma right_coset_def {_287922 : Type'} : (@right_coset _287922) = (fun _414508 : Group _287922 => fun _414509 : _287922 -> Prop => fun _414510 : _287922 => @group_setmul _287922 _414508 _414509 (@INSERT _287922 _414510 (@EMPTY _287922))).
Proof. exact (eq_refl (@right_coset _287922)). Qed.
Definition left_coset {_287937 : Type'} : (Group _287937) -> _287937 -> (_287937 -> Prop) -> _287937 -> Prop := fun _414529 : Group _287937 => fun _414530 : _287937 => fun _414531 : _287937 -> Prop => @group_setmul _287937 _414529 (@INSERT _287937 _414530 (@EMPTY _287937)) _414531.
Lemma left_coset_def {_287937 : Type'} : (@left_coset _287937) = (fun _414529 : Group _287937 => fun _414530 : _287937 => fun _414531 : _287937 -> Prop => @group_setmul _287937 _414529 (@INSERT _287937 _414530 (@EMPTY _287937)) _414531).
Proof. exact (eq_refl (@left_coset _287937)). Qed.
Definition normal_subgroup_of {A : Type'} : (A -> Prop) -> (Group A) -> Prop := fun _420191 : A -> Prop => fun _420192 : Group A => (@subgroup_of A _420191 _420192) /\ (forall x : A, (@IN A x (@group_carrier A _420192)) -> (@left_coset A _420192 x _420191) = (@right_coset A _420192 _420191 x)).
Lemma normal_subgroup_of_def {A : Type'} : (@normal_subgroup_of A) = (fun _420191 : A -> Prop => fun _420192 : Group A => (@subgroup_of A _420191 _420192) /\ (forall x : A, (@IN A x (@group_carrier A _420192)) -> (@left_coset A _420192 x _420191) = (@right_coset A _420192 _420191 x))).
Proof. exact (eq_refl (@normal_subgroup_of A)). Qed.
Definition group_conjugate {A : Type'} : (Group A) -> (A -> Prop) -> (A -> Prop) -> Prop := fun _422663 : Group A => fun _422664 : A -> Prop => fun _422665 : A -> Prop => (@SUBSET A _422664 (@group_carrier A _422663)) /\ ((@SUBSET A _422665 (@group_carrier A _422663)) /\ (exists a : A, (@IN A a (@group_carrier A _422663)) /\ ((@IMAGE A A (@group_conjugation A _422663 a) _422664) = _422665))).
Lemma group_conjugate_def {A : Type'} : (@group_conjugate A) = (fun _422663 : Group A => fun _422664 : A -> Prop => fun _422665 : A -> Prop => (@SUBSET A _422664 (@group_carrier A _422663)) /\ ((@SUBSET A _422665 (@group_carrier A _422663)) /\ (exists a : A, (@IN A a (@group_carrier A _422663)) /\ ((@IMAGE A A (@group_conjugation A _422663 a) _422664) = _422665)))).
Proof. exact (eq_refl (@group_conjugate A)). Qed.
Definition group_centralizer {A : Type'} : (Group A) -> (A -> Prop) -> A -> Prop := fun _423436 : Group A => fun _423437 : A -> Prop => @GSPEC A (fun GEN_PVAR_944 : A => exists x : A, @SETSPEC A GEN_PVAR_944 ((@IN A x (@group_carrier A _423436)) /\ (forall y : A, ((@IN A y (@group_carrier A _423436)) /\ (@IN A y _423437)) -> (@group_mul A _423436 x y) = (@group_mul A _423436 y x))) x).
Lemma group_centralizer_def {A : Type'} : (@group_centralizer A) = (fun _423436 : Group A => fun _423437 : A -> Prop => @GSPEC A (fun GEN_PVAR_944 : A => exists x : A, @SETSPEC A GEN_PVAR_944 ((@IN A x (@group_carrier A _423436)) /\ (forall y : A, ((@IN A y (@group_carrier A _423436)) /\ (@IN A y _423437)) -> (@group_mul A _423436 x y) = (@group_mul A _423436 y x))) x)).
Proof. exact (eq_refl (@group_centralizer A)). Qed.
Definition group_normalizer {A : Type'} : (Group A) -> (A -> Prop) -> A -> Prop := fun _423448 : Group A => fun _423449 : A -> Prop => @GSPEC A (fun GEN_PVAR_945 : A => exists x : A, @SETSPEC A GEN_PVAR_945 ((@IN A x (@group_carrier A _423448)) /\ ((@group_setmul A _423448 (@INSERT A x (@EMPTY A)) (@INTER A (@group_carrier A _423448) _423449)) = (@group_setmul A _423448 (@INTER A (@group_carrier A _423448) _423449) (@INSERT A x (@EMPTY A))))) x).
Lemma group_normalizer_def {A : Type'} : (@group_normalizer A) = (fun _423448 : Group A => fun _423449 : A -> Prop => @GSPEC A (fun GEN_PVAR_945 : A => exists x : A, @SETSPEC A GEN_PVAR_945 ((@IN A x (@group_carrier A _423448)) /\ ((@group_setmul A _423448 (@INSERT A x (@EMPTY A)) (@INTER A (@group_carrier A _423448) _423449)) = (@group_setmul A _423448 (@INTER A (@group_carrier A _423448) _423449) (@INSERT A x (@EMPTY A))))) x)).
Proof. exact (eq_refl (@group_normalizer A)). Qed.
Definition quotient_group {A : Type'} : (Group A) -> (A -> Prop) -> Group (A -> Prop) := fun _425519 : Group A => fun _425520 : A -> Prop => @group (A -> Prop) (@pair ((A -> Prop) -> Prop) (prod (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop))) (@GSPEC (A -> Prop) (fun GEN_PVAR_963 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_963 (@IN A x (@group_carrier A _425519)) (@right_coset A _425519 _425520 x))) (@pair (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop)) _425520 (@pair ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop) (@group_setinv A _425519) (@group_setmul A _425519)))).
Lemma quotient_group_def {A : Type'} : (@quotient_group A) = (fun _425519 : Group A => fun _425520 : A -> Prop => @group (A -> Prop) (@pair ((A -> Prop) -> Prop) (prod (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop))) (@GSPEC (A -> Prop) (fun GEN_PVAR_963 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_963 (@IN A x (@group_carrier A _425519)) (@right_coset A _425519 _425520 x))) (@pair (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop)) _425520 (@pair ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop) (@group_setinv A _425519) (@group_setmul A _425519))))).
Proof. exact (eq_refl (@quotient_group A)). Qed.
Definition group_kernel {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> A -> Prop := fun _427994 : prod (Group A) (Group B) => fun _427995 : A -> B => @GSPEC A (fun GEN_PVAR_971 : A => exists x : A, @SETSPEC A GEN_PVAR_971 ((@IN A x (@group_carrier A (@fst (Group A) (Group B) _427994))) /\ ((_427995 x) = (@group_id B (@snd (Group A) (Group B) _427994)))) x).
Lemma group_kernel_def {A B : Type'} : (@group_kernel A B) = (fun _427994 : prod (Group A) (Group B) => fun _427995 : A -> B => @GSPEC A (fun GEN_PVAR_971 : A => exists x : A, @SETSPEC A GEN_PVAR_971 ((@IN A x (@group_carrier A (@fst (Group A) (Group B) _427994))) /\ ((_427995 x) = (@group_id B (@snd (Group A) (Group B) _427994)))) x)).
Proof. exact (eq_refl (@group_kernel A B)). Qed.
Definition group_image {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> B -> Prop := fun _428011 : prod (Group A) (Group B) => fun _428012 : A -> B => @IMAGE A B _428012 (@group_carrier A (@fst (Group A) (Group B) _428011)).
Lemma group_image_def {A B : Type'} : (@group_image A B) = (fun _428011 : prod (Group A) (Group B) => fun _428012 : A -> B => @IMAGE A B _428012 (@group_carrier A (@fst (Group A) (Group B) _428011))).
Proof. exact (eq_refl (@group_image A B)). Qed.
Definition trivial_homomorphism {A B : Type'} : (prod (Group A) (Group B)) -> (A -> B) -> Prop := fun _458314 : prod (Group A) (Group B) => fun _458315 : A -> B => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _458314) (@snd (Group A) (Group B) _458314)) _458315) /\ (forall x : A, (@IN A x (@group_carrier A (@fst (Group A) (Group B) _458314))) -> (_458315 x) = (@group_id B (@snd (Group A) (Group B) _458314))).
Lemma trivial_homomorphism_def {A B : Type'} : (@trivial_homomorphism A B) = (fun _458314 : prod (Group A) (Group B) => fun _458315 : A -> B => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (Group B) _458314) (@snd (Group A) (Group B) _458314)) _458315) /\ (forall x : A, (@IN A x (@group_carrier A (@fst (Group A) (Group B) _458314))) -> (_458315 x) = (@group_id B (@snd (Group A) (Group B) _458314)))).
Proof. exact (eq_refl (@trivial_homomorphism A B)). Qed.
Definition group_element_order {A : Type'} : (Group A) -> A -> N := fun _459805 : Group A => fun _459806 : A => @ε N (fun d : N => forall n : N, ((@group_pow A _459805 _459806 n) = (@group_id A _459805)) = (num_divides d n)).
Lemma group_element_order_def {A : Type'} : (@group_element_order A) = (fun _459805 : Group A => fun _459806 : A => @ε N (fun d : N => forall n : N, ((@group_pow A _459805 _459806 n) = (@group_id A _459805)) = (num_divides d n))).
Proof. exact (eq_refl (@group_element_order A)). Qed.
Definition cyclic_group {_310016 : Type'} : (Group _310016) -> Prop := fun _464632 : Group _310016 => exists x : _310016, (@IN _310016 x (@group_carrier _310016 _464632)) /\ ((@subgroup_generated _310016 _464632 (@INSERT _310016 x (@EMPTY _310016))) = _464632).
Lemma cyclic_group_def {_310016 : Type'} : (@cyclic_group _310016) = (fun _464632 : Group _310016 => exists x : _310016, (@IN _310016 x (@group_carrier _310016 _464632)) /\ ((@subgroup_generated _310016 _464632 (@INSERT _310016 x (@EMPTY _310016))) = _464632)).
Proof. exact (eq_refl (@cyclic_group _310016)). Qed.
Definition finitely_generated_group {A : Type'} : (Group A) -> Prop := fun _467681 : Group A => exists s : A -> Prop, (@FINITE A s) /\ ((@subgroup_generated A _467681 s) = _467681).
Lemma finitely_generated_group_def {A : Type'} : (@finitely_generated_group A) = (fun _467681 : Group A => exists s : A -> Prop, (@FINITE A s) /\ ((@subgroup_generated A _467681 s) = _467681)).
Proof. exact (eq_refl (@finitely_generated_group A)). Qed.
Definition integer_group : Group Z := @group Z (@pair (Z -> Prop) (prod Z (prod (Z -> Z) (Z -> Z -> Z))) (@UNIV Z) (@pair Z (prod (Z -> Z) (Z -> Z -> Z)) (Z_of_N (NUMERAL 0%N)) (@pair (Z -> Z) (Z -> Z -> Z) Z.opp Z.add))).
Lemma integer_group_def : integer_group = (@group Z (@pair (Z -> Prop) (prod Z (prod (Z -> Z) (Z -> Z -> Z))) (@UNIV Z) (@pair Z (prod (Z -> Z) (Z -> Z -> Z)) (Z_of_N (NUMERAL 0%N)) (@pair (Z -> Z) (Z -> Z -> Z) Z.opp Z.add)))).
Proof. exact (eq_refl integer_group). Qed.
Definition integer_mod_group : N -> Group Z := fun _493916 : N => @COND (Group Z) (_493916 = (NUMERAL 0%N)) integer_group (@group Z (@pair (Z -> Prop) (prod Z (prod (Z -> Z) (Z -> Z -> Z))) (@GSPEC Z (fun GEN_PVAR_1055 : Z => exists m : Z, @SETSPEC Z GEN_PVAR_1055 ((Z.le (Z_of_N (NUMERAL 0%N)) m) /\ (Z.lt m (Z_of_N _493916))) m)) (@pair Z (prod (Z -> Z) (Z -> Z -> Z)) (Z_of_N (NUMERAL 0%N)) (@pair (Z -> Z) (Z -> Z -> Z) (fun a : Z => Zrem (Z.opp a) (Z_of_N _493916)) (fun a : Z => fun b : Z => Zrem (Z.add a b) (Z_of_N _493916)))))).
Lemma integer_mod_group_def : integer_mod_group = (fun _493916 : N => @COND (Group Z) (_493916 = (NUMERAL 0%N)) integer_group (@group Z (@pair (Z -> Prop) (prod Z (prod (Z -> Z) (Z -> Z -> Z))) (@GSPEC Z (fun GEN_PVAR_1055 : Z => exists m : Z, @SETSPEC Z GEN_PVAR_1055 ((Z.le (Z_of_N (NUMERAL 0%N)) m) /\ (Z.lt m (Z_of_N _493916))) m)) (@pair Z (prod (Z -> Z) (Z -> Z -> Z)) (Z_of_N (NUMERAL 0%N)) (@pair (Z -> Z) (Z -> Z -> Z) (fun a : Z => Zrem (Z.opp a) (Z_of_N _493916)) (fun a : Z => fun b : Z => Zrem (Z.add a b) (Z_of_N _493916))))))).
Proof. exact (eq_refl integer_mod_group). Qed.
Definition pgroup {A : Type'} : (N -> Prop) -> (Group A) -> Prop := fun _496759 : N -> Prop => fun _496760 : Group A => forall p : N, forall x : A, ((prime p) /\ ((@IN A x (@group_carrier A _496760)) /\ (num_divides p (@group_element_order A _496760 x)))) -> @IN N p _496759.
Lemma pgroup_def {A : Type'} : (@pgroup A) = (fun _496759 : N -> Prop => fun _496760 : Group A => forall p : N, forall x : A, ((prime p) /\ ((@IN A x (@group_carrier A _496760)) /\ (num_divides p (@group_element_order A _496760 x)))) -> @IN N p _496759).
Proof. exact (eq_refl (@pgroup A)). Qed.
Definition free_abelian_group {A : Type'} : (A -> Prop) -> Group (frag A) := fun _567156 : A -> Prop => @group (frag A) (@pair ((frag A) -> Prop) (prod (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A))) (@GSPEC (frag A) (fun GEN_PVAR_1210 : frag A => exists c : frag A, @SETSPEC (frag A) GEN_PVAR_1210 (@SUBSET A (@frag_support A c) _567156) c)) (@pair (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A)) (@frag_0 A) (@pair ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A) (@frag_neg A) (@frag_add A)))).
Lemma free_abelian_group_def {A : Type'} : (@free_abelian_group A) = (fun _567156 : A -> Prop => @group (frag A) (@pair ((frag A) -> Prop) (prod (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A))) (@GSPEC (frag A) (fun GEN_PVAR_1210 : frag A => exists c : frag A, @SETSPEC (frag A) GEN_PVAR_1210 (@SUBSET A (@frag_support A c) _567156) c)) (@pair (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A)) (@frag_0 A) (@pair ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A) (@frag_neg A) (@frag_add A))))).
Proof. exact (eq_refl (@free_abelian_group A)). Qed.
Definition group_exactness {A B C : Type'} : (prod (Group A) (prod (Group B) (Group C))) -> (prod (A -> B) (B -> C)) -> Prop := fun _568984 : prod (Group A) (prod (Group B) (Group C)) => fun _568985 : prod (A -> B) (B -> C) => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (prod (Group B) (Group C)) _568984) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@fst (A -> B) (B -> C) _568985)) /\ ((@group_homomorphism B C (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@snd (A -> B) (B -> C) _568985)) /\ ((@group_image A B (@pair (Group A) (Group B) (@fst (Group A) (prod (Group B) (Group C)) _568984) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@fst (A -> B) (B -> C) _568985)) = (@group_kernel B C (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@snd (A -> B) (B -> C) _568985)))).
Lemma group_exactness_def {A B C : Type'} : (@group_exactness A B C) = (fun _568984 : prod (Group A) (prod (Group B) (Group C)) => fun _568985 : prod (A -> B) (B -> C) => (@group_homomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (prod (Group B) (Group C)) _568984) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@fst (A -> B) (B -> C) _568985)) /\ ((@group_homomorphism B C (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@snd (A -> B) (B -> C) _568985)) /\ ((@group_image A B (@pair (Group A) (Group B) (@fst (Group A) (prod (Group B) (Group C)) _568984) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@fst (A -> B) (B -> C) _568985)) = (@group_kernel B C (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _568984))) (@snd (A -> B) (B -> C) _568985))))).
Proof. exact (eq_refl (@group_exactness A B C)). Qed.
Definition short_exact_sequence {A B C : Type'} : (prod (Group A) (prod (Group B) (Group C))) -> (prod (A -> B) (B -> C)) -> Prop := fun _569011 : prod (Group A) (prod (Group B) (Group C)) => fun _569012 : prod (A -> B) (B -> C) => (@group_monomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (prod (Group B) (Group C)) _569011) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011))) (@fst (A -> B) (B -> C) _569012)) /\ ((@group_exactness A B C (@pair (Group A) (prod (Group B) (Group C)) (@fst (Group A) (prod (Group B) (Group C)) _569011) (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011)))) (@pair (A -> B) (B -> C) (@fst (A -> B) (B -> C) _569012) (@snd (A -> B) (B -> C) _569012))) /\ (@group_epimorphism B C (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011))) (@snd (A -> B) (B -> C) _569012))).
Lemma short_exact_sequence_def {A B C : Type'} : (@short_exact_sequence A B C) = (fun _569011 : prod (Group A) (prod (Group B) (Group C)) => fun _569012 : prod (A -> B) (B -> C) => (@group_monomorphism A B (@pair (Group A) (Group B) (@fst (Group A) (prod (Group B) (Group C)) _569011) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011))) (@fst (A -> B) (B -> C) _569012)) /\ ((@group_exactness A B C (@pair (Group A) (prod (Group B) (Group C)) (@fst (Group A) (prod (Group B) (Group C)) _569011) (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011)))) (@pair (A -> B) (B -> C) (@fst (A -> B) (B -> C) _569012) (@snd (A -> B) (B -> C) _569012))) /\ (@group_epimorphism B C (@pair (Group B) (Group C) (@fst (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011)) (@snd (Group B) (Group C) (@snd (Group A) (prod (Group B) (Group C)) _569011))) (@snd (A -> B) (B -> C) _569012)))).
Proof. exact (eq_refl (@short_exact_sequence A B C)). Qed.
Definition matroid_set {A : Type'} : (Matroid A) -> A -> Prop := fun m : Matroid A => @fst (A -> Prop) ((A -> Prop) -> A -> Prop) (@dest_matroid A m).
Lemma matroid_set_def {A : Type'} : (@matroid_set A) = (fun m : Matroid A => @fst (A -> Prop) ((A -> Prop) -> A -> Prop) (@dest_matroid A m)).
Proof. exact (eq_refl (@matroid_set A)). Qed.
Definition matroid_span {A : Type'} : (Matroid A) -> (A -> Prop) -> A -> Prop := fun m : Matroid A => @snd (A -> Prop) ((A -> Prop) -> A -> Prop) (@dest_matroid A m).
Lemma matroid_span_def {A : Type'} : (@matroid_span A) = (fun m : Matroid A => @snd (A -> Prop) ((A -> Prop) -> A -> Prop) (@dest_matroid A m)).
Proof. exact (eq_refl (@matroid_span A)). Qed.
Definition matroid_spanning {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _600731 : Matroid A => fun _600732 : A -> Prop => (@SUBSET A _600732 (@matroid_set A _600731)) /\ ((@matroid_span A _600731 _600732) = (@matroid_set A _600731)).
Lemma matroid_spanning_def {A : Type'} : (@matroid_spanning A) = (fun _600731 : Matroid A => fun _600732 : A -> Prop => (@SUBSET A _600732 (@matroid_set A _600731)) /\ ((@matroid_span A _600731 _600732) = (@matroid_set A _600731))).
Proof. exact (eq_refl (@matroid_spanning A)). Qed.
Definition matroid_independent {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _600743 : Matroid A => fun _600744 : A -> Prop => (@SUBSET A _600744 (@matroid_set A _600743)) /\ (forall x : A, (@IN A x _600744) -> ~ (@IN A x (@matroid_span A _600743 (@DELETE A _600744 x)))).
Lemma matroid_independent_def {A : Type'} : (@matroid_independent A) = (fun _600743 : Matroid A => fun _600744 : A -> Prop => (@SUBSET A _600744 (@matroid_set A _600743)) /\ (forall x : A, (@IN A x _600744) -> ~ (@IN A x (@matroid_span A _600743 (@DELETE A _600744 x))))).
Proof. exact (eq_refl (@matroid_independent A)). Qed.
Definition matroid_basis {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _600755 : Matroid A => fun _600756 : A -> Prop => (@matroid_spanning A _600755 _600756) /\ (@matroid_independent A _600755 _600756).
Lemma matroid_basis_def {A : Type'} : (@matroid_basis A) = (fun _600755 : Matroid A => fun _600756 : A -> Prop => (@matroid_spanning A _600755 _600756) /\ (@matroid_independent A _600755 _600756)).
Proof. exact (eq_refl (@matroid_basis A)). Qed.
Definition matroid_subspace {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _607285 : Matroid A => fun _607286 : A -> Prop => (@SUBSET A _607286 (@matroid_set A _607285)) /\ ((@matroid_span A _607285 _607286) = _607286).
Lemma matroid_subspace_def {A : Type'} : (@matroid_subspace A) = (fun _607285 : Matroid A => fun _607286 : A -> Prop => (@SUBSET A _607286 (@matroid_set A _607285)) /\ ((@matroid_span A _607285 _607286) = _607286)).
Proof. exact (eq_refl (@matroid_subspace A)). Qed.
Definition submatroid {A : Type'} : (Matroid A) -> (A -> Prop) -> Matroid A := fun _607432 : Matroid A => fun _607433 : A -> Prop => @matroid A (@pair (A -> Prop) ((A -> Prop) -> A -> Prop) (@matroid_span A _607432 (@INTER A (@matroid_set A _607432) _607433)) (@matroid_span A _607432)).
Lemma submatroid_def {A : Type'} : (@submatroid A) = (fun _607432 : Matroid A => fun _607433 : A -> Prop => @matroid A (@pair (A -> Prop) ((A -> Prop) -> A -> Prop) (@matroid_span A _607432 (@INTER A (@matroid_set A _607432) _607433)) (@matroid_span A _607432))).
Proof. exact (eq_refl (@submatroid A)). Qed.
Definition matroid_finite_dimensional {A : Type'} : (Matroid A) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))))) -> (Matroid A) -> Prop) (fun matroid_finite_dimensional' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))))) -> (Matroid A) -> Prop => forall _607866 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))), forall m : Matroid A, (matroid_finite_dimensional' _607866 m) = (exists b : A -> Prop, (@FINITE A b) /\ (@matroid_spanning A m b))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))))))))))).
Lemma matroid_finite_dimensional_def {A : Type'} : (@matroid_finite_dimensional A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))))) -> (Matroid A) -> Prop) (fun matroid_finite_dimensional' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))))) -> (Matroid A) -> Prop => forall _607866 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))), forall m : Matroid A, (matroid_finite_dimensional' _607866 m) = (exists b : A -> Prop, (@FINITE A b) /\ (@matroid_spanning A m b))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))))))))))))).
Proof. exact (eq_refl (@matroid_finite_dimensional A)). Qed.
Definition matroid_dimension {A : Type'} : (Matroid A) -> N := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> (Matroid A) -> N) (fun matroid_dimension' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> (Matroid A) -> N => forall _607891 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))), forall m : Matroid A, (matroid_dimension' _607891 m) = (@ε N (fun n : N => forall b : A -> Prop, (@matroid_basis A m b) -> @HAS_SIZE A b n))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))).
Lemma matroid_dimension_def {A : Type'} : (@matroid_dimension A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> (Matroid A) -> N) (fun matroid_dimension' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> (Matroid A) -> N => forall _607891 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))), forall m : Matroid A, (matroid_dimension' _607891 m) = (@ε N (fun n : N => forall b : A -> Prop, (@matroid_basis A m b) -> @HAS_SIZE A b n))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))).
Proof. exact (eq_refl (@matroid_dimension A)). Qed.
Definition matroid_finite_dim {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop) (fun matroid_finite_dim' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop => forall _608005 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_finite_dim' _608005 m s) = ((@SUBSET A s (@matroid_set A m)) /\ (@matroid_finite_dimensional A (@submatroid A m s)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))).
Lemma matroid_finite_dim_def {A : Type'} : (@matroid_finite_dim A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop) (fun matroid_finite_dim' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop => forall _608005 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_finite_dim' _608005 m s) = ((@SUBSET A s (@matroid_set A m)) /\ (@matroid_finite_dimensional A (@submatroid A m s)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))))).
Proof. exact (eq_refl (@matroid_finite_dim A)). Qed.
Definition matroid_dim {A : Type'} : (Matroid A) -> (A -> Prop) -> N := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (Matroid A) -> (A -> Prop) -> N) (fun matroid_dim' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (Matroid A) -> (A -> Prop) -> N => forall _608119 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_dim' _608119 m s) = (@matroid_dimension A (@submatroid A m s))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))).
Lemma matroid_dim_def {A : Type'} : (@matroid_dim A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (Matroid A) -> (A -> Prop) -> N) (fun matroid_dim' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (Matroid A) -> (A -> Prop) -> N => forall _608119 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_dim' _608119 m s) = (@matroid_dimension A (@submatroid A m s))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))).
Proof. exact (eq_refl (@matroid_dim A)). Qed.
Definition binom : (prod N N) -> N := @ε ((prod N (prod N (prod N (prod N N)))) -> (prod N N) -> N) (fun binom' : (prod N (prod N (prod N (prod N N)))) -> (prod N N) -> N => forall _612257 : prod N (prod N (prod N (prod N N))), (forall n : N, (binom' _612257 (@pair N N n (NUMERAL 0%N))) = (NUMERAL (BIT1 0%N))) /\ ((forall k : N, (binom' _612257 (@pair N N (NUMERAL 0%N) (N.succ k))) = (NUMERAL 0%N)) /\ (forall n : N, forall k : N, (binom' _612257 (@pair N N (N.succ n) (N.succ k))) = (N.add (binom' _612257 (@pair N N n (N.succ k))) (binom' _612257 (@pair N N n k)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))).
Lemma binom_def : binom = (@ε ((prod N (prod N (prod N (prod N N)))) -> (prod N N) -> N) (fun binom' : (prod N (prod N (prod N (prod N N)))) -> (prod N N) -> N => forall _612257 : prod N (prod N (prod N (prod N N))), (forall n : N, (binom' _612257 (@pair N N n (NUMERAL 0%N))) = (NUMERAL (BIT1 0%N))) /\ ((forall k : N, (binom' _612257 (@pair N N (NUMERAL 0%N) (N.succ k))) = (NUMERAL 0%N)) /\ (forall n : N, forall k : N, (binom' _612257 (@pair N N (N.succ n) (N.succ k))) = (N.add (binom' _612257 (@pair N N n (N.succ k))) (binom' _612257 (@pair N N n k)))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))).
Proof. exact (eq_refl binom). Qed.
Definition istopology {_350906 : Type'} : ((_350906 -> Prop) -> Prop) -> Prop := fun _613298 : (_350906 -> Prop) -> Prop => (@IN (_350906 -> Prop) (@EMPTY _350906) _613298) /\ ((forall s : _350906 -> Prop, forall t : _350906 -> Prop, ((@IN (_350906 -> Prop) s _613298) /\ (@IN (_350906 -> Prop) t _613298)) -> @IN (_350906 -> Prop) (@INTER _350906 s t) _613298) /\ (forall k : (_350906 -> Prop) -> Prop, (@SUBSET (_350906 -> Prop) k _613298) -> @IN (_350906 -> Prop) (@UNIONS _350906 k) _613298)).
Lemma istopology_def {_350906 : Type'} : (@istopology _350906) = (fun _613298 : (_350906 -> Prop) -> Prop => (@IN (_350906 -> Prop) (@EMPTY _350906) _613298) /\ ((forall s : _350906 -> Prop, forall t : _350906 -> Prop, ((@IN (_350906 -> Prop) s _613298) /\ (@IN (_350906 -> Prop) t _613298)) -> @IN (_350906 -> Prop) (@INTER _350906 s t) _613298) /\ (forall k : (_350906 -> Prop) -> Prop, (@SUBSET (_350906 -> Prop) k _613298) -> @IN (_350906 -> Prop) (@UNIONS _350906 k) _613298))).
Proof. exact (eq_refl (@istopology _350906)). Qed.
Definition topspace {_350968 : Type'} : (Topology _350968) -> _350968 -> Prop := fun _613340 : Topology _350968 => @UNIONS _350968 (@GSPEC (_350968 -> Prop) (fun GEN_PVAR_1231 : _350968 -> Prop => exists s : _350968 -> Prop, @SETSPEC (_350968 -> Prop) GEN_PVAR_1231 (@open_in _350968 _613340 s) s)).
Lemma topspace_def {_350968 : Type'} : (@topspace _350968) = (fun _613340 : Topology _350968 => @UNIONS _350968 (@GSPEC (_350968 -> Prop) (fun GEN_PVAR_1231 : _350968 -> Prop => exists s : _350968 -> Prop, @SETSPEC (_350968 -> Prop) GEN_PVAR_1231 (@open_in _350968 _613340 s) s))).
Proof. exact (eq_refl (@topspace _350968)). Qed.
Definition closed_in {_351271 : Type'} : (Topology _351271) -> (_351271 -> Prop) -> Prop := fun _613375 : Topology _351271 => fun _613376 : _351271 -> Prop => (@SUBSET _351271 _613376 (@topspace _351271 _613375)) /\ (@open_in _351271 _613375 (@DIFF _351271 (@topspace _351271 _613375) _613376)).
Lemma closed_in_def {_351271 : Type'} : (@closed_in _351271) = (fun _613375 : Topology _351271 => fun _613376 : _351271 -> Prop => (@SUBSET _351271 _613376 (@topspace _351271 _613375)) /\ (@open_in _351271 _613375 (@DIFF _351271 (@topspace _351271 _613375) _613376))).
Proof. exact (eq_refl (@closed_in _351271)). Qed.
Definition discrete_topology {A : Type'} : (A -> Prop) -> Topology A := fun _613954 : A -> Prop => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1235 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1235 (@SUBSET A s _613954) s)).
Lemma discrete_topology_def {A : Type'} : (@discrete_topology A) = (fun _613954 : A -> Prop => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1235 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1235 (@SUBSET A s _613954) s))).
Proof. exact (eq_refl (@discrete_topology A)). Qed.
Definition discrete_space {A : Type'} : (Topology A) -> Prop := fun _613959 : Topology A => (@discrete_topology A (@topspace A _613959)) = _613959.
Lemma discrete_space_def {A : Type'} : (@discrete_space A) = (fun _613959 : Topology A => (@discrete_topology A (@topspace A _613959)) = _613959).
Proof. exact (eq_refl (@discrete_space A)). Qed.
Definition subtopology {_352607 : Type'} : (Topology _352607) -> (_352607 -> Prop) -> Topology _352607 := fun _614305 : Topology _352607 => fun _614306 : _352607 -> Prop => @topology _352607 (@GSPEC (_352607 -> Prop) (fun GEN_PVAR_1237 : _352607 -> Prop => exists s : _352607 -> Prop, @SETSPEC (_352607 -> Prop) GEN_PVAR_1237 (@open_in _352607 _614305 s) (@INTER _352607 s _614306))).
Lemma subtopology_def {_352607 : Type'} : (@subtopology _352607) = (fun _614305 : Topology _352607 => fun _614306 : _352607 -> Prop => @topology _352607 (@GSPEC (_352607 -> Prop) (fun GEN_PVAR_1237 : _352607 -> Prop => exists s : _352607 -> Prop, @SETSPEC (_352607 -> Prop) GEN_PVAR_1237 (@open_in _352607 _614305 s) (@INTER _352607 s _614306)))).
Proof. exact (eq_refl (@subtopology _352607)). Qed.
Definition hereditarily {A : Type'} : ((Topology A) -> Prop) -> (Topology A) -> Prop := fun _615305 : (Topology A) -> Prop => fun _615306 : Topology A => forall s : A -> Prop, (@SUBSET A s (@topspace A _615306)) -> _615305 (@subtopology A _615306 s).
Lemma hereditarily_def {A : Type'} : (@hereditarily A) = (fun _615305 : (Topology A) -> Prop => fun _615306 : Topology A => forall s : A -> Prop, (@SUBSET A s (@topspace A _615306)) -> _615305 (@subtopology A _615306 s)).
Proof. exact (eq_refl (@hereditarily A)). Qed.
Definition derived_set_of {A : Type'} : (Topology A) -> (A -> Prop) -> A -> Prop := fun _615327 : Topology A => fun _615328 : A -> Prop => @GSPEC A (fun GEN_PVAR_1246 : A => exists x : A, @SETSPEC A GEN_PVAR_1246 ((@IN A x (@topspace A _615327)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _615327 t)) -> exists y : A, (~ (y = x)) /\ ((@IN A y _615328) /\ (@IN A y t)))) x).
Lemma derived_set_of_def {A : Type'} : (@derived_set_of A) = (fun _615327 : Topology A => fun _615328 : A -> Prop => @GSPEC A (fun GEN_PVAR_1246 : A => exists x : A, @SETSPEC A GEN_PVAR_1246 ((@IN A x (@topspace A _615327)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _615327 t)) -> exists y : A, (~ (y = x)) /\ ((@IN A y _615328) /\ (@IN A y t)))) x)).
Proof. exact (eq_refl (@derived_set_of A)). Qed.
Definition closure_of {A : Type'} : (Topology A) -> (A -> Prop) -> A -> Prop := fun _615766 : Topology A => fun _615767 : A -> Prop => @GSPEC A (fun GEN_PVAR_1249 : A => exists x : A, @SETSPEC A GEN_PVAR_1249 ((@IN A x (@topspace A _615766)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _615766 t)) -> exists y : A, (@IN A y _615767) /\ (@IN A y t))) x).
Lemma closure_of_def {A : Type'} : (@closure_of A) = (fun _615766 : Topology A => fun _615767 : A -> Prop => @GSPEC A (fun GEN_PVAR_1249 : A => exists x : A, @SETSPEC A GEN_PVAR_1249 ((@IN A x (@topspace A _615766)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _615766 t)) -> exists y : A, (@IN A y _615767) /\ (@IN A y t))) x)).
Proof. exact (eq_refl (@closure_of A)). Qed.
Definition interior_of {_357493 : Type'} : (Topology _357493) -> (_357493 -> Prop) -> _357493 -> Prop := fun _616306 : Topology _357493 => fun _616307 : _357493 -> Prop => @GSPEC _357493 (fun GEN_PVAR_1259 : _357493 => exists x : _357493, @SETSPEC _357493 GEN_PVAR_1259 (exists t : _357493 -> Prop, (@open_in _357493 _616306 t) /\ ((@IN _357493 x t) /\ (@SUBSET _357493 t _616307))) x).
Lemma interior_of_def {_357493 : Type'} : (@interior_of _357493) = (fun _616306 : Topology _357493 => fun _616307 : _357493 -> Prop => @GSPEC _357493 (fun GEN_PVAR_1259 : _357493 => exists x : _357493, @SETSPEC _357493 GEN_PVAR_1259 (exists t : _357493 -> Prop, (@open_in _357493 _616306 t) /\ ((@IN _357493 x t) /\ (@SUBSET _357493 t _616307))) x)).
Proof. exact (eq_refl (@interior_of _357493)). Qed.
Definition frontier_of {_358829 : Type'} : (Topology _358829) -> (_358829 -> Prop) -> _358829 -> Prop := fun _616667 : Topology _358829 => fun _616668 : _358829 -> Prop => @DIFF _358829 (@closure_of _358829 _616667 _616668) (@interior_of _358829 _616667 _616668).
Lemma frontier_of_def {_358829 : Type'} : (@frontier_of _358829) = (fun _616667 : Topology _358829 => fun _616668 : _358829 -> Prop => @DIFF _358829 (@closure_of _358829 _616667 _616668) (@interior_of _358829 _616667 _616668)).
Proof. exact (eq_refl (@frontier_of _358829)). Qed.
Definition locally_finite_in {_360557 : Type'} : (Topology _360557) -> ((_360557 -> Prop) -> Prop) -> Prop := fun _617070 : Topology _360557 => fun _617071 : (_360557 -> Prop) -> Prop => (forall u : _360557 -> Prop, (@IN (_360557 -> Prop) u _617071) -> @SUBSET _360557 u (@topspace _360557 _617070)) /\ (forall x : _360557, (@IN _360557 x (@topspace _360557 _617070)) -> exists v : _360557 -> Prop, (@open_in _360557 _617070 v) /\ ((@IN _360557 x v) /\ (@FINITE (_360557 -> Prop) (@GSPEC (_360557 -> Prop) (fun GEN_PVAR_1263 : _360557 -> Prop => exists u : _360557 -> Prop, @SETSPEC (_360557 -> Prop) GEN_PVAR_1263 ((@IN (_360557 -> Prop) u _617071) /\ (~ ((@INTER _360557 u v) = (@EMPTY _360557)))) u))))).
Lemma locally_finite_in_def {_360557 : Type'} : (@locally_finite_in _360557) = (fun _617070 : Topology _360557 => fun _617071 : (_360557 -> Prop) -> Prop => (forall u : _360557 -> Prop, (@IN (_360557 -> Prop) u _617071) -> @SUBSET _360557 u (@topspace _360557 _617070)) /\ (forall x : _360557, (@IN _360557 x (@topspace _360557 _617070)) -> exists v : _360557 -> Prop, (@open_in _360557 _617070 v) /\ ((@IN _360557 x v) /\ (@FINITE (_360557 -> Prop) (@GSPEC (_360557 -> Prop) (fun GEN_PVAR_1263 : _360557 -> Prop => exists u : _360557 -> Prop, @SETSPEC (_360557 -> Prop) GEN_PVAR_1263 ((@IN (_360557 -> Prop) u _617071) /\ (~ ((@INTER _360557 u v) = (@EMPTY _360557)))) u)))))).
Proof. exact (eq_refl (@locally_finite_in _360557)). Qed.
Definition continuous_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _617296 : prod (Topology A) (Topology B) => fun _617297 : A -> B => (forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _617296))) -> @IN B (_617297 x) (@topspace B (@snd (Topology A) (Topology B) _617296))) /\ (forall u : B -> Prop, (@open_in B (@snd (Topology A) (Topology B) _617296) u) -> @open_in A (@fst (Topology A) (Topology B) _617296) (@GSPEC A (fun GEN_PVAR_1276 : A => exists x : A, @SETSPEC A GEN_PVAR_1276 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _617296))) /\ (@IN B (_617297 x) u)) x))).
Lemma continuous_map_def {A B : Type'} : (@continuous_map A B) = (fun _617296 : prod (Topology A) (Topology B) => fun _617297 : A -> B => (forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _617296))) -> @IN B (_617297 x) (@topspace B (@snd (Topology A) (Topology B) _617296))) /\ (forall u : B -> Prop, (@open_in B (@snd (Topology A) (Topology B) _617296) u) -> @open_in A (@fst (Topology A) (Topology B) _617296) (@GSPEC A (fun GEN_PVAR_1276 : A => exists x : A, @SETSPEC A GEN_PVAR_1276 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _617296))) /\ (@IN B (_617297 x) u)) x)))).
Proof. exact (eq_refl (@continuous_map A B)). Qed.
Definition open_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _625338 : prod (Topology A) (Topology B) => fun _625339 : A -> B => forall u : A -> Prop, (@open_in A (@fst (Topology A) (Topology B) _625338) u) -> @open_in B (@snd (Topology A) (Topology B) _625338) (@IMAGE A B _625339 u).
Lemma open_map_def {A B : Type'} : (@open_map A B) = (fun _625338 : prod (Topology A) (Topology B) => fun _625339 : A -> B => forall u : A -> Prop, (@open_in A (@fst (Topology A) (Topology B) _625338) u) -> @open_in B (@snd (Topology A) (Topology B) _625338) (@IMAGE A B _625339 u)).
Proof. exact (eq_refl (@open_map A B)). Qed.
Definition closed_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _625355 : prod (Topology A) (Topology B) => fun _625356 : A -> B => forall u : A -> Prop, (@closed_in A (@fst (Topology A) (Topology B) _625355) u) -> @closed_in B (@snd (Topology A) (Topology B) _625355) (@IMAGE A B _625356 u).
Lemma closed_map_def {A B : Type'} : (@closed_map A B) = (fun _625355 : prod (Topology A) (Topology B) => fun _625356 : A -> B => forall u : A -> Prop, (@closed_in A (@fst (Topology A) (Topology B) _625355) u) -> @closed_in B (@snd (Topology A) (Topology B) _625355) (@IMAGE A B _625356 u)).
Proof. exact (eq_refl (@closed_map A B)). Qed.
Definition quotient_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _629186 : prod (Topology A) (Topology B) => fun _629187 : A -> B => ((@IMAGE A B _629187 (@topspace A (@fst (Topology A) (Topology B) _629186))) = (@topspace B (@snd (Topology A) (Topology B) _629186))) /\ (forall u : B -> Prop, (@SUBSET B u (@topspace B (@snd (Topology A) (Topology B) _629186))) -> (@open_in A (@fst (Topology A) (Topology B) _629186) (@GSPEC A (fun GEN_PVAR_1371 : A => exists x : A, @SETSPEC A GEN_PVAR_1371 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _629186))) /\ (@IN B (_629187 x) u)) x))) = (@open_in B (@snd (Topology A) (Topology B) _629186) u)).
Lemma quotient_map_def {A B : Type'} : (@quotient_map A B) = (fun _629186 : prod (Topology A) (Topology B) => fun _629187 : A -> B => ((@IMAGE A B _629187 (@topspace A (@fst (Topology A) (Topology B) _629186))) = (@topspace B (@snd (Topology A) (Topology B) _629186))) /\ (forall u : B -> Prop, (@SUBSET B u (@topspace B (@snd (Topology A) (Topology B) _629186))) -> (@open_in A (@fst (Topology A) (Topology B) _629186) (@GSPEC A (fun GEN_PVAR_1371 : A => exists x : A, @SETSPEC A GEN_PVAR_1371 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _629186))) /\ (@IN B (_629187 x) u)) x))) = (@open_in B (@snd (Topology A) (Topology B) _629186) u))).
Proof. exact (eq_refl (@quotient_map A B)). Qed.
Definition prod_topology {A B : Type'} : (Topology A) -> (Topology B) -> Topology (prod A B) := fun _638421 : Topology A => fun _638422 : Topology B => @topology (prod A B) (@UNION_OF (prod A B) (@ARBITRARY (prod A B)) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_1385 : (prod A B) -> Prop => exists s : A -> Prop, exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_1385 ((@open_in A _638421 s) /\ (@open_in B _638422 t)) (@CROSS A B s t)))).
Lemma prod_topology_def {A B : Type'} : (@prod_topology A B) = (fun _638421 : Topology A => fun _638422 : Topology B => @topology (prod A B) (@UNION_OF (prod A B) (@ARBITRARY (prod A B)) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_1385 : (prod A B) -> Prop => exists s : A -> Prop, exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_1385 ((@open_in A _638421 s) /\ (@open_in B _638422 t)) (@CROSS A B s t))))).
Proof. exact (eq_refl (@prod_topology A B)). Qed.
Definition product_topology {A K : Type'} : (K -> Prop) -> (K -> Topology A) -> Topology (K -> A) := fun _642306 : K -> Prop => fun _642307 : K -> Topology A => @topology (K -> A) (@UNION_OF (K -> A) (@ARBITRARY (K -> A)) (@relative_to (K -> A) (@INTERSECTION_OF (K -> A) (@FINITE ((K -> A) -> Prop)) (@GSPEC ((K -> A) -> Prop) (fun GEN_PVAR_1390 : (K -> A) -> Prop => exists k : K, exists u : A -> Prop, @SETSPEC ((K -> A) -> Prop) GEN_PVAR_1390 ((@IN K k _642306) /\ (@open_in A (_642307 k) u)) (@GSPEC (K -> A) (fun GEN_PVAR_1389 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1389 (@IN A (x k) u) x))))) (@GSPEC (K -> A) (fun GEN_PVAR_1391 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1391 ((@EXTENSIONAL K A _642306 x) /\ (forall k : K, (@IN K k _642306) -> @IN A (x k) (@topspace A (_642307 k)))) x)))).
Lemma product_topology_def {A K : Type'} : (@product_topology A K) = (fun _642306 : K -> Prop => fun _642307 : K -> Topology A => @topology (K -> A) (@UNION_OF (K -> A) (@ARBITRARY (K -> A)) (@relative_to (K -> A) (@INTERSECTION_OF (K -> A) (@FINITE ((K -> A) -> Prop)) (@GSPEC ((K -> A) -> Prop) (fun GEN_PVAR_1390 : (K -> A) -> Prop => exists k : K, exists u : A -> Prop, @SETSPEC ((K -> A) -> Prop) GEN_PVAR_1390 ((@IN K k _642306) /\ (@open_in A (_642307 k) u)) (@GSPEC (K -> A) (fun GEN_PVAR_1389 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1389 (@IN A (x k) u) x))))) (@GSPEC (K -> A) (fun GEN_PVAR_1391 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1391 ((@EXTENSIONAL K A _642306 x) /\ (forall k : K, (@IN K k _642306) -> @IN A (x k) (@topspace A (_642307 k)))) x))))).
Proof. exact (eq_refl (@product_topology A K)). Qed.
Definition sum_topology {A K : Type'} : (K -> Prop) -> (K -> Topology A) -> Topology (prod K A) := fun _649397 : K -> Prop => fun _649398 : K -> Topology A => @topology (prod K A) (@GSPEC ((prod K A) -> Prop) (fun GEN_PVAR_1454 : (prod K A) -> Prop => exists u : (prod K A) -> Prop, @SETSPEC ((prod K A) -> Prop) GEN_PVAR_1454 ((@SUBSET (prod K A) u (@disjoint_union A K _649397 (@o K (Topology A) (A -> Prop) (@topspace A) _649398))) /\ (forall i : K, (@IN K i _649397) -> @open_in A (_649398 i) (@GSPEC A (fun GEN_PVAR_1453 : A => exists x : A, @SETSPEC A GEN_PVAR_1453 (@IN (prod K A) (@pair K A i x) u) x)))) u)).
Lemma sum_topology_def {A K : Type'} : (@sum_topology A K) = (fun _649397 : K -> Prop => fun _649398 : K -> Topology A => @topology (prod K A) (@GSPEC ((prod K A) -> Prop) (fun GEN_PVAR_1454 : (prod K A) -> Prop => exists u : (prod K A) -> Prop, @SETSPEC ((prod K A) -> Prop) GEN_PVAR_1454 ((@SUBSET (prod K A) u (@disjoint_union A K _649397 (@o K (Topology A) (A -> Prop) (@topspace A) _649398))) /\ (forall i : K, (@IN K i _649397) -> @open_in A (_649398 i) (@GSPEC A (fun GEN_PVAR_1453 : A => exists x : A, @SETSPEC A GEN_PVAR_1453 (@IN (prod K A) (@pair K A i x) u) x)))) u))).
Proof. exact (eq_refl (@sum_topology A K)). Qed.
Definition homeomorphic_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _649924 : prod (Topology A) (Topology B) => fun _649925 : A -> B => (@quotient_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _649924) (@snd (Topology A) (Topology B) _649924)) _649925) /\ (forall x : A, forall y : A, ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _649924))) /\ (@IN A y (@topspace A (@fst (Topology A) (Topology B) _649924)))) -> ((_649925 x) = (_649925 y)) = (x = y)).
Lemma homeomorphic_map_def {A B : Type'} : (@homeomorphic_map A B) = (fun _649924 : prod (Topology A) (Topology B) => fun _649925 : A -> B => (@quotient_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _649924) (@snd (Topology A) (Topology B) _649924)) _649925) /\ (forall x : A, forall y : A, ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _649924))) /\ (@IN A y (@topspace A (@fst (Topology A) (Topology B) _649924)))) -> ((_649925 x) = (_649925 y)) = (x = y))).
Proof. exact (eq_refl (@homeomorphic_map A B)). Qed.
Definition homeomorphic_maps {A B : Type'} : (prod (Topology A) (Topology B)) -> (prod (A -> B) (B -> A)) -> Prop := fun _649941 : prod (Topology A) (Topology B) => fun _649942 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _649941) (@snd (Topology A) (Topology B) _649941)) (@fst (A -> B) (B -> A) _649942)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _649941) (@fst (Topology A) (Topology B) _649941)) (@snd (A -> B) (B -> A) _649942)) /\ ((forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _649941))) -> (@snd (A -> B) (B -> A) _649942 (@fst (A -> B) (B -> A) _649942 x)) = x) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _649941))) -> (@fst (A -> B) (B -> A) _649942 (@snd (A -> B) (B -> A) _649942 y)) = y))).
Lemma homeomorphic_maps_def {A B : Type'} : (@homeomorphic_maps A B) = (fun _649941 : prod (Topology A) (Topology B) => fun _649942 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _649941) (@snd (Topology A) (Topology B) _649941)) (@fst (A -> B) (B -> A) _649942)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _649941) (@fst (Topology A) (Topology B) _649941)) (@snd (A -> B) (B -> A) _649942)) /\ ((forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _649941))) -> (@snd (A -> B) (B -> A) _649942 (@fst (A -> B) (B -> A) _649942 x)) = x) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _649941))) -> (@fst (A -> B) (B -> A) _649942 (@snd (A -> B) (B -> A) _649942 y)) = y)))).
Proof. exact (eq_refl (@homeomorphic_maps A B)). Qed.
Definition homeomorphic_space {A B : Type'} : (Topology A) -> (Topology B) -> Prop := fun _703343 : Topology A => fun _703344 : Topology B => exists f : A -> B, exists g : B -> A, @homeomorphic_maps A B (@pair (Topology A) (Topology B) _703343 _703344) (@pair (A -> B) (B -> A) f g).
Lemma homeomorphic_space_def {A B : Type'} : (@homeomorphic_space A B) = (fun _703343 : Topology A => fun _703344 : Topology B => exists f : A -> B, exists g : B -> A, @homeomorphic_maps A B (@pair (Topology A) (Topology B) _703343 _703344) (@pair (A -> B) (B -> A) f g)).
Proof. exact (eq_refl (@homeomorphic_space A B)). Qed.
Definition embedding_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _704677 : prod (Topology A) (Topology B) => fun _704678 : A -> B => @homeomorphic_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _704677) (@subtopology B (@snd (Topology A) (Topology B) _704677) (@IMAGE A B _704678 (@topspace A (@fst (Topology A) (Topology B) _704677))))) _704678.
Lemma embedding_map_def {A B : Type'} : (@embedding_map A B) = (fun _704677 : prod (Topology A) (Topology B) => fun _704678 : A -> B => @homeomorphic_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _704677) (@subtopology B (@snd (Topology A) (Topology B) _704677) (@IMAGE A B _704678 (@topspace A (@fst (Topology A) (Topology B) _704677))))) _704678).
Proof. exact (eq_refl (@embedding_map A B)). Qed.
Definition retraction_maps {A B : Type'} : (prod (Topology A) (Topology B)) -> (prod (A -> B) (B -> A)) -> Prop := fun _707808 : prod (Topology A) (Topology B) => fun _707809 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _707808) (@snd (Topology A) (Topology B) _707808)) (@fst (A -> B) (B -> A) _707809)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _707808) (@fst (Topology A) (Topology B) _707808)) (@snd (A -> B) (B -> A) _707809)) /\ (forall x : B, (@IN B x (@topspace B (@snd (Topology A) (Topology B) _707808))) -> (@fst (A -> B) (B -> A) _707809 (@snd (A -> B) (B -> A) _707809 x)) = x)).
Lemma retraction_maps_def {A B : Type'} : (@retraction_maps A B) = (fun _707808 : prod (Topology A) (Topology B) => fun _707809 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _707808) (@snd (Topology A) (Topology B) _707808)) (@fst (A -> B) (B -> A) _707809)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _707808) (@fst (Topology A) (Topology B) _707808)) (@snd (A -> B) (B -> A) _707809)) /\ (forall x : B, (@IN B x (@topspace B (@snd (Topology A) (Topology B) _707808))) -> (@fst (A -> B) (B -> A) _707809 (@snd (A -> B) (B -> A) _707809 x)) = x))).
Proof. exact (eq_refl (@retraction_maps A B)). Qed.
Definition section_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _707830 : prod (Topology A) (Topology B) => fun _707831 : A -> B => exists g : B -> A, @retraction_maps B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _707830) (@fst (Topology A) (Topology B) _707830)) (@pair (B -> A) (A -> B) g _707831).
Lemma section_map_def {A B : Type'} : (@section_map A B) = (fun _707830 : prod (Topology A) (Topology B) => fun _707831 : A -> B => exists g : B -> A, @retraction_maps B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _707830) (@fst (Topology A) (Topology B) _707830)) (@pair (B -> A) (A -> B) g _707831)).
Proof. exact (eq_refl (@section_map A B)). Qed.
Definition retraction_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _707847 : prod (Topology A) (Topology B) => fun _707848 : A -> B => exists g : B -> A, @retraction_maps A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _707847) (@snd (Topology A) (Topology B) _707847)) (@pair (A -> B) (B -> A) _707848 g).
Lemma retraction_map_def {A B : Type'} : (@retraction_map A B) = (fun _707847 : prod (Topology A) (Topology B) => fun _707848 : A -> B => exists g : B -> A, @retraction_maps A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _707847) (@snd (Topology A) (Topology B) _707847)) (@pair (A -> B) (B -> A) _707848 g)).
Proof. exact (eq_refl (@retraction_map A B)). Qed.
Definition retract_of_space {A : Type'} : (A -> Prop) -> (Topology A) -> Prop := fun _713400 : A -> Prop => fun _713401 : Topology A => (@SUBSET A _713400 (@topspace A _713401)) /\ (exists r : A -> A, (@continuous_map A A (@pair (Topology A) (Topology A) _713401 (@subtopology A _713401 _713400)) r) /\ (forall x : A, (@IN A x _713400) -> (r x) = x)).
Lemma retract_of_space_def {A : Type'} : (@retract_of_space A) = (fun _713400 : A -> Prop => fun _713401 : Topology A => (@SUBSET A _713400 (@topspace A _713401)) /\ (exists r : A -> A, (@continuous_map A A (@pair (Topology A) (Topology A) _713401 (@subtopology A _713401 _713400)) r) /\ (forall x : A, (@IN A x _713400) -> (r x) = x))).
Proof. exact (eq_refl (@retract_of_space A)). Qed.
Definition compact_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _714179 : Topology A => fun _714180 : A -> Prop => (@SUBSET A _714180 (@topspace A _714179)) /\ (forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _714179 u) /\ (@SUBSET A _714180 (@UNIONS A U))) -> exists V : (A -> Prop) -> Prop, (@FINITE (A -> Prop) V) /\ ((@SUBSET (A -> Prop) V U) /\ (@SUBSET A _714180 (@UNIONS A V)))).
Lemma compact_in_def {A : Type'} : (@compact_in A) = (fun _714179 : Topology A => fun _714180 : A -> Prop => (@SUBSET A _714180 (@topspace A _714179)) /\ (forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _714179 u) /\ (@SUBSET A _714180 (@UNIONS A U))) -> exists V : (A -> Prop) -> Prop, (@FINITE (A -> Prop) V) /\ ((@SUBSET (A -> Prop) V U) /\ (@SUBSET A _714180 (@UNIONS A V))))).
Proof. exact (eq_refl (@compact_in A)). Qed.
Definition compact_space {A : Type'} : (Topology A) -> Prop := fun _714191 : Topology A => @compact_in A _714191 (@topspace A _714191).
Lemma compact_space_def {A : Type'} : (@compact_space A) = (fun _714191 : Topology A => @compact_in A _714191 (@topspace A _714191)).
Proof. exact (eq_refl (@compact_space A)). Qed.
Definition separated_in {_389322 : Type'} : (Topology _389322) -> (_389322 -> Prop) -> (_389322 -> Prop) -> Prop := fun _727300 : Topology _389322 => fun _727301 : _389322 -> Prop => fun _727302 : _389322 -> Prop => (@SUBSET _389322 _727301 (@topspace _389322 _727300)) /\ ((@SUBSET _389322 _727302 (@topspace _389322 _727300)) /\ (((@INTER _389322 _727301 (@closure_of _389322 _727300 _727302)) = (@EMPTY _389322)) /\ ((@INTER _389322 _727302 (@closure_of _389322 _727300 _727301)) = (@EMPTY _389322)))).
Lemma separated_in_def {_389322 : Type'} : (@separated_in _389322) = (fun _727300 : Topology _389322 => fun _727301 : _389322 -> Prop => fun _727302 : _389322 -> Prop => (@SUBSET _389322 _727301 (@topspace _389322 _727300)) /\ ((@SUBSET _389322 _727302 (@topspace _389322 _727300)) /\ (((@INTER _389322 _727301 (@closure_of _389322 _727300 _727302)) = (@EMPTY _389322)) /\ ((@INTER _389322 _727302 (@closure_of _389322 _727300 _727301)) = (@EMPTY _389322))))).
Proof. exact (eq_refl (@separated_in _389322)). Qed.
Definition t1_space {_390503 : Type'} : (Topology _390503) -> Prop := fun _729444 : Topology _390503 => forall x : _390503, forall y : _390503, ((@IN _390503 x (@topspace _390503 _729444)) /\ ((@IN _390503 y (@topspace _390503 _729444)) /\ (~ (x = y)))) -> exists u : _390503 -> Prop, (@open_in _390503 _729444 u) /\ ((@IN _390503 x u) /\ (~ (@IN _390503 y u))).
Lemma t1_space_def {_390503 : Type'} : (@t1_space _390503) = (fun _729444 : Topology _390503 => forall x : _390503, forall y : _390503, ((@IN _390503 x (@topspace _390503 _729444)) /\ ((@IN _390503 y (@topspace _390503 _729444)) /\ (~ (x = y)))) -> exists u : _390503 -> Prop, (@open_in _390503 _729444 u) /\ ((@IN _390503 x u) /\ (~ (@IN _390503 y u)))).
Proof. exact (eq_refl (@t1_space _390503)). Qed.
Definition hausdorff_space {A : Type'} : (Topology A) -> Prop := fun _730627 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _730627)) /\ ((@IN A y (@topspace A _730627)) /\ (~ (x = y)))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _730627 u) /\ ((@open_in A _730627 v) /\ ((@IN A x u) /\ ((@IN A y v) /\ (@DISJOINT A u v)))).
Lemma hausdorff_space_def {A : Type'} : (@hausdorff_space A) = (fun _730627 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _730627)) /\ ((@IN A y (@topspace A _730627)) /\ (~ (x = y)))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _730627 u) /\ ((@open_in A _730627 v) /\ ((@IN A x u) /\ ((@IN A y v) /\ (@DISJOINT A u v))))).
Proof. exact (eq_refl (@hausdorff_space A)). Qed.
Definition kc_space {A : Type'} : (Topology A) -> Prop := fun _737184 : Topology A => forall s : A -> Prop, (@compact_in A _737184 s) -> @closed_in A _737184 s.
Lemma kc_space_def {A : Type'} : (@kc_space A) = (fun _737184 : Topology A => forall s : A -> Prop, (@compact_in A _737184 s) -> @closed_in A _737184 s).
Proof. exact (eq_refl (@kc_space A)). Qed.
Definition proper_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _738676 : prod (Topology A) (Topology B) => fun _738677 : A -> B => (@closed_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _738676) (@snd (Topology A) (Topology B) _738676)) _738677) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _738676))) -> @compact_in A (@fst (Topology A) (Topology B) _738676) (@GSPEC A (fun GEN_PVAR_1536 : A => exists x : A, @SETSPEC A GEN_PVAR_1536 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _738676))) /\ ((_738677 x) = y)) x))).
Lemma proper_map_def {A B : Type'} : (@proper_map A B) = (fun _738676 : prod (Topology A) (Topology B) => fun _738677 : A -> B => (@closed_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _738676) (@snd (Topology A) (Topology B) _738676)) _738677) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _738676))) -> @compact_in A (@fst (Topology A) (Topology B) _738676) (@GSPEC A (fun GEN_PVAR_1536 : A => exists x : A, @SETSPEC A GEN_PVAR_1536 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _738676))) /\ ((_738677 x) = y)) x)))).
Proof. exact (eq_refl (@proper_map A B)). Qed.
Definition perfect_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _747441 : prod (Topology A) (Topology B) => fun _747442 : A -> B => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _747441) (@snd (Topology A) (Topology B) _747441)) _747442) /\ ((@proper_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _747441) (@snd (Topology A) (Topology B) _747441)) _747442) /\ ((@IMAGE A B _747442 (@topspace A (@fst (Topology A) (Topology B) _747441))) = (@topspace B (@snd (Topology A) (Topology B) _747441)))).
Lemma perfect_map_def {A B : Type'} : (@perfect_map A B) = (fun _747441 : prod (Topology A) (Topology B) => fun _747442 : A -> B => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _747441) (@snd (Topology A) (Topology B) _747441)) _747442) /\ ((@proper_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _747441) (@snd (Topology A) (Topology B) _747441)) _747442) /\ ((@IMAGE A B _747442 (@topspace A (@fst (Topology A) (Topology B) _747441))) = (@topspace B (@snd (Topology A) (Topology B) _747441))))).
Proof. exact (eq_refl (@perfect_map A B)). Qed.
Definition lindelof_space {A : Type'} : (Topology A) -> Prop := fun _752246 : Topology A => forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _752246 u) /\ ((@UNIONS A U) = (@topspace A _752246))) -> exists V : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) V) /\ ((@SUBSET (A -> Prop) V U) /\ ((@UNIONS A V) = (@topspace A _752246))).
Lemma lindelof_space_def {A : Type'} : (@lindelof_space A) = (fun _752246 : Topology A => forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _752246 u) /\ ((@UNIONS A U) = (@topspace A _752246))) -> exists V : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) V) /\ ((@SUBSET (A -> Prop) V U) /\ ((@UNIONS A V) = (@topspace A _752246)))).
Proof. exact (eq_refl (@lindelof_space A)). Qed.
Definition second_countable {A : Type'} : (Topology A) -> Prop := fun _754661 : Topology A => exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _754661 v) /\ (forall u : A -> Prop, forall x : A, ((@open_in A _754661 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@SUBSET A v u)))).
Lemma second_countable_def {A : Type'} : (@second_countable A) = (fun _754661 : Topology A => exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _754661 v) /\ (forall u : A -> Prop, forall x : A, ((@open_in A _754661 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@SUBSET A v u))))).
Proof. exact (eq_refl (@second_countable A)). Qed.
Definition first_countable {A : Type'} : (Topology A) -> Prop := fun _754666 : Topology A => forall x : A, (@IN A x (@topspace A _754666)) -> exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _754666 v) /\ (forall u : A -> Prop, ((@open_in A _754666 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@SUBSET A v u)))).
Lemma first_countable_def {A : Type'} : (@first_countable A) = (fun _754666 : Topology A => forall x : A, (@IN A x (@topspace A _754666)) -> exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _754666 v) /\ (forall u : A -> Prop, ((@open_in A _754666 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@SUBSET A v u))))).
Proof. exact (eq_refl (@first_countable A)). Qed.
Definition separable_space {A : Type'} : (Topology A) -> Prop := fun _754671 : Topology A => exists c : A -> Prop, (@COUNTABLE A c) /\ ((@SUBSET A c (@topspace A _754671)) /\ ((@closure_of A _754671 c) = (@topspace A _754671))).
Lemma separable_space_def {A : Type'} : (@separable_space A) = (fun _754671 : Topology A => exists c : A -> Prop, (@COUNTABLE A c) /\ ((@SUBSET A c (@topspace A _754671)) /\ ((@closure_of A _754671 c) = (@topspace A _754671)))).
Proof. exact (eq_refl (@separable_space A)). Qed.
Definition netfilter {A : Type'} : (net A) -> (A -> Prop) -> Prop := fun _756664 : net A => @fst ((A -> Prop) -> Prop) (A -> Prop) (@dest_net A _756664).
Lemma netfilter_def {A : Type'} : (@netfilter A) = (fun _756664 : net A => @fst ((A -> Prop) -> Prop) (A -> Prop) (@dest_net A _756664)).
Proof. exact (eq_refl (@netfilter A)). Qed.
Definition netlimits {A : Type'} : (net A) -> A -> Prop := fun _756669 : net A => @snd ((A -> Prop) -> Prop) (A -> Prop) (@dest_net A _756669).
Lemma netlimits_def {A : Type'} : (@netlimits A) = (fun _756669 : net A => @snd ((A -> Prop) -> Prop) (A -> Prop) (@dest_net A _756669)).
Proof. exact (eq_refl (@netlimits A)). Qed.
Definition netlimit {A : Type'} : (net A) -> A := fun _756674 : net A => @ε A (fun x : A => @IN A x (@netlimits A _756674)).
Lemma netlimit_def {A : Type'} : (@netlimit A) = (fun _756674 : net A => @ε A (fun x : A => @IN A x (@netlimits A _756674))).
Proof. exact (eq_refl (@netlimit A)). Qed.
Definition within {_406905 : Type'} : (net _406905) -> (_406905 -> Prop) -> net _406905 := fun _756702 : net _406905 => fun _756703 : _406905 -> Prop => @mk_net _406905 (@pair ((_406905 -> Prop) -> Prop) (_406905 -> Prop) (@relative_to _406905 (@netfilter _406905 _756702) _756703) (@netlimits _406905 _756702)).
Lemma within_def {_406905 : Type'} : (@within _406905) = (fun _756702 : net _406905 => fun _756703 : _406905 -> Prop => @mk_net _406905 (@pair ((_406905 -> Prop) -> Prop) (_406905 -> Prop) (@relative_to _406905 (@netfilter _406905 _756702) _756703) (@netlimits _406905 _756702))).
Proof. exact (eq_refl (@within _406905)). Qed.
Definition eventually {A : Type'} : (A -> Prop) -> (net A) -> Prop := fun _756782 : A -> Prop => fun _756783 : net A => ((@netfilter A _756783) = (@EMPTY (A -> Prop))) \/ (exists u : A -> Prop, (@IN (A -> Prop) u (@netfilter A _756783)) /\ (forall x : A, (@IN A x (@DIFF A u (@netlimits A _756783))) -> _756782 x)).
Lemma eventually_def {A : Type'} : (@eventually A) = (fun _756782 : A -> Prop => fun _756783 : net A => ((@netfilter A _756783) = (@EMPTY (A -> Prop))) \/ (exists u : A -> Prop, (@IN (A -> Prop) u (@netfilter A _756783)) /\ (forall x : A, (@IN A x (@DIFF A u (@netlimits A _756783))) -> _756782 x))).
Proof. exact (eq_refl (@eventually A)). Qed.
Definition trivial_limit {_407078 : Type'} : (net _407078) -> Prop := fun _756794 : net _407078 => @eventually _407078 (fun x : _407078 => False) _756794.
Lemma trivial_limit_def {_407078 : Type'} : (@trivial_limit _407078) = (fun _756794 : net _407078 => @eventually _407078 (fun x : _407078 => False) _756794).
Proof. exact (eq_refl (@trivial_limit _407078)). Qed.
Definition sequentially : net N := @mk_net N (@pair ((N -> Prop) -> Prop) (N -> Prop) (@GSPEC (N -> Prop) (fun GEN_PVAR_1595 : N -> Prop => exists n : N, @SETSPEC (N -> Prop) GEN_PVAR_1595 (@IN N n (@UNIV N)) (from n))) (@EMPTY N)).
Lemma sequentially_def : sequentially = (@mk_net N (@pair ((N -> Prop) -> Prop) (N -> Prop) (@GSPEC (N -> Prop) (fun GEN_PVAR_1595 : N -> Prop => exists n : N, @SETSPEC (N -> Prop) GEN_PVAR_1595 (@IN N n (@UNIV N)) (from n))) (@EMPTY N))).
Proof. exact (eq_refl sequentially). Qed.
Definition fsigma_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _757304 : Topology A => @UNION_OF A (@COUNTABLE (A -> Prop)) (@closed_in A _757304).
Lemma fsigma_in_def {A : Type'} : (@fsigma_in A) = (fun _757304 : Topology A => @UNION_OF A (@COUNTABLE (A -> Prop)) (@closed_in A _757304)).
Proof. exact (eq_refl (@fsigma_in A)). Qed.
Definition gdelta_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _757309 : Topology A => @relative_to A (@INTERSECTION_OF A (@COUNTABLE (A -> Prop)) (@open_in A _757309)) (@topspace A _757309).
Lemma gdelta_in_def {A : Type'} : (@gdelta_in A) = (fun _757309 : Topology A => @relative_to A (@INTERSECTION_OF A (@COUNTABLE (A -> Prop)) (@open_in A _757309)) (@topspace A _757309)).
Proof. exact (eq_refl (@gdelta_in A)). Qed.
Definition is_metric_space {A : Type'} : (prod (A -> Prop) ((prod A A) -> R)) -> Prop := fun _758555 : prod (A -> Prop) ((prod A A) -> R) => (forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555))) -> Rle (R_of_N (NUMERAL 0%N)) (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y))) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555))) -> ((@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y)) = (R_of_N (NUMERAL 0%N))) = (x = y)) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555))) -> (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y)) = (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A y x))) /\ (forall x : A, forall y : A, forall z : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ ((@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A z (@fst (A -> Prop) ((prod A A) -> R) _758555)))) -> Rle (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x z)) (Rplus (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y)) (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A y z)))))).
Lemma is_metric_space_def {A : Type'} : (@is_metric_space A) = (fun _758555 : prod (A -> Prop) ((prod A A) -> R) => (forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555))) -> Rle (R_of_N (NUMERAL 0%N)) (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y))) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555))) -> ((@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y)) = (R_of_N (NUMERAL 0%N))) = (x = y)) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555))) -> (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y)) = (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A y x))) /\ (forall x : A, forall y : A, forall z : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ ((@IN A y (@fst (A -> Prop) ((prod A A) -> R) _758555)) /\ (@IN A z (@fst (A -> Prop) ((prod A A) -> R) _758555)))) -> Rle (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x z)) (Rplus (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A x y)) (@snd (A -> Prop) ((prod A A) -> R) _758555 (@pair A A y z))))))).
Proof. exact (eq_refl (@is_metric_space A)). Qed.
Definition mspace {A : Type'} : (Metric A) -> A -> Prop := fun _758795 : Metric A => @fst (A -> Prop) ((prod A A) -> R) (@dest_metric A _758795).
Lemma mspace_def {A : Type'} : (@mspace A) = (fun _758795 : Metric A => @fst (A -> Prop) ((prod A A) -> R) (@dest_metric A _758795)).
Proof. exact (eq_refl (@mspace A)). Qed.
Definition mdist {A : Type'} : (Metric A) -> (prod A A) -> R := fun _758800 : Metric A => @snd (A -> Prop) ((prod A A) -> R) (@dest_metric A _758800).
Lemma mdist_def {A : Type'} : (@mdist A) = (fun _758800 : Metric A => @snd (A -> Prop) ((prod A A) -> R) (@dest_metric A _758800)).
Proof. exact (eq_refl (@mdist A)). Qed.
Definition mball {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _759314 : Metric A => fun _759315 : prod A R => @GSPEC A (fun GEN_PVAR_1613 : A => exists y : A, @SETSPEC A GEN_PVAR_1613 ((@IN A (@fst A R _759315) (@mspace A _759314)) /\ ((@IN A y (@mspace A _759314)) /\ (Rlt (@mdist A _759314 (@pair A A (@fst A R _759315) y)) (@snd A R _759315)))) y).
Lemma mball_def {A : Type'} : (@mball A) = (fun _759314 : Metric A => fun _759315 : prod A R => @GSPEC A (fun GEN_PVAR_1613 : A => exists y : A, @SETSPEC A GEN_PVAR_1613 ((@IN A (@fst A R _759315) (@mspace A _759314)) /\ ((@IN A y (@mspace A _759314)) /\ (Rlt (@mdist A _759314 (@pair A A (@fst A R _759315) y)) (@snd A R _759315)))) y)).
Proof. exact (eq_refl (@mball A)). Qed.
Definition submetric {A : Type'} : (Metric A) -> (A -> Prop) -> Metric A := fun _759384 : Metric A => fun _759385 : A -> Prop => @metric A (@pair (A -> Prop) ((prod A A) -> R) (@INTER A _759385 (@mspace A _759384)) (@mdist A _759384)).
Lemma submetric_def {A : Type'} : (@submetric A) = (fun _759384 : Metric A => fun _759385 : A -> Prop => @metric A (@pair (A -> Prop) ((prod A A) -> R) (@INTER A _759385 (@mspace A _759384)) (@mdist A _759384))).
Proof. exact (eq_refl (@submetric A)). Qed.
Definition mtopology {A : Type'} : (Metric A) -> Topology A := fun _759402 : Metric A => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1614 : A -> Prop => exists u : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1614 ((@SUBSET A u (@mspace A _759402)) /\ (forall x : A, (@IN A x u) -> exists r : R, (Rlt (R_of_N (NUMERAL 0%N)) r) /\ (@SUBSET A (@mball A _759402 (@pair A R x r)) u))) u)).
Lemma mtopology_def {A : Type'} : (@mtopology A) = (fun _759402 : Metric A => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1614 : A -> Prop => exists u : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1614 ((@SUBSET A u (@mspace A _759402)) /\ (forall x : A, (@IN A x u) -> exists r : R, (Rlt (R_of_N (NUMERAL 0%N)) r) /\ (@SUBSET A (@mball A _759402 (@pair A R x r)) u))) u))).
Proof. exact (eq_refl (@mtopology A)). Qed.
Definition mcball {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _759681 : Metric A => fun _759682 : prod A R => @GSPEC A (fun GEN_PVAR_1620 : A => exists y : A, @SETSPEC A GEN_PVAR_1620 ((@IN A (@fst A R _759682) (@mspace A _759681)) /\ ((@IN A y (@mspace A _759681)) /\ (Rle (@mdist A _759681 (@pair A A (@fst A R _759682) y)) (@snd A R _759682)))) y).
Lemma mcball_def {A : Type'} : (@mcball A) = (fun _759681 : Metric A => fun _759682 : prod A R => @GSPEC A (fun GEN_PVAR_1620 : A => exists y : A, @SETSPEC A GEN_PVAR_1620 ((@IN A (@fst A R _759682) (@mspace A _759681)) /\ ((@IN A y (@mspace A _759681)) /\ (Rle (@mdist A _759681 (@pair A A (@fst A R _759682) y)) (@snd A R _759682)))) y)).
Proof. exact (eq_refl (@mcball A)). Qed.
Definition msphere {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _759894 : Metric A => fun _759895 : prod A R => @GSPEC A (fun GEN_PVAR_1621 : A => exists y : A, @SETSPEC A GEN_PVAR_1621 ((@mdist A _759894 (@pair A A (@fst A R _759895) y)) = (@snd A R _759895)) y).
Lemma msphere_def {A : Type'} : (@msphere A) = (fun _759894 : Metric A => fun _759895 : prod A R => @GSPEC A (fun GEN_PVAR_1621 : A => exists y : A, @SETSPEC A GEN_PVAR_1621 ((@mdist A _759894 (@pair A A (@fst A R _759895) y)) = (@snd A R _759895)) y)).
Proof. exact (eq_refl (@msphere A)). Qed.
Definition mbounded {A : Type'} : (Metric A) -> (A -> Prop) -> Prop := fun _759959 : Metric A => fun _759960 : A -> Prop => exists c : A, exists b : R, @SUBSET A _759960 (@mcball A _759959 (@pair A R c b)).
Lemma mbounded_def {A : Type'} : (@mbounded A) = (fun _759959 : Metric A => fun _759960 : A -> Prop => exists c : A, exists b : R, @SUBSET A _759960 (@mcball A _759959 (@pair A R c b))).
Proof. exact (eq_refl (@mbounded A)). Qed.
Definition discrete_metric {_415081 : Type'} : (_415081 -> Prop) -> Metric _415081 := fun _760484 : _415081 -> Prop => @metric _415081 (@pair (_415081 -> Prop) ((prod _415081 _415081) -> R) _760484 (@GABS ((prod _415081 _415081) -> R) (fun f : (prod _415081 _415081) -> R => forall x : _415081, forall y : _415081, @GEQ R (f (@pair _415081 _415081 x y)) (@COND R (x = y) (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N))))))).
Lemma discrete_metric_def {_415081 : Type'} : (@discrete_metric _415081) = (fun _760484 : _415081 -> Prop => @metric _415081 (@pair (_415081 -> Prop) ((prod _415081 _415081) -> R) _760484 (@GABS ((prod _415081 _415081) -> R) (fun f : (prod _415081 _415081) -> R => forall x : _415081, forall y : _415081, @GEQ R (f (@pair _415081 _415081 x y)) (@COND R (x = y) (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))))))).
Proof. exact (eq_refl (@discrete_metric _415081)). Qed.
Definition metrizable_space {_415259 : Type'} : (Topology _415259) -> Prop := fun _760711 : Topology _415259 => exists m : Metric _415259, _760711 = (@mtopology _415259 m).
Lemma metrizable_space_def {_415259 : Type'} : (@metrizable_space _415259) = (fun _760711 : Topology _415259 => exists m : Metric _415259, _760711 = (@mtopology _415259 m)).
Proof. exact (eq_refl (@metrizable_space _415259)). Qed.
Definition connected_space {A : Type'} : (Topology A) -> Prop := fun _763672 : Topology A => ~ (exists e1 : A -> Prop, exists e2 : A -> Prop, (@open_in A _763672 e1) /\ ((@open_in A _763672 e2) /\ ((@SUBSET A (@topspace A _763672) (@UNION A e1 e2)) /\ (((@INTER A e1 e2) = (@EMPTY A)) /\ ((~ (e1 = (@EMPTY A))) /\ (~ (e2 = (@EMPTY A)))))))).
Lemma connected_space_def {A : Type'} : (@connected_space A) = (fun _763672 : Topology A => ~ (exists e1 : A -> Prop, exists e2 : A -> Prop, (@open_in A _763672 e1) /\ ((@open_in A _763672 e2) /\ ((@SUBSET A (@topspace A _763672) (@UNION A e1 e2)) /\ (((@INTER A e1 e2) = (@EMPTY A)) /\ ((~ (e1 = (@EMPTY A))) /\ (~ (e2 = (@EMPTY A))))))))).
Proof. exact (eq_refl (@connected_space A)). Qed.
Definition connected_in {_415952 : Type'} : (Topology _415952) -> (_415952 -> Prop) -> Prop := fun _763677 : Topology _415952 => fun _763678 : _415952 -> Prop => (@SUBSET _415952 _763678 (@topspace _415952 _763677)) /\ (@connected_space _415952 (@subtopology _415952 _763677 _763678)).
Lemma connected_in_def {_415952 : Type'} : (@connected_in _415952) = (fun _763677 : Topology _415952 => fun _763678 : _415952 -> Prop => (@SUBSET _415952 _763678 (@topspace _415952 _763677)) /\ (@connected_space _415952 (@subtopology _415952 _763677 _763678))).
Proof. exact (eq_refl (@connected_in _415952)). Qed.
Definition separated_between {A : Type'} : (Topology A) -> (A -> Prop) -> (A -> Prop) -> Prop := fun _776352 : Topology A => fun _776353 : A -> Prop => fun _776354 : A -> Prop => exists u : A -> Prop, exists v : A -> Prop, (@open_in A _776352 u) /\ ((@open_in A _776352 v) /\ (((@UNION A u v) = (@topspace A _776352)) /\ ((@DISJOINT A u v) /\ ((@SUBSET A _776353 u) /\ (@SUBSET A _776354 v))))).
Lemma separated_between_def {A : Type'} : (@separated_between A) = (fun _776352 : Topology A => fun _776353 : A -> Prop => fun _776354 : A -> Prop => exists u : A -> Prop, exists v : A -> Prop, (@open_in A _776352 u) /\ ((@open_in A _776352 v) /\ (((@UNION A u v) = (@topspace A _776352)) /\ ((@DISJOINT A u v) /\ ((@SUBSET A _776353 u) /\ (@SUBSET A _776354 v)))))).
Proof. exact (eq_refl (@separated_between A)). Qed.
Definition connected_component_of {_421324 : Type'} : (Topology _421324) -> _421324 -> _421324 -> Prop := fun _777792 : Topology _421324 => fun _777793 : _421324 => fun _777794 : _421324 => exists t : _421324 -> Prop, (@connected_in _421324 _777792 t) /\ ((@IN _421324 _777793 t) /\ (@IN _421324 _777794 t)).
Lemma connected_component_of_def {_421324 : Type'} : (@connected_component_of _421324) = (fun _777792 : Topology _421324 => fun _777793 : _421324 => fun _777794 : _421324 => exists t : _421324 -> Prop, (@connected_in _421324 _777792 t) /\ ((@IN _421324 _777793 t) /\ (@IN _421324 _777794 t))).
Proof. exact (eq_refl (@connected_component_of _421324)). Qed.
Definition connected_components_of {_421354 : Type'} : (Topology _421354) -> (_421354 -> Prop) -> Prop := fun _777813 : Topology _421354 => @GSPEC (_421354 -> Prop) (fun GEN_PVAR_1650 : _421354 -> Prop => exists x : _421354, @SETSPEC (_421354 -> Prop) GEN_PVAR_1650 (@IN _421354 x (@topspace _421354 _777813)) (@connected_component_of _421354 _777813 x)).
Lemma connected_components_of_def {_421354 : Type'} : (@connected_components_of _421354) = (fun _777813 : Topology _421354 => @GSPEC (_421354 -> Prop) (fun GEN_PVAR_1650 : _421354 -> Prop => exists x : _421354, @SETSPEC (_421354 -> Prop) GEN_PVAR_1650 (@IN _421354 x (@topspace _421354 _777813)) (@connected_component_of _421354 _777813 x))).
Proof. exact (eq_refl (@connected_components_of _421354)). Qed.
Definition monotone_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _789390 : prod (Topology A) (Topology B) => fun _789391 : A -> B => (@SUBSET B (@IMAGE A B _789391 (@topspace A (@fst (Topology A) (Topology B) _789390))) (@topspace B (@snd (Topology A) (Topology B) _789390))) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _789390))) -> @connected_in A (@fst (Topology A) (Topology B) _789390) (@GSPEC A (fun GEN_PVAR_1663 : A => exists x : A, @SETSPEC A GEN_PVAR_1663 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _789390))) /\ ((_789391 x) = y)) x))).
Lemma monotone_map_def {A B : Type'} : (@monotone_map A B) = (fun _789390 : prod (Topology A) (Topology B) => fun _789391 : A -> B => (@SUBSET B (@IMAGE A B _789391 (@topspace A (@fst (Topology A) (Topology B) _789390))) (@topspace B (@snd (Topology A) (Topology B) _789390))) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _789390))) -> @connected_in A (@fst (Topology A) (Topology B) _789390) (@GSPEC A (fun GEN_PVAR_1663 : A => exists x : A, @SETSPEC A GEN_PVAR_1663 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _789390))) /\ ((_789391 x) = y)) x)))).
Proof. exact (eq_refl (@monotone_map A B)). Qed.
Definition neighbourhood_base_at {A : Type'} : A -> ((A -> Prop) -> Prop) -> (Topology A) -> Prop := fun _794531 : A => fun _794532 : (A -> Prop) -> Prop => fun _794533 : Topology A => forall w : A -> Prop, ((@open_in A _794533 w) /\ (@IN A _794531 w)) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _794533 u) /\ ((_794532 v) /\ ((@IN A _794531 u) /\ ((@SUBSET A u v) /\ (@SUBSET A v w)))).
Lemma neighbourhood_base_at_def {A : Type'} : (@neighbourhood_base_at A) = (fun _794531 : A => fun _794532 : (A -> Prop) -> Prop => fun _794533 : Topology A => forall w : A -> Prop, ((@open_in A _794533 w) /\ (@IN A _794531 w)) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _794533 u) /\ ((_794532 v) /\ ((@IN A _794531 u) /\ ((@SUBSET A u v) /\ (@SUBSET A v w))))).
Proof. exact (eq_refl (@neighbourhood_base_at A)). Qed.
Definition neighbourhood_base_of {_425114 : Type'} : ((_425114 -> Prop) -> Prop) -> (Topology _425114) -> Prop := fun _794552 : (_425114 -> Prop) -> Prop => fun _794553 : Topology _425114 => forall x : _425114, (@IN _425114 x (@topspace _425114 _794553)) -> @neighbourhood_base_at _425114 x _794552 _794553.
Lemma neighbourhood_base_of_def {_425114 : Type'} : (@neighbourhood_base_of _425114) = (fun _794552 : (_425114 -> Prop) -> Prop => fun _794553 : Topology _425114 => forall x : _425114, (@IN _425114 x (@topspace _425114 _794553)) -> @neighbourhood_base_at _425114 x _794552 _794553).
Proof. exact (eq_refl (@neighbourhood_base_of _425114)). Qed.
Definition t0_space {A : Type'} : (Topology A) -> Prop := fun _794990 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _794990)) /\ ((@IN A y (@topspace A _794990)) /\ (~ (x = y)))) -> exists u : A -> Prop, (@open_in A _794990 u) /\ (~ ((@IN A x u) = (@IN A y u))).
Lemma t0_space_def {A : Type'} : (@t0_space A) = (fun _794990 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _794990)) /\ ((@IN A y (@topspace A _794990)) /\ (~ (x = y)))) -> exists u : A -> Prop, (@open_in A _794990 u) /\ (~ ((@IN A x u) = (@IN A y u)))).
Proof. exact (eq_refl (@t0_space A)). Qed.
Definition kolmogorov_quotient {A : Type'} : (Topology A) -> A -> A := fun _798901 : Topology A => fun x : A => @ε A (fun y : A => forall u : A -> Prop, (@open_in A _798901 u) -> (@IN A y u) = (@IN A x u)).
Lemma kolmogorov_quotient_def {A : Type'} : (@kolmogorov_quotient A) = (fun _798901 : Topology A => fun x : A => @ε A (fun y : A => forall u : A -> Prop, (@open_in A _798901 u) -> (@IN A y u) = (@IN A x u))).
Proof. exact (eq_refl (@kolmogorov_quotient A)). Qed.
Definition regular_space {A : Type'} : (Topology A) -> Prop := fun _800166 : Topology A => forall c : A -> Prop, forall a : A, ((@closed_in A _800166 c) /\ (@IN A a (@DIFF A (@topspace A _800166) c))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _800166 u) /\ ((@open_in A _800166 v) /\ ((@IN A a u) /\ ((@SUBSET A c v) /\ (@DISJOINT A u v)))).
Lemma regular_space_def {A : Type'} : (@regular_space A) = (fun _800166 : Topology A => forall c : A -> Prop, forall a : A, ((@closed_in A _800166 c) /\ (@IN A a (@DIFF A (@topspace A _800166) c))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _800166 u) /\ ((@open_in A _800166 v) /\ ((@IN A a u) /\ ((@SUBSET A c v) /\ (@DISJOINT A u v))))).
Proof. exact (eq_refl (@regular_space A)). Qed.
Definition locally_compact_space {_431393 : Type'} : (Topology _431393) -> Prop := fun _808310 : Topology _431393 => forall x : _431393, (@IN _431393 x (@topspace _431393 _808310)) -> exists u : _431393 -> Prop, exists k : _431393 -> Prop, (@open_in _431393 _808310 u) /\ ((@compact_in _431393 _808310 k) /\ ((@IN _431393 x u) /\ (@SUBSET _431393 u k))).
Lemma locally_compact_space_def {_431393 : Type'} : (@locally_compact_space _431393) = (fun _808310 : Topology _431393 => forall x : _431393, (@IN _431393 x (@topspace _431393 _808310)) -> exists u : _431393 -> Prop, exists k : _431393 -> Prop, (@open_in _431393 _808310 u) /\ ((@compact_in _431393 _808310 k) /\ ((@IN _431393 x u) /\ (@SUBSET _431393 u k)))).
Proof. exact (eq_refl (@locally_compact_space _431393)). Qed.
Definition real_open : (R -> Prop) -> Prop := fun _823569 : R -> Prop => forall x : R, (@IN R x _823569) -> exists e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) /\ (forall x' : R, (Rlt (Rabs (Rminus x' x)) e) -> @IN R x' _823569).
Lemma real_open_def : real_open = (fun _823569 : R -> Prop => forall x : R, (@IN R x _823569) -> exists e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) /\ (forall x' : R, (Rlt (Rabs (Rminus x' x)) e) -> @IN R x' _823569)).
Proof. exact (eq_refl real_open). Qed.
Definition real_closed : (R -> Prop) -> Prop := fun _823574 : R -> Prop => real_open (@DIFF R (@UNIV R) _823574).
Lemma real_closed_def : real_closed = (fun _823574 : R -> Prop => real_open (@DIFF R (@UNIV R) _823574)).
Proof. exact (eq_refl real_closed). Qed.
Definition euclideanreal : Topology R := @topology R real_open.
Lemma euclideanreal_def : euclideanreal = (@topology R real_open).
Proof. exact (eq_refl euclideanreal). Qed.
Definition real_euclidean_metric : Metric R := @metric R (@pair (R -> Prop) ((prod R R) -> R) (@UNIV R) (@GABS ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @GEQ R (f (@pair R R x y)) (Rabs (Rminus y x))))).
Lemma real_euclidean_metric_def : real_euclidean_metric = (@metric R (@pair (R -> Prop) ((prod R R) -> R) (@UNIV R) (@GABS ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @GEQ R (f (@pair R R x y)) (Rabs (Rminus y x)))))).
Proof. exact (eq_refl real_euclidean_metric). Qed.
Definition real_bounded : (R -> Prop) -> Prop := fun _824092 : R -> Prop => exists B : R, forall x : R, (@IN R x _824092) -> Rle (Rabs x) B.
Lemma real_bounded_def : real_bounded = (fun _824092 : R -> Prop => exists B : R, forall x : R, (@IN R x _824092) -> Rle (Rabs x) B).
Proof. exact (eq_refl real_bounded). Qed.
Definition real_compact : (R -> Prop) -> Prop := fun _825374 : R -> Prop => @compact_in R euclideanreal _825374.
Lemma real_compact_def : real_compact = (fun _825374 : R -> Prop => @compact_in R euclideanreal _825374).
Proof. exact (eq_refl real_compact). Qed.
Definition atpointof {_438043 : Type'} : (Topology _438043) -> _438043 -> net _438043 := fun _826262 : Topology _438043 => fun _826263 : _438043 => @mk_net _438043 (@pair ((_438043 -> Prop) -> Prop) (_438043 -> Prop) (@GSPEC (_438043 -> Prop) (fun GEN_PVAR_1781 : _438043 -> Prop => exists u : _438043 -> Prop, @SETSPEC (_438043 -> Prop) GEN_PVAR_1781 ((@open_in _438043 _826262 u) /\ (@IN _438043 _826263 u)) u)) (@INSERT _438043 _826263 (@EMPTY _438043))).
Lemma atpointof_def {_438043 : Type'} : (@atpointof _438043) = (fun _826262 : Topology _438043 => fun _826263 : _438043 => @mk_net _438043 (@pair ((_438043 -> Prop) -> Prop) (_438043 -> Prop) (@GSPEC (_438043 -> Prop) (fun GEN_PVAR_1781 : _438043 -> Prop => exists u : _438043 -> Prop, @SETSPEC (_438043 -> Prop) GEN_PVAR_1781 ((@open_in _438043 _826262 u) /\ (@IN _438043 _826263 u)) u)) (@INSERT _438043 _826263 (@EMPTY _438043)))).
Proof. exact (eq_refl (@atpointof _438043)). Qed.
Definition limit {A B : Type'} : (Topology B) -> (A -> B) -> B -> (net A) -> Prop := fun _826602 : Topology B => fun _826603 : A -> B => fun _826604 : B => fun _826605 : net A => (@IN B _826604 (@topspace B _826602)) /\ (forall u : B -> Prop, ((@open_in B _826602 u) /\ (@IN B _826604 u)) -> @eventually A (fun x : A => @IN B (_826603 x) u) _826605).
Lemma limit_def {A B : Type'} : (@limit A B) = (fun _826602 : Topology B => fun _826603 : A -> B => fun _826604 : B => fun _826605 : net A => (@IN B _826604 (@topspace B _826602)) /\ (forall u : B -> Prop, ((@open_in B _826602 u) /\ (@IN B _826604 u)) -> @eventually A (fun x : A => @IN B (_826603 x) u) _826605)).
Proof. exact (eq_refl (@limit A B)). Qed.
Definition cauchy_in {A : Type'} : (Metric A) -> (N -> A) -> Prop := fun _830072 : Metric A => fun _830073 : N -> A => (forall n : N, @IN A (_830073 n) (@mspace A _830072)) /\ (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists N' : N, forall n : N, forall n' : N, ((N.le N' n) /\ (N.le N' n')) -> Rlt (@mdist A _830072 (@pair A A (_830073 n) (_830073 n'))) e).
Lemma cauchy_in_def {A : Type'} : (@cauchy_in A) = (fun _830072 : Metric A => fun _830073 : N -> A => (forall n : N, @IN A (_830073 n) (@mspace A _830072)) /\ (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists N' : N, forall n : N, forall n' : N, ((N.le N' n) /\ (N.le N' n')) -> Rlt (@mdist A _830072 (@pair A A (_830073 n) (_830073 n'))) e)).
Proof. exact (eq_refl (@cauchy_in A)). Qed.
Definition mcomplete {A : Type'} : (Metric A) -> Prop := fun _830084 : Metric A => forall s : N -> A, (@cauchy_in A _830084 s) -> exists x : A, @limit N A (@mtopology A _830084) s x sequentially.
Lemma mcomplete_def {A : Type'} : (@mcomplete A) = (fun _830084 : Metric A => forall s : N -> A, (@cauchy_in A _830084 s) -> exists x : A, @limit N A (@mtopology A _830084) s x sequentially).
Proof. exact (eq_refl (@mcomplete A)). Qed.
Definition totally_bounded_in {A : Type'} : (Metric A) -> (A -> Prop) -> Prop := fun _834558 : Metric A => fun _834559 : A -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists k : A -> Prop, (@FINITE A k) /\ ((@SUBSET A k _834559) /\ (@SUBSET A _834559 (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_1814 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_1814 (@IN A x k) (@mball A _834558 (@pair A R x e))))))).
Lemma totally_bounded_in_def {A : Type'} : (@totally_bounded_in A) = (fun _834558 : Metric A => fun _834559 : A -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists k : A -> Prop, (@FINITE A k) /\ ((@SUBSET A k _834559) /\ (@SUBSET A _834559 (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_1814 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_1814 (@IN A x k) (@mball A _834558 (@pair A R x e)))))))).
Proof. exact (eq_refl (@totally_bounded_in A)). Qed.
Definition topcontinuous_at {A B : Type'} : (Topology A) -> (Topology B) -> (A -> B) -> A -> Prop := fun _837763 : Topology A => fun _837764 : Topology B => fun _837765 : A -> B => fun _837766 : A => (@IN A _837766 (@topspace A _837763)) /\ ((forall x : A, (@IN A x (@topspace A _837763)) -> @IN B (_837765 x) (@topspace B _837764)) /\ (forall v : B -> Prop, ((@open_in B _837764 v) /\ (@IN B (_837765 _837766) v)) -> exists u : A -> Prop, (@open_in A _837763 u) /\ ((@IN A _837766 u) /\ (forall y : A, (@IN A y u) -> @IN B (_837765 y) v)))).
Lemma topcontinuous_at_def {A B : Type'} : (@topcontinuous_at A B) = (fun _837763 : Topology A => fun _837764 : Topology B => fun _837765 : A -> B => fun _837766 : A => (@IN A _837766 (@topspace A _837763)) /\ ((forall x : A, (@IN A x (@topspace A _837763)) -> @IN B (_837765 x) (@topspace B _837764)) /\ (forall v : B -> Prop, ((@open_in B _837764 v) /\ (@IN B (_837765 _837766) v)) -> exists u : A -> Prop, (@open_in A _837763 u) /\ ((@IN A _837766 u) /\ (forall y : A, (@IN A y u) -> @IN B (_837765 y) v))))).
Proof. exact (eq_refl (@topcontinuous_at A B)). Qed.
Definition path_in {A : Type'} : (Topology A) -> (R -> A) -> Prop := fun _838908 : Topology A => fun _838909 : R -> A => @continuous_map R A (@pair (Topology R) (Topology A) (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R))))) _838908) _838909.
Lemma path_in_def {A : Type'} : (@path_in A) = (fun _838908 : Topology A => fun _838909 : R -> A => @continuous_map R A (@pair (Topology R) (Topology A) (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R))))) _838908) _838909).
Proof. exact (eq_refl (@path_in A)). Qed.
Definition path_connected_space {A : Type'} : (Topology A) -> Prop := fun _839336 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _839336)) /\ (@IN A y (@topspace A _839336))) -> exists g : R -> A, (@path_in A _839336 g) /\ (((g (R_of_N (NUMERAL 0%N))) = x) /\ ((g (R_of_N (NUMERAL (BIT1 0%N)))) = y)).
Lemma path_connected_space_def {A : Type'} : (@path_connected_space A) = (fun _839336 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _839336)) /\ (@IN A y (@topspace A _839336))) -> exists g : R -> A, (@path_in A _839336 g) /\ (((g (R_of_N (NUMERAL 0%N))) = x) /\ ((g (R_of_N (NUMERAL (BIT1 0%N)))) = y))).
Proof. exact (eq_refl (@path_connected_space A)). Qed.
Definition path_connected_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _839341 : Topology A => fun _839342 : A -> Prop => (@SUBSET A _839342 (@topspace A _839341)) /\ (@path_connected_space A (@subtopology A _839341 _839342)).
Lemma path_connected_in_def {A : Type'} : (@path_connected_in A) = (fun _839341 : Topology A => fun _839342 : A -> Prop => (@SUBSET A _839342 (@topspace A _839341)) /\ (@path_connected_space A (@subtopology A _839341 _839342))).
Proof. exact (eq_refl (@path_connected_in A)). Qed.
Definition path_component_of {_457543 : Type'} : (Topology _457543) -> _457543 -> _457543 -> Prop := fun _841254 : Topology _457543 => fun _841255 : _457543 => fun _841256 : _457543 => exists g : R -> _457543, (@path_in _457543 _841254 g) /\ (((g (R_of_N (NUMERAL 0%N))) = _841255) /\ ((g (R_of_N (NUMERAL (BIT1 0%N)))) = _841256)).
Lemma path_component_of_def {_457543 : Type'} : (@path_component_of _457543) = (fun _841254 : Topology _457543 => fun _841255 : _457543 => fun _841256 : _457543 => exists g : R -> _457543, (@path_in _457543 _841254 g) /\ (((g (R_of_N (NUMERAL 0%N))) = _841255) /\ ((g (R_of_N (NUMERAL (BIT1 0%N)))) = _841256))).
Proof. exact (eq_refl (@path_component_of _457543)). Qed.
Definition path_components_of {_457570 : Type'} : (Topology _457570) -> (_457570 -> Prop) -> Prop := fun _841275 : Topology _457570 => @GSPEC (_457570 -> Prop) (fun GEN_PVAR_1874 : _457570 -> Prop => exists x : _457570, @SETSPEC (_457570 -> Prop) GEN_PVAR_1874 (@IN _457570 x (@topspace _457570 _841275)) (@path_component_of _457570 _841275 x)).
Lemma path_components_of_def {_457570 : Type'} : (@path_components_of _457570) = (fun _841275 : Topology _457570 => @GSPEC (_457570 -> Prop) (fun GEN_PVAR_1874 : _457570 -> Prop => exists x : _457570, @SETSPEC (_457570 -> Prop) GEN_PVAR_1874 (@IN _457570 x (@topspace _457570 _841275)) (@path_component_of _457570 _841275 x))).
Proof. exact (eq_refl (@path_components_of _457570)). Qed.
Definition normal_space {A : Type'} : (Topology A) -> Prop := fun _853160 : Topology A => forall s : A -> Prop, forall t : A -> Prop, ((@closed_in A _853160 s) /\ ((@closed_in A _853160 t) /\ (@DISJOINT A s t))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _853160 u) /\ ((@open_in A _853160 v) /\ ((@SUBSET A s u) /\ ((@SUBSET A t v) /\ (@DISJOINT A u v)))).
Lemma normal_space_def {A : Type'} : (@normal_space A) = (fun _853160 : Topology A => forall s : A -> Prop, forall t : A -> Prop, ((@closed_in A _853160 s) /\ ((@closed_in A _853160 t) /\ (@DISJOINT A s t))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _853160 u) /\ ((@open_in A _853160 v) /\ ((@SUBSET A s u) /\ ((@SUBSET A t v) /\ (@DISJOINT A u v))))).
Proof. exact (eq_refl (@normal_space A)). Qed.
Definition completely_regular_space {A : Type'} : (Topology A) -> Prop := fun _869042 : Topology A => forall s : A -> Prop, forall x : A, ((@closed_in A _869042 s) /\ (@IN A x (@DIFF A (@topspace A _869042) s))) -> exists f : A -> R, (@continuous_map A R (@pair (Topology A) (Topology R) _869042 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R)))))) f) /\ (((f x) = (R_of_N (NUMERAL 0%N))) /\ (forall x' : A, (@IN A x' s) -> (f x') = (R_of_N (NUMERAL (BIT1 0%N))))).
Lemma completely_regular_space_def {A : Type'} : (@completely_regular_space A) = (fun _869042 : Topology A => forall s : A -> Prop, forall x : A, ((@closed_in A _869042 s) /\ (@IN A x (@DIFF A (@topspace A _869042) s))) -> exists f : A -> R, (@continuous_map A R (@pair (Topology A) (Topology R) _869042 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R)))))) f) /\ (((f x) = (R_of_N (NUMERAL 0%N))) /\ (forall x' : A, (@IN A x' s) -> (f x') = (R_of_N (NUMERAL (BIT1 0%N)))))).
Proof. exact (eq_refl (@completely_regular_space A)). Qed.
Definition weakly_locally_path_connected_at {_470946 : Type'} : _470946 -> (Topology _470946) -> Prop := fun _872685 : _470946 => fun _872686 : Topology _470946 => @neighbourhood_base_at _470946 _872685 (@path_connected_in _470946 _872686) _872686.
Lemma weakly_locally_path_connected_at_def {_470946 : Type'} : (@weakly_locally_path_connected_at _470946) = (fun _872685 : _470946 => fun _872686 : Topology _470946 => @neighbourhood_base_at _470946 _872685 (@path_connected_in _470946 _872686) _872686).
Proof. exact (eq_refl (@weakly_locally_path_connected_at _470946)). Qed.
Definition locally_path_connected_at {_470954 : Type'} : _470954 -> (Topology _470954) -> Prop := fun _872697 : _470954 => fun _872698 : Topology _470954 => @neighbourhood_base_at _470954 _872697 (fun u : _470954 -> Prop => (@open_in _470954 _872698 u) /\ (@path_connected_in _470954 _872698 u)) _872698.
Lemma locally_path_connected_at_def {_470954 : Type'} : (@locally_path_connected_at _470954) = (fun _872697 : _470954 => fun _872698 : Topology _470954 => @neighbourhood_base_at _470954 _872697 (fun u : _470954 -> Prop => (@open_in _470954 _872698 u) /\ (@path_connected_in _470954 _872698 u)) _872698).
Proof. exact (eq_refl (@locally_path_connected_at _470954)). Qed.
Definition locally_path_connected_space {_470974 : Type'} : (Topology _470974) -> Prop := fun _872709 : Topology _470974 => @neighbourhood_base_of _470974 (@path_connected_in _470974 _872709) _872709.
Lemma locally_path_connected_space_def {_470974 : Type'} : (@locally_path_connected_space _470974) = (fun _872709 : Topology _470974 => @neighbourhood_base_of _470974 (@path_connected_in _470974 _872709) _872709).
Proof. exact (eq_refl (@locally_path_connected_space _470974)). Qed.
Definition weakly_locally_connected_at {_472699 : Type'} : _472699 -> (Topology _472699) -> Prop := fun _874154 : _472699 => fun _874155 : Topology _472699 => @neighbourhood_base_at _472699 _874154 (@connected_in _472699 _874155) _874155.
Lemma weakly_locally_connected_at_def {_472699 : Type'} : (@weakly_locally_connected_at _472699) = (fun _874154 : _472699 => fun _874155 : Topology _472699 => @neighbourhood_base_at _472699 _874154 (@connected_in _472699 _874155) _874155).
Proof. exact (eq_refl (@weakly_locally_connected_at _472699)). Qed.
Definition locally_connected_at {_472707 : Type'} : _472707 -> (Topology _472707) -> Prop := fun _874166 : _472707 => fun _874167 : Topology _472707 => @neighbourhood_base_at _472707 _874166 (fun u : _472707 -> Prop => (@open_in _472707 _874167 u) /\ (@connected_in _472707 _874167 u)) _874167.
Lemma locally_connected_at_def {_472707 : Type'} : (@locally_connected_at _472707) = (fun _874166 : _472707 => fun _874167 : Topology _472707 => @neighbourhood_base_at _472707 _874166 (fun u : _472707 -> Prop => (@open_in _472707 _874167 u) /\ (@connected_in _472707 _874167 u)) _874167).
Proof. exact (eq_refl (@locally_connected_at _472707)). Qed.
Definition locally_connected_space {_472727 : Type'} : (Topology _472727) -> Prop := fun _874178 : Topology _472727 => @neighbourhood_base_of _472727 (@connected_in _472727 _874178) _874178.
Lemma locally_connected_space_def {_472727 : Type'} : (@locally_connected_space _472727) = (fun _874178 : Topology _472727 => @neighbourhood_base_of _472727 (@connected_in _472727 _874178) _874178).
Proof. exact (eq_refl (@locally_connected_space _472727)). Qed.
Definition quasi_component_of {_474420 : Type'} : (Topology _474420) -> _474420 -> _474420 -> Prop := fun _875566 : Topology _474420 => fun _875567 : _474420 => fun _875568 : _474420 => (@IN _474420 _875567 (@topspace _474420 _875566)) /\ ((@IN _474420 _875568 (@topspace _474420 _875566)) /\ (forall t : _474420 -> Prop, ((@closed_in _474420 _875566 t) /\ (@open_in _474420 _875566 t)) -> (@IN _474420 _875567 t) = (@IN _474420 _875568 t))).
Lemma quasi_component_of_def {_474420 : Type'} : (@quasi_component_of _474420) = (fun _875566 : Topology _474420 => fun _875567 : _474420 => fun _875568 : _474420 => (@IN _474420 _875567 (@topspace _474420 _875566)) /\ ((@IN _474420 _875568 (@topspace _474420 _875566)) /\ (forall t : _474420 -> Prop, ((@closed_in _474420 _875566 t) /\ (@open_in _474420 _875566 t)) -> (@IN _474420 _875567 t) = (@IN _474420 _875568 t)))).
Proof. exact (eq_refl (@quasi_component_of _474420)). Qed.
Definition quasi_components_of {_474443 : Type'} : (Topology _474443) -> (_474443 -> Prop) -> Prop := fun _875587 : Topology _474443 => @GSPEC (_474443 -> Prop) (fun GEN_PVAR_1974 : _474443 -> Prop => exists x : _474443, @SETSPEC (_474443 -> Prop) GEN_PVAR_1974 (@IN _474443 x (@topspace _474443 _875587)) (@quasi_component_of _474443 _875587 x)).
Lemma quasi_components_of_def {_474443 : Type'} : (@quasi_components_of _474443) = (fun _875587 : Topology _474443 => @GSPEC (_474443 -> Prop) (fun GEN_PVAR_1974 : _474443 -> Prop => exists x : _474443, @SETSPEC (_474443 -> Prop) GEN_PVAR_1974 (@IN _474443 x (@topspace _474443 _875587)) (@quasi_component_of _474443 _875587 x))).
Proof. exact (eq_refl (@quasi_components_of _474443)). Qed.
Definition k_space {A : Type'} : (Topology A) -> Prop := fun _879736 : Topology A => forall s : A -> Prop, (@SUBSET A s (@topspace A _879736)) -> (@closed_in A _879736 s) = (forall k : A -> Prop, (@compact_in A _879736 k) -> @closed_in A (@subtopology A _879736 k) (@INTER A k s)).
Lemma k_space_def {A : Type'} : (@k_space A) = (fun _879736 : Topology A => forall s : A -> Prop, (@SUBSET A s (@topspace A _879736)) -> (@closed_in A _879736 s) = (forall k : A -> Prop, (@compact_in A _879736 k) -> @closed_in A (@subtopology A _879736 k) (@INTER A k s))).
Proof. exact (eq_refl (@k_space A)). Qed.
Definition kification {A : Type'} : (Topology A) -> Topology A := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Topology A) -> Topology A) (fun kification' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Topology A) -> Topology A => forall _883057 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))), forall top : Topology A, (kification' _883057 top) = (@topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_2014 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_2014 ((@SUBSET A s (@topspace A top)) /\ (forall k : A -> Prop, (@compact_in A top k) -> @open_in A (@subtopology A top k) (@INTER A k s))) s)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))).
Lemma kification_def {A : Type'} : (@kification A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Topology A) -> Topology A) (fun kification' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (Topology A) -> Topology A => forall _883057 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))), forall top : Topology A, (kification' _883057 top) = (@topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_2014 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_2014 ((@SUBSET A s (@topspace A top)) /\ (forall k : A -> Prop, (@compact_in A top k) -> @open_in A (@subtopology A top k) (@INTER A k s))) s)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))).
Proof. exact (eq_refl (@kification A)). Qed.
Definition alexandroff_compactification {A : Type'} : (Topology A) -> Topology (Datatypes.sum A unit) := fun _884542 : Topology A => @topology (Datatypes.sum A unit) (@UNION ((Datatypes.sum A unit) -> Prop) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2016 : (Datatypes.sum A unit) -> Prop => exists u : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2016 (@open_in A _884542 u) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) u))) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2017 : (Datatypes.sum A unit) -> Prop => exists c : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2017 ((@compact_in A _884542 c) /\ (@closed_in A _884542 c)) (@INSERT (Datatypes.sum A unit) (@inr A unit tt) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) (@DIFF A (@topspace A _884542) c)))))).
Lemma alexandroff_compactification_def {A : Type'} : (@alexandroff_compactification A) = (fun _884542 : Topology A => @topology (Datatypes.sum A unit) (@UNION ((Datatypes.sum A unit) -> Prop) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2016 : (Datatypes.sum A unit) -> Prop => exists u : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2016 (@open_in A _884542 u) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) u))) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2017 : (Datatypes.sum A unit) -> Prop => exists c : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2017 ((@compact_in A _884542 c) /\ (@closed_in A _884542 c)) (@INSERT (Datatypes.sum A unit) (@inr A unit tt) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) (@DIFF A (@topspace A _884542) c))))))).
Proof. exact (eq_refl (@alexandroff_compactification A)). Qed.
Definition homotopic_with {_485959 _485962 : Type'} : ((_485962 -> _485959) -> Prop) -> (prod (Topology _485962) (Topology _485959)) -> (_485962 -> _485959) -> (_485962 -> _485959) -> Prop := fun _894008 : (_485962 -> _485959) -> Prop => fun _894009 : prod (Topology _485962) (Topology _485959) => fun _894010 : _485962 -> _485959 => fun _894011 : _485962 -> _485959 => exists h : (prod R _485962) -> _485959, (@continuous_map (prod R _485962) _485959 (@pair (Topology (prod R _485962)) (Topology _485959) (@prod_topology R _485962 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R))))) (@fst (Topology _485962) (Topology _485959) _894009)) (@snd (Topology _485962) (Topology _485959) _894009)) h) /\ ((forall x : _485962, (h (@pair R _485962 (R_of_N (NUMERAL 0%N)) x)) = (_894010 x)) /\ ((forall x : _485962, (h (@pair R _485962 (R_of_N (NUMERAL (BIT1 0%N))) x)) = (_894011 x)) /\ (forall t : R, (@IN R t (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R))))) -> _894008 (fun x : _485962 => h (@pair R _485962 t x))))).
Lemma homotopic_with_def {_485959 _485962 : Type'} : (@homotopic_with _485959 _485962) = (fun _894008 : (_485962 -> _485959) -> Prop => fun _894009 : prod (Topology _485962) (Topology _485959) => fun _894010 : _485962 -> _485959 => fun _894011 : _485962 -> _485959 => exists h : (prod R _485962) -> _485959, (@continuous_map (prod R _485962) _485959 (@pair (Topology (prod R _485962)) (Topology _485959) (@prod_topology R _485962 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R))))) (@fst (Topology _485962) (Topology _485959) _894009)) (@snd (Topology _485962) (Topology _485959) _894009)) h) /\ ((forall x : _485962, (h (@pair R _485962 (R_of_N (NUMERAL 0%N)) x)) = (_894010 x)) /\ ((forall x : _485962, (h (@pair R _485962 (R_of_N (NUMERAL (BIT1 0%N))) x)) = (_894011 x)) /\ (forall t : R, (@IN R t (closed_real_interval (@cons (prod R R) (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))) (@nil (prod R R))))) -> _894008 (fun x : _485962 => h (@pair R _485962 t x)))))).
Proof. exact (eq_refl (@homotopic_with _485959 _485962)). Qed.
Definition homotopy_equivalent_space {A B : Type'} : (Topology A) -> (Topology B) -> Prop := fun _894877 : Topology A => fun _894878 : Topology B => exists f : A -> B, exists g : B -> A, (@continuous_map A B (@pair (Topology A) (Topology B) _894877 _894878) f) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) _894878 _894877) g) /\ ((@homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _894877 _894877) (@o A B A g f) (@I A)) /\ (@homotopic_with B B (fun x : B -> B => True) (@pair (Topology B) (Topology B) _894878 _894878) (@o B A B f g) (@I B)))).
Lemma homotopy_equivalent_space_def {A B : Type'} : (@homotopy_equivalent_space A B) = (fun _894877 : Topology A => fun _894878 : Topology B => exists f : A -> B, exists g : B -> A, (@continuous_map A B (@pair (Topology A) (Topology B) _894877 _894878) f) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) _894878 _894877) g) /\ ((@homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _894877 _894877) (@o A B A g f) (@I A)) /\ (@homotopic_with B B (fun x : B -> B => True) (@pair (Topology B) (Topology B) _894878 _894878) (@o B A B f g) (@I B))))).
Proof. exact (eq_refl (@homotopy_equivalent_space A B)). Qed.
Definition contractible_space {A : Type'} : (Topology A) -> Prop := fun _895625 : Topology A => exists a : A, @homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _895625 _895625) (fun x : A => x) (fun x : A => a).
Lemma contractible_space_def {A : Type'} : (@contractible_space A) = (fun _895625 : Topology A => exists a : A, @homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _895625 _895625) (fun x : A => x) (fun x : A => a)).
Proof. exact (eq_refl (@contractible_space A)). Qed.
Definition completely_metrizable_space {_489462 : Type'} : (Topology _489462) -> Prop := fun _896837 : Topology _489462 => exists m : Metric _489462, (@mcomplete _489462 m) /\ (_896837 = (@mtopology _489462 m)).
Lemma completely_metrizable_space_def {_489462 : Type'} : (@completely_metrizable_space _489462) = (fun _896837 : Topology _489462 => exists m : Metric _489462, (@mcomplete _489462 m) /\ (_896837 = (@mtopology _489462 m))).
Proof. exact (eq_refl (@completely_metrizable_space _489462)). Qed.
Definition prod_metric {A B : Type'} : (Metric A) -> (Metric B) -> Metric (prod A B) := fun _900571 : Metric A => fun _900572 : Metric B => @metric (prod A B) (@pair ((prod A B) -> Prop) ((prod (prod A B) (prod A B)) -> R) (@CROSS A B (@mspace A _900571) (@mspace B _900572)) (@GABS ((prod (prod A B) (prod A B)) -> R) (fun f : (prod (prod A B) (prod A B)) -> R => forall x : A, forall y : B, forall x' : A, forall y' : B, @GEQ R (f (@pair (prod A B) (prod A B) (@pair A B x y) (@pair A B x' y'))) (sqrt (Rplus (Rpow (@mdist A _900571 (@pair A A x x')) (NUMERAL (BIT0 (BIT1 0%N)))) (Rpow (@mdist B _900572 (@pair B B y y')) (NUMERAL (BIT0 (BIT1 0%N))))))))).
Lemma prod_metric_def {A B : Type'} : (@prod_metric A B) = (fun _900571 : Metric A => fun _900572 : Metric B => @metric (prod A B) (@pair ((prod A B) -> Prop) ((prod (prod A B) (prod A B)) -> R) (@CROSS A B (@mspace A _900571) (@mspace B _900572)) (@GABS ((prod (prod A B) (prod A B)) -> R) (fun f : (prod (prod A B) (prod A B)) -> R => forall x : A, forall y : B, forall x' : A, forall y' : B, @GEQ R (f (@pair (prod A B) (prod A B) (@pair A B x y) (@pair A B x' y'))) (sqrt (Rplus (Rpow (@mdist A _900571 (@pair A A x x')) (NUMERAL (BIT0 (BIT1 0%N)))) (Rpow (@mdist B _900572 (@pair B B y y')) (NUMERAL (BIT0 (BIT1 0%N)))))))))).
Proof. exact (eq_refl (@prod_metric A B)). Qed.
Definition lipschitz_continuous_map {_491946 _491958 : Type'} : (prod (Metric _491958) (Metric _491946)) -> (_491958 -> _491946) -> Prop := fun _904328 : prod (Metric _491958) (Metric _491946) => fun _904329 : _491958 -> _491946 => (@SUBSET _491946 (@IMAGE _491958 _491946 _904329 (@mspace _491958 (@fst (Metric _491958) (Metric _491946) _904328))) (@mspace _491946 (@snd (Metric _491958) (Metric _491946) _904328))) /\ (exists B : R, forall x : _491958, forall y : _491958, ((@IN _491958 x (@mspace _491958 (@fst (Metric _491958) (Metric _491946) _904328))) /\ (@IN _491958 y (@mspace _491958 (@fst (Metric _491958) (Metric _491946) _904328)))) -> Rle (@mdist _491946 (@snd (Metric _491958) (Metric _491946) _904328) (@pair _491946 _491946 (_904329 x) (_904329 y))) (Rmult B (@mdist _491958 (@fst (Metric _491958) (Metric _491946) _904328) (@pair _491958 _491958 x y)))).
Lemma lipschitz_continuous_map_def {_491946 _491958 : Type'} : (@lipschitz_continuous_map _491946 _491958) = (fun _904328 : prod (Metric _491958) (Metric _491946) => fun _904329 : _491958 -> _491946 => (@SUBSET _491946 (@IMAGE _491958 _491946 _904329 (@mspace _491958 (@fst (Metric _491958) (Metric _491946) _904328))) (@mspace _491946 (@snd (Metric _491958) (Metric _491946) _904328))) /\ (exists B : R, forall x : _491958, forall y : _491958, ((@IN _491958 x (@mspace _491958 (@fst (Metric _491958) (Metric _491946) _904328))) /\ (@IN _491958 y (@mspace _491958 (@fst (Metric _491958) (Metric _491946) _904328)))) -> Rle (@mdist _491946 (@snd (Metric _491958) (Metric _491946) _904328) (@pair _491946 _491946 (_904329 x) (_904329 y))) (Rmult B (@mdist _491958 (@fst (Metric _491958) (Metric _491946) _904328) (@pair _491958 _491958 x y))))).
Proof. exact (eq_refl (@lipschitz_continuous_map _491946 _491958)). Qed.
Definition uniformly_continuous_map {_492508 _492513 : Type'} : (prod (Metric _492513) (Metric _492508)) -> (_492513 -> _492508) -> Prop := fun _904856 : prod (Metric _492513) (Metric _492508) => fun _904857 : _492513 -> _492508 => (@SUBSET _492508 (@IMAGE _492513 _492508 _904857 (@mspace _492513 (@fst (Metric _492513) (Metric _492508) _904856))) (@mspace _492508 (@snd (Metric _492513) (Metric _492508) _904856))) /\ (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x : _492513, forall x' : _492513, ((@IN _492513 x (@mspace _492513 (@fst (Metric _492513) (Metric _492508) _904856))) /\ ((@IN _492513 x' (@mspace _492513 (@fst (Metric _492513) (Metric _492508) _904856))) /\ (Rlt (@mdist _492513 (@fst (Metric _492513) (Metric _492508) _904856) (@pair _492513 _492513 x' x)) d))) -> Rlt (@mdist _492508 (@snd (Metric _492513) (Metric _492508) _904856) (@pair _492508 _492508 (_904857 x') (_904857 x))) e)).
Lemma uniformly_continuous_map_def {_492508 _492513 : Type'} : (@uniformly_continuous_map _492508 _492513) = (fun _904856 : prod (Metric _492513) (Metric _492508) => fun _904857 : _492513 -> _492508 => (@SUBSET _492508 (@IMAGE _492513 _492508 _904857 (@mspace _492513 (@fst (Metric _492513) (Metric _492508) _904856))) (@mspace _492508 (@snd (Metric _492513) (Metric _492508) _904856))) /\ (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x : _492513, forall x' : _492513, ((@IN _492513 x (@mspace _492513 (@fst (Metric _492513) (Metric _492508) _904856))) /\ ((@IN _492513 x' (@mspace _492513 (@fst (Metric _492513) (Metric _492508) _904856))) /\ (Rlt (@mdist _492513 (@fst (Metric _492513) (Metric _492508) _904856) (@pair _492513 _492513 x' x)) d))) -> Rlt (@mdist _492508 (@snd (Metric _492513) (Metric _492508) _904856) (@pair _492508 _492508 (_904857 x') (_904857 x))) e))).
Proof. exact (eq_refl (@uniformly_continuous_map _492508 _492513)). Qed.
Definition cauchy_continuous_map {_493261 _493269 : Type'} : (prod (Metric _493261) (Metric _493269)) -> (_493261 -> _493269) -> Prop := fun _905551 : prod (Metric _493261) (Metric _493269) => fun _905552 : _493261 -> _493269 => forall x : N -> _493261, (@cauchy_in _493261 (@fst (Metric _493261) (Metric _493269) _905551) x) -> @cauchy_in _493269 (@snd (Metric _493261) (Metric _493269) _905551) (@o N _493261 _493269 _905552 x).
Lemma cauchy_continuous_map_def {_493261 _493269 : Type'} : (@cauchy_continuous_map _493261 _493269) = (fun _905551 : prod (Metric _493261) (Metric _493269) => fun _905552 : _493261 -> _493269 => forall x : N -> _493261, (@cauchy_in _493261 (@fst (Metric _493261) (Metric _493269) _905551) x) -> @cauchy_in _493269 (@snd (Metric _493261) (Metric _493269) _905551) (@o N _493261 _493269 _905552 x)).
Proof. exact (eq_refl (@cauchy_continuous_map _493261 _493269)). Qed.
Definition capped_metric {A : Type'} : R -> (Metric A) -> Metric A := fun _912035 : R => fun _912036 : Metric A => @COND (Metric A) (Rle _912035 (R_of_N (NUMERAL 0%N))) _912036 (@metric A (@pair (A -> Prop) ((prod A A) -> R) (@mspace A _912036) (@GABS ((prod A A) -> R) (fun f : (prod A A) -> R => forall x : A, forall y : A, @GEQ R (f (@pair A A x y)) (Rmin _912035 (@mdist A _912036 (@pair A A x y))))))).
Lemma capped_metric_def {A : Type'} : (@capped_metric A) = (fun _912035 : R => fun _912036 : Metric A => @COND (Metric A) (Rle _912035 (R_of_N (NUMERAL 0%N))) _912036 (@metric A (@pair (A -> Prop) ((prod A A) -> R) (@mspace A _912036) (@GABS ((prod A A) -> R) (fun f : (prod A A) -> R => forall x : A, forall y : A, @GEQ R (f (@pair A A x y)) (Rmin _912035 (@mdist A _912036 (@pair A A x y)))))))).
Proof. exact (eq_refl (@capped_metric A)). Qed.
Definition euclidean_space : N -> Topology (N -> R) := fun _933703 : N => @subtopology (N -> R) (@product_topology R N (@UNIV N) (fun i : N => euclideanreal)) (@GSPEC (N -> R) (fun GEN_PVAR_2056 : N -> R => exists x : N -> R, @SETSPEC (N -> R) GEN_PVAR_2056 (forall i : N, (~ (@IN N i (dotdot (NUMERAL (BIT1 0%N)) _933703))) -> (x i) = (R_of_N (NUMERAL 0%N))) x)).
Lemma euclidean_space_def : euclidean_space = (fun _933703 : N => @subtopology (N -> R) (@product_topology R N (@UNIV N) (fun i : N => euclideanreal)) (@GSPEC (N -> R) (fun GEN_PVAR_2056 : N -> R => exists x : N -> R, @SETSPEC (N -> R) GEN_PVAR_2056 (forall i : N, (~ (@IN N i (dotdot (NUMERAL (BIT1 0%N)) _933703))) -> (x i) = (R_of_N (NUMERAL 0%N))) x))).
Proof. exact (eq_refl euclidean_space). Qed.
Definition nsphere : N -> Topology (N -> R) := fun _933922 : N => @subtopology (N -> R) (euclidean_space (N.add _933922 (NUMERAL (BIT1 0%N)))) (@GSPEC (N -> R) (fun GEN_PVAR_2062 : N -> R => exists x : N -> R, @SETSPEC (N -> R) GEN_PVAR_2062 ((@sum N (dotdot (NUMERAL (BIT1 0%N)) (N.add _933922 (NUMERAL (BIT1 0%N)))) (fun i : N => Rpow (x i) (NUMERAL (BIT0 (BIT1 0%N))))) = (R_of_N (NUMERAL (BIT1 0%N)))) x)).
Lemma nsphere_def : nsphere = (fun _933922 : N => @subtopology (N -> R) (euclidean_space (N.add _933922 (NUMERAL (BIT1 0%N)))) (@GSPEC (N -> R) (fun GEN_PVAR_2062 : N -> R => exists x : N -> R, @SETSPEC (N -> R) GEN_PVAR_2062 ((@sum N (dotdot (NUMERAL (BIT1 0%N)) (N.add _933922 (NUMERAL (BIT1 0%N)))) (fun i : N => Rpow (x i) (NUMERAL (BIT0 (BIT1 0%N))))) = (R_of_N (NUMERAL (BIT1 0%N)))) x))).
Proof. exact (eq_refl nsphere). Qed.
Definition funspace {A B : Type'} : (A -> Prop) -> (Metric B) -> Metric (A -> B) := fun _936199 : A -> Prop => fun _936200 : Metric B => @metric (A -> B) (@pair ((A -> B) -> Prop) ((prod (A -> B) (A -> B)) -> R) (@GSPEC (A -> B) (fun GEN_PVAR_2068 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2068 ((forall x : A, (@IN A x _936199) -> @IN B (f x) (@mspace B _936200)) /\ ((@IN (A -> B) f (@EXTENSIONAL A B _936199)) /\ (@mbounded B _936200 (@IMAGE A B f _936199)))) f)) (@GABS ((prod (A -> B) (A -> B)) -> R) (fun f : (prod (A -> B) (A -> B)) -> R => forall f' : A -> B, forall g : A -> B, @GEQ R (f (@pair (A -> B) (A -> B) f' g)) (@COND R (_936199 = (@EMPTY A)) (R_of_N (NUMERAL 0%N)) (sup (@GSPEC R (fun GEN_PVAR_2069 : R => exists x : A, @SETSPEC R GEN_PVAR_2069 (@IN A x _936199) (@mdist B _936200 (@pair B B (f' x) (g x)))))))))).
Lemma funspace_def {A B : Type'} : (@funspace A B) = (fun _936199 : A -> Prop => fun _936200 : Metric B => @metric (A -> B) (@pair ((A -> B) -> Prop) ((prod (A -> B) (A -> B)) -> R) (@GSPEC (A -> B) (fun GEN_PVAR_2068 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2068 ((forall x : A, (@IN A x _936199) -> @IN B (f x) (@mspace B _936200)) /\ ((@IN (A -> B) f (@EXTENSIONAL A B _936199)) /\ (@mbounded B _936200 (@IMAGE A B f _936199)))) f)) (@GABS ((prod (A -> B) (A -> B)) -> R) (fun f : (prod (A -> B) (A -> B)) -> R => forall f' : A -> B, forall g : A -> B, @GEQ R (f (@pair (A -> B) (A -> B) f' g)) (@COND R (_936199 = (@EMPTY A)) (R_of_N (NUMERAL 0%N)) (sup (@GSPEC R (fun GEN_PVAR_2069 : R => exists x : A, @SETSPEC R GEN_PVAR_2069 (@IN A x _936199) (@mdist B _936200 (@pair B B (f' x) (g x))))))))))).
Proof. exact (eq_refl (@funspace A B)). Qed.
Definition cfunspace {A B : Type'} : (Topology A) -> (Metric B) -> Metric (A -> B) := fun _937968 : Topology A => fun _937969 : Metric B => @submetric (A -> B) (@funspace A B (@topspace A _937968) _937969) (@GSPEC (A -> B) (fun GEN_PVAR_2081 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2081 (@continuous_map A B (@pair (Topology A) (Topology B) _937968 (@mtopology B _937969)) f) f)).
Lemma cfunspace_def {A B : Type'} : (@cfunspace A B) = (fun _937968 : Topology A => fun _937969 : Metric B => @submetric (A -> B) (@funspace A B (@topspace A _937968) _937969) (@GSPEC (A -> B) (fun GEN_PVAR_2081 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2081 (@continuous_map A B (@pair (Topology A) (Topology B) _937968 (@mtopology B _937969)) f) f))).
Proof. exact (eq_refl (@cfunspace A B)). Qed.
Definition dimension_le {A : Type'} : (Topology A) -> Z -> Prop := fun a0 : Topology A => fun a1 : Z => forall dimension_le' : (Topology A) -> Z -> Prop, (forall a0' : Topology A, forall a1' : Z, ((Z.le (Z.opp (Z_of_N (NUMERAL (BIT1 0%N)))) a1') /\ (forall v : A -> Prop, forall a : A, ((@open_in A a0' v) /\ (@IN A a v)) -> exists u : A -> Prop, (@IN A a u) /\ ((@SUBSET A u v) /\ ((@open_in A a0' u) /\ (dimension_le' (@subtopology A a0' (@frontier_of A a0' u)) (Z.sub a1' (Z_of_N (NUMERAL (BIT1 0%N))))))))) -> dimension_le' a0' a1') -> dimension_le' a0 a1.
Lemma dimension_le_def {A : Type'} : (@dimension_le A) = (fun a0 : Topology A => fun a1 : Z => forall dimension_le' : (Topology A) -> Z -> Prop, (forall a0' : Topology A, forall a1' : Z, ((Z.le (Z.opp (Z_of_N (NUMERAL (BIT1 0%N)))) a1') /\ (forall v : A -> Prop, forall a : A, ((@open_in A a0' v) /\ (@IN A a v)) -> exists u : A -> Prop, (@IN A a u) /\ ((@SUBSET A u v) /\ ((@open_in A a0' u) /\ (dimension_le' (@subtopology A a0' (@frontier_of A a0' u)) (Z.sub a1' (Z_of_N (NUMERAL (BIT1 0%N))))))))) -> dimension_le' a0' a1') -> dimension_le' a0 a1).
Proof. exact (eq_refl (@dimension_le A)). Qed.
Definition standard_simplex : N -> (N -> R) -> Prop := fun _984987 : N => @GSPEC (N -> R) (fun GEN_PVAR_2117 : N -> R => exists x : N -> R, @SETSPEC (N -> R) GEN_PVAR_2117 ((forall i : N, (Rle (R_of_N (NUMERAL 0%N)) (x i)) /\ (Rle (x i) (R_of_N (NUMERAL (BIT1 0%N))))) /\ ((forall i : N, (N.lt _984987 i) -> (x i) = (R_of_N (NUMERAL 0%N))) /\ ((@sum N (dotdot (NUMERAL 0%N) _984987) x) = (R_of_N (NUMERAL (BIT1 0%N)))))) x).
Lemma standard_simplex_def : standard_simplex = (fun _984987 : N => @GSPEC (N -> R) (fun GEN_PVAR_2117 : N -> R => exists x : N -> R, @SETSPEC (N -> R) GEN_PVAR_2117 ((forall i : N, (Rle (R_of_N (NUMERAL 0%N)) (x i)) /\ (Rle (x i) (R_of_N (NUMERAL (BIT1 0%N))))) /\ ((forall i : N, (N.lt _984987 i) -> (x i) = (R_of_N (NUMERAL 0%N))) /\ ((@sum N (dotdot (NUMERAL 0%N) _984987) x) = (R_of_N (NUMERAL (BIT1 0%N)))))) x)).
Proof. exact (eq_refl standard_simplex). Qed.
Definition simplicial_face : N -> (N -> R) -> N -> R := fun _985714 : N => fun _985715 : N -> R => fun i : N => @COND R (N.lt i _985714) (_985715 i) (@COND R (i = _985714) (R_of_N (NUMERAL 0%N)) (_985715 (N.sub i (NUMERAL (BIT1 0%N))))).
Lemma simplicial_face_def : simplicial_face = (fun _985714 : N => fun _985715 : N -> R => fun i : N => @COND R (N.lt i _985714) (_985715 i) (@COND R (i = _985714) (R_of_N (NUMERAL 0%N)) (_985715 (N.sub i (NUMERAL (BIT1 0%N)))))).
Proof. exact (eq_refl simplicial_face). Qed.
Definition singular_simplex {A : Type'} : (prod N (Topology A)) -> ((N -> R) -> A) -> Prop := fun _985816 : prod N (Topology A) => fun _985817 : (N -> R) -> A => (@continuous_map (N -> R) A (@pair (Topology (N -> R)) (Topology A) (@subtopology (N -> R) (@product_topology R N (@UNIV N) (fun i : N => euclideanreal)) (standard_simplex (@fst N (Topology A) _985816))) (@snd N (Topology A) _985816)) _985817) /\ (@EXTENSIONAL (N -> R) A (standard_simplex (@fst N (Topology A) _985816)) _985817).
Lemma singular_simplex_def {A : Type'} : (@singular_simplex A) = (fun _985816 : prod N (Topology A) => fun _985817 : (N -> R) -> A => (@continuous_map (N -> R) A (@pair (Topology (N -> R)) (Topology A) (@subtopology (N -> R) (@product_topology R N (@UNIV N) (fun i : N => euclideanreal)) (standard_simplex (@fst N (Topology A) _985816))) (@snd N (Topology A) _985816)) _985817) /\ (@EXTENSIONAL (N -> R) A (standard_simplex (@fst N (Topology A) _985816)) _985817)).
Proof. exact (eq_refl (@singular_simplex A)). Qed.
Definition singular_face {_521279 : Type'} : N -> N -> ((N -> R) -> _521279) -> (N -> R) -> _521279 := fun _985963 : N => fun _985964 : N => fun _985965 : (N -> R) -> _521279 => @RESTRICTION (N -> R) _521279 (standard_simplex (N.sub _985963 (NUMERAL (BIT1 0%N)))) (@o (N -> R) (N -> R) _521279 _985965 (simplicial_face _985964)).
Lemma singular_face_def {_521279 : Type'} : (@singular_face _521279) = (fun _985963 : N => fun _985964 : N => fun _985965 : (N -> R) -> _521279 => @RESTRICTION (N -> R) _521279 (standard_simplex (N.sub _985963 (NUMERAL (BIT1 0%N)))) (@o (N -> R) (N -> R) _521279 _985965 (simplicial_face _985964))).
Proof. exact (eq_refl (@singular_face _521279)). Qed.
Definition singular_chain {A : Type'} : (prod N (Topology A)) -> (frag ((N -> R) -> A)) -> Prop := fun _985986 : prod N (Topology A) => fun _985987 : frag ((N -> R) -> A) => @SUBSET ((N -> R) -> A) (@frag_support ((N -> R) -> A) _985987) (@singular_simplex A (@pair N (Topology A) (@fst N (Topology A) _985986) (@snd N (Topology A) _985986))).
Lemma singular_chain_def {A : Type'} : (@singular_chain A) = (fun _985986 : prod N (Topology A) => fun _985987 : frag ((N -> R) -> A) => @SUBSET ((N -> R) -> A) (@frag_support ((N -> R) -> A) _985987) (@singular_simplex A (@pair N (Topology A) (@fst N (Topology A) _985986) (@snd N (Topology A) _985986)))).
Proof. exact (eq_refl (@singular_chain A)). Qed.
Definition chain_boundary {A : Type'} : N -> (frag ((N -> R) -> A)) -> frag ((N -> R) -> A) := fun _986240 : N => fun _986241 : frag ((N -> R) -> A) => @COND (frag ((N -> R) -> A)) (_986240 = (NUMERAL 0%N)) (@frag_0 ((N -> R) -> A)) (@frag_extend ((N -> R) -> A) ((N -> R) -> A) (fun f : (N -> R) -> A => @iterate N (frag ((N -> R) -> A)) (@frag_add ((N -> R) -> A)) (dotdot (NUMERAL 0%N) _986240) (fun k : N => @frag_cmul ((N -> R) -> A) (Zpow (Z.opp (Z_of_N (NUMERAL (BIT1 0%N)))) k) (@frag_of ((N -> R) -> A) (@singular_face A _986240 k f)))) _986241).
Lemma chain_boundary_def {A : Type'} : (@chain_boundary A) = (fun _986240 : N => fun _986241 : frag ((N -> R) -> A) => @COND (frag ((N -> R) -> A)) (_986240 = (NUMERAL 0%N)) (@frag_0 ((N -> R) -> A)) (@frag_extend ((N -> R) -> A) ((N -> R) -> A) (fun f : (N -> R) -> A => @iterate N (frag ((N -> R) -> A)) (@frag_add ((N -> R) -> A)) (dotdot (NUMERAL 0%N) _986240) (fun k : N => @frag_cmul ((N -> R) -> A) (Zpow (Z.opp (Z_of_N (NUMERAL (BIT1 0%N)))) k) (@frag_of ((N -> R) -> A) (@singular_face A _986240 k f)))) _986241)).
Proof. exact (eq_refl (@chain_boundary A)). Qed.
Definition mod_subset {_522237 : Type'} : (prod N (Topology _522237)) -> (frag ((N -> R) -> _522237)) -> (frag ((N -> R) -> _522237)) -> Prop := fun _986341 : prod N (Topology _522237) => fun _986342 : frag ((N -> R) -> _522237) => fun _986343 : frag ((N -> R) -> _522237) => @singular_chain _522237 (@pair N (Topology _522237) (@fst N (Topology _522237) _986341) (@snd N (Topology _522237) _986341)) (@frag_sub ((N -> R) -> _522237) _986342 _986343).
Lemma mod_subset_def {_522237 : Type'} : (@mod_subset _522237) = (fun _986341 : prod N (Topology _522237) => fun _986342 : frag ((N -> R) -> _522237) => fun _986343 : frag ((N -> R) -> _522237) => @singular_chain _522237 (@pair N (Topology _522237) (@fst N (Topology _522237) _986341) (@snd N (Topology _522237) _986341)) (@frag_sub ((N -> R) -> _522237) _986342 _986343)).
Proof. exact (eq_refl (@mod_subset _522237)). Qed.
Definition singular_relcycle {_522468 : Type'} : (prod N (prod (Topology _522468) (_522468 -> Prop))) -> (frag ((N -> R) -> _522468)) -> Prop := fun _986368 : prod N (prod (Topology _522468) (_522468 -> Prop)) => fun _986369 : frag ((N -> R) -> _522468) => (@singular_chain _522468 (@pair N (Topology _522468) (@fst N (prod (Topology _522468) (_522468 -> Prop)) _986368) (@fst (Topology _522468) (_522468 -> Prop) (@snd N (prod (Topology _522468) (_522468 -> Prop)) _986368))) _986369) /\ (@eq2 (frag ((N -> R) -> _522468)) (@chain_boundary _522468 (@fst N (prod (Topology _522468) (_522468 -> Prop)) _986368) _986369) (@frag_0 ((N -> R) -> _522468)) (@mod_subset _522468 (@pair N (Topology _522468) (N.sub (@fst N (prod (Topology _522468) (_522468 -> Prop)) _986368) (NUMERAL (BIT1 0%N))) (@subtopology _522468 (@fst (Topology _522468) (_522468 -> Prop) (@snd N (prod (Topology _522468) (_522468 -> Prop)) _986368)) (@snd (Topology _522468) (_522468 -> Prop) (@snd N (prod (Topology _522468) (_522468 -> Prop)) _986368)))))).
Lemma singular_relcycle_def {_522468 : Type'} : (@singular_relcycle _522468) = (fun _986368 : prod N (prod (Topology _522468) (_522468 -> Prop)) => fun _986369 : frag ((N -> R) -> _522468) => (@singular_chain _522468 (@pair N (Topology _522468) (@fst N (prod (Topology _522468) (_522468 -> Prop)) _986368) (@fst (Topology _522468) (_522468 -> Prop) (@snd N (prod (Topology _522468) (_522468 -> Prop)) _986368))) _986369) /\ (@eq2 (frag ((N -> R) -> _522468)) (@chain_boundary _522468 (@fst N (prod (Topology _522468) (_522468 -> Prop)) _986368) _986369) (@frag_0 ((N -> R) -> _522468)) (@mod_subset _522468 (@pair N (Topology _522468) (N.sub (@fst N (prod (Topology _522468) (_522468 -> Prop)) _986368) (NUMERAL (BIT1 0%N))) (@subtopology _522468 (@fst (Topology _522468) (_522468 -> Prop) (@snd N (prod (Topology _522468) (_522468 -> Prop)) _986368)) (@snd (Topology _522468) (_522468 -> Prop) (@snd N (prod (Topology _522468) (_522468 -> Prop)) _986368))))))).
Proof. exact (eq_refl (@singular_relcycle _522468)). Qed.
Definition singular_relboundary {_523075 : Type'} : (prod N (prod (Topology _523075) (_523075 -> Prop))) -> (frag ((N -> R) -> _523075)) -> Prop := fun _986506 : prod N (prod (Topology _523075) (_523075 -> Prop)) => fun _986507 : frag ((N -> R) -> _523075) => exists d : frag ((N -> R) -> _523075), (@singular_chain _523075 (@pair N (Topology _523075) (N.add (@fst N (prod (Topology _523075) (_523075 -> Prop)) _986506) (NUMERAL (BIT1 0%N))) (@fst (Topology _523075) (_523075 -> Prop) (@snd N (prod (Topology _523075) (_523075 -> Prop)) _986506))) d) /\ (@eq2 (frag ((N -> R) -> _523075)) (@chain_boundary _523075 (N.add (@fst N (prod (Topology _523075) (_523075 -> Prop)) _986506) (NUMERAL (BIT1 0%N))) d) _986507 (@mod_subset _523075 (@pair N (Topology _523075) (@fst N (prod (Topology _523075) (_523075 -> Prop)) _986506) (@subtopology _523075 (@fst (Topology _523075) (_523075 -> Prop) (@snd N (prod (Topology _523075) (_523075 -> Prop)) _986506)) (@snd (Topology _523075) (_523075 -> Prop) (@snd N (prod (Topology _523075) (_523075 -> Prop)) _986506)))))).
Lemma singular_relboundary_def {_523075 : Type'} : (@singular_relboundary _523075) = (fun _986506 : prod N (prod (Topology _523075) (_523075 -> Prop)) => fun _986507 : frag ((N -> R) -> _523075) => exists d : frag ((N -> R) -> _523075), (@singular_chain _523075 (@pair N (Topology _523075) (N.add (@fst N (prod (Topology _523075) (_523075 -> Prop)) _986506) (NUMERAL (BIT1 0%N))) (@fst (Topology _523075) (_523075 -> Prop) (@snd N (prod (Topology _523075) (_523075 -> Prop)) _986506))) d) /\ (@eq2 (frag ((N -> R) -> _523075)) (@chain_boundary _523075 (N.add (@fst N (prod (Topology _523075) (_523075 -> Prop)) _986506) (NUMERAL (BIT1 0%N))) d) _986507 (@mod_subset _523075 (@pair N (Topology _523075) (@fst N (prod (Topology _523075) (_523075 -> Prop)) _986506) (@subtopology _523075 (@fst (Topology _523075) (_523075 -> Prop) (@snd N (prod (Topology _523075) (_523075 -> Prop)) _986506)) (@snd (Topology _523075) (_523075 -> Prop) (@snd N (prod (Topology _523075) (_523075 -> Prop)) _986506))))))).
Proof. exact (eq_refl (@singular_relboundary _523075)). Qed.
Definition homologous_rel {A : Type'} : (prod N (prod (Topology A) (A -> Prop))) -> (frag ((N -> R) -> A)) -> (frag ((N -> R) -> A)) -> Prop := fun _986886 : prod N (prod (Topology A) (A -> Prop)) => fun _986887 : frag ((N -> R) -> A) => fun _986888 : frag ((N -> R) -> A) => @singular_relboundary A (@pair N (prod (Topology A) (A -> Prop)) (@fst N (prod (Topology A) (A -> Prop)) _986886) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _986886)) (@snd (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _986886)))) (@frag_sub ((N -> R) -> A) _986887 _986888).
Lemma homologous_rel_def {A : Type'} : (@homologous_rel A) = (fun _986886 : prod N (prod (Topology A) (A -> Prop)) => fun _986887 : frag ((N -> R) -> A) => fun _986888 : frag ((N -> R) -> A) => @singular_relboundary A (@pair N (prod (Topology A) (A -> Prop)) (@fst N (prod (Topology A) (A -> Prop)) _986886) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _986886)) (@snd (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _986886)))) (@frag_sub ((N -> R) -> A) _986887 _986888)).
Proof. exact (eq_refl (@homologous_rel A)). Qed.
Definition simplex_map {A B : Type'} : N -> (A -> B) -> ((N -> R) -> A) -> (N -> R) -> B := fun _988371 : N => fun _988372 : A -> B => fun _988373 : (N -> R) -> A => @RESTRICTION (N -> R) B (standard_simplex _988371) (@o (N -> R) A B _988372 _988373).
Lemma simplex_map_def {A B : Type'} : (@simplex_map A B) = (fun _988371 : N => fun _988372 : A -> B => fun _988373 : (N -> R) -> A => @RESTRICTION (N -> R) B (standard_simplex _988371) (@o (N -> R) A B _988372 _988373)).
Proof. exact (eq_refl (@simplex_map A B)). Qed.
Definition chain_map {A B : Type'} : N -> (A -> B) -> (frag ((N -> R) -> A)) -> frag ((N -> R) -> B) := fun _988811 : N => fun _988812 : A -> B => fun _988813 : frag ((N -> R) -> A) => @frag_extend ((N -> R) -> A) ((N -> R) -> B) (@o ((N -> R) -> A) ((N -> R) -> B) (frag ((N -> R) -> B)) (@frag_of ((N -> R) -> B)) (@simplex_map A B _988811 _988812)) _988813.
Lemma chain_map_def {A B : Type'} : (@chain_map A B) = (fun _988811 : N => fun _988812 : A -> B => fun _988813 : frag ((N -> R) -> A) => @frag_extend ((N -> R) -> A) ((N -> R) -> B) (@o ((N -> R) -> A) ((N -> R) -> B) (frag ((N -> R) -> B)) (@frag_of ((N -> R) -> B)) (@simplex_map A B _988811 _988812)) _988813).
Proof. exact (eq_refl (@chain_map A B)). Qed.
Definition oriented_simplex : N -> (N -> N -> R) -> (N -> R) -> N -> R := fun _990052 : N => fun _990053 : N -> N -> R => @RESTRICTION (N -> R) (N -> R) (standard_simplex _990052) (fun x : N -> R => fun i : N => @sum N (dotdot (NUMERAL 0%N) _990052) (fun j : N => Rmult (_990053 j i) (x j))).
Lemma oriented_simplex_def : oriented_simplex = (fun _990052 : N => fun _990053 : N -> N -> R => @RESTRICTION (N -> R) (N -> R) (standard_simplex _990052) (fun x : N -> R => fun i : N => @sum N (dotdot (NUMERAL 0%N) _990052) (fun j : N => Rmult (_990053 j i) (x j)))).
Proof. exact (eq_refl oriented_simplex). Qed.
Definition simplicial_simplex : (prod N ((N -> R) -> Prop)) -> ((N -> R) -> N -> R) -> Prop := fun _990064 : prod N ((N -> R) -> Prop) => fun _990065 : (N -> R) -> N -> R => (@singular_simplex (N -> R) (@pair N (Topology (N -> R)) (@fst N ((N -> R) -> Prop) _990064) (@subtopology (N -> R) (@product_topology R N (@UNIV N) (fun i : N => euclideanreal)) (@snd N ((N -> R) -> Prop) _990064))) _990065) /\ (exists l : N -> N -> R, _990065 = (oriented_simplex (@fst N ((N -> R) -> Prop) _990064) l)).
Lemma simplicial_simplex_def : simplicial_simplex = (fun _990064 : prod N ((N -> R) -> Prop) => fun _990065 : (N -> R) -> N -> R => (@singular_simplex (N -> R) (@pair N (Topology (N -> R)) (@fst N ((N -> R) -> Prop) _990064) (@subtopology (N -> R) (@product_topology R N (@UNIV N) (fun i : N => euclideanreal)) (@snd N ((N -> R) -> Prop) _990064))) _990065) /\ (exists l : N -> N -> R, _990065 = (oriented_simplex (@fst N ((N -> R) -> Prop) _990064) l))).
Proof. exact (eq_refl simplicial_simplex). Qed.
Definition simplicial_chain : (prod N ((N -> R) -> Prop)) -> (frag ((N -> R) -> N -> R)) -> Prop := fun _990089 : prod N ((N -> R) -> Prop) => fun _990090 : frag ((N -> R) -> N -> R) => @SUBSET ((N -> R) -> N -> R) (@frag_support ((N -> R) -> N -> R) _990090) (simplicial_simplex (@pair N ((N -> R) -> Prop) (@fst N ((N -> R) -> Prop) _990089) (@snd N ((N -> R) -> Prop) _990089))).
Lemma simplicial_chain_def : simplicial_chain = (fun _990089 : prod N ((N -> R) -> Prop) => fun _990090 : frag ((N -> R) -> N -> R) => @SUBSET ((N -> R) -> N -> R) (@frag_support ((N -> R) -> N -> R) _990090) (simplicial_simplex (@pair N ((N -> R) -> Prop) (@fst N ((N -> R) -> Prop) _990089) (@snd N ((N -> R) -> Prop) _990089)))).
Proof. exact (eq_refl simplicial_chain). Qed.
Definition simplex_cone : N -> (N -> R) -> ((N -> R) -> N -> R) -> (N -> R) -> N -> R := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> N -> (N -> R) -> ((N -> R) -> N -> R) -> (N -> R) -> N -> R) (fun cone : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> N -> (N -> R) -> ((N -> R) -> N -> R) -> (N -> R) -> N -> R => forall _990310 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))), forall p : N, forall v : N -> R, forall l : N -> N -> R, (cone _990310 p v (oriented_simplex p l)) = (oriented_simplex (N.add p (NUMERAL (BIT1 0%N))) (fun i : N => @COND (N -> R) (i = (NUMERAL 0%N)) v (l (N.sub i (NUMERAL (BIT1 0%N))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))).
Lemma simplex_cone_def : simplex_cone = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> N -> (N -> R) -> ((N -> R) -> N -> R) -> (N -> R) -> N -> R) (fun cone : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> N -> (N -> R) -> ((N -> R) -> N -> R) -> (N -> R) -> N -> R => forall _990310 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))), forall p : N, forall v : N -> R, forall l : N -> N -> R, (cone _990310 p v (oriented_simplex p l)) = (oriented_simplex (N.add p (NUMERAL (BIT1 0%N))) (fun i : N => @COND (N -> R) (i = (NUMERAL 0%N)) v (l (N.sub i (NUMERAL (BIT1 0%N))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))).
Proof. exact (eq_refl simplex_cone). Qed.
Definition simplicial_cone : N -> (N -> R) -> (frag ((N -> R) -> N -> R)) -> frag ((N -> R) -> N -> R) := fun _990469 : N => fun _990470 : N -> R => @frag_extend ((N -> R) -> N -> R) ((N -> R) -> N -> R) (@o ((N -> R) -> N -> R) ((N -> R) -> N -> R) (frag ((N -> R) -> N -> R)) (@frag_of ((N -> R) -> N -> R)) (simplex_cone _990469 _990470)).
Lemma simplicial_cone_def : simplicial_cone = (fun _990469 : N => fun _990470 : N -> R => @frag_extend ((N -> R) -> N -> R) ((N -> R) -> N -> R) (@o ((N -> R) -> N -> R) ((N -> R) -> N -> R) (frag ((N -> R) -> N -> R)) (@frag_of ((N -> R) -> N -> R)) (simplex_cone _990469 _990470))).
Proof. exact (eq_refl simplicial_cone). Qed.
Definition simplicial_vertex : N -> ((N -> R) -> N -> R) -> N -> R := fun _990744 : N => fun _990745 : (N -> R) -> N -> R => _990745 (fun j : N => @COND R (j = _990744) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))).
Lemma simplicial_vertex_def : simplicial_vertex = (fun _990744 : N => fun _990745 : (N -> R) -> N -> R => _990745 (fun j : N => @COND R (j = _990744) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl simplicial_vertex). Qed.
Definition simplicial_subdivision : N -> (frag ((N -> R) -> N -> R)) -> frag ((N -> R) -> N -> R) := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (frag ((N -> R) -> N -> R)) -> frag ((N -> R) -> N -> R)) (fun simplicial_subdivision' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (frag ((N -> R) -> N -> R)) -> frag ((N -> R) -> N -> R) => forall _990765 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))), ((simplicial_subdivision' _990765 (NUMERAL 0%N)) = (@I (frag ((N -> R) -> N -> R)))) /\ (forall p : N, (simplicial_subdivision' _990765 (N.succ p)) = (@frag_extend ((N -> R) -> N -> R) ((N -> R) -> N -> R) (fun f : (N -> R) -> N -> R => simplicial_cone p (fun i : N => Rdiv (@sum N (dotdot (NUMERAL 0%N) (N.succ p)) (fun j : N => simplicial_vertex j f i)) (Rplus (R_of_N p) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (simplicial_subdivision' _990765 p (@chain_boundary (N -> R) (N.succ p) (@frag_of ((N -> R) -> N -> R) f))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))))))).
Lemma simplicial_subdivision_def : simplicial_subdivision = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (frag ((N -> R) -> N -> R)) -> frag ((N -> R) -> N -> R)) (fun simplicial_subdivision' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (frag ((N -> R) -> N -> R)) -> frag ((N -> R) -> N -> R) => forall _990765 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))), ((simplicial_subdivision' _990765 (NUMERAL 0%N)) = (@I (frag ((N -> R) -> N -> R)))) /\ (forall p : N, (simplicial_subdivision' _990765 (N.succ p)) = (@frag_extend ((N -> R) -> N -> R) ((N -> R) -> N -> R) (fun f : (N -> R) -> N -> R => simplicial_cone p (fun i : N => Rdiv (@sum N (dotdot (NUMERAL 0%N) (N.succ p)) (fun j : N => simplicial_vertex j f i)) (Rplus (R_of_N p) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (simplicial_subdivision' _990765 p (@chain_boundary (N -> R) (N.succ p) (@frag_of ((N -> R) -> N -> R) f))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))))))))).
Proof. exact (eq_refl simplicial_subdivision). Qed.
Definition singular_subdivision {_536613 : Type'} : N -> (frag ((N -> R) -> _536613)) -> frag ((N -> R) -> _536613) := fun _991670 : N => @frag_extend ((N -> R) -> _536613) ((N -> R) -> _536613) (fun f : (N -> R) -> _536613 => @chain_map (N -> R) _536613 _991670 f (simplicial_subdivision _991670 (@frag_of ((N -> R) -> N -> R) (@RESTRICTION (N -> R) (N -> R) (standard_simplex _991670) (@I (N -> R)))))).
Lemma singular_subdivision_def {_536613 : Type'} : (@singular_subdivision _536613) = (fun _991670 : N => @frag_extend ((N -> R) -> _536613) ((N -> R) -> _536613) (fun f : (N -> R) -> _536613 => @chain_map (N -> R) _536613 _991670 f (simplicial_subdivision _991670 (@frag_of ((N -> R) -> N -> R) (@RESTRICTION (N -> R) (N -> R) (standard_simplex _991670) (@I (N -> R))))))).
Proof. exact (eq_refl (@singular_subdivision _536613)). Qed.
Definition chain_group {A : Type'} : (prod N (Topology A)) -> Group (frag ((N -> R) -> A)) := fun _999613 : prod N (Topology A) => @free_abelian_group ((N -> R) -> A) (@singular_simplex A (@pair N (Topology A) (@fst N (Topology A) _999613) (@snd N (Topology A) _999613))).
Lemma chain_group_def {A : Type'} : (@chain_group A) = (fun _999613 : prod N (Topology A) => @free_abelian_group ((N -> R) -> A) (@singular_simplex A (@pair N (Topology A) (@fst N (Topology A) _999613) (@snd N (Topology A) _999613)))).
Proof. exact (eq_refl (@chain_group A)). Qed.
Definition relcycle_group {A : Type'} : (prod N (prod (Topology A) (A -> Prop))) -> Group (frag ((N -> R) -> A)) := fun _999622 : prod N (prod (Topology A) (A -> Prop)) => @subgroup_generated (frag ((N -> R) -> A)) (@chain_group A (@pair N (Topology A) (@fst N (prod (Topology A) (A -> Prop)) _999622) (@fst (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _999622)))) (@singular_relcycle A (@pair N (prod (Topology A) (A -> Prop)) (@fst N (prod (Topology A) (A -> Prop)) _999622) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _999622)) (@snd (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _999622))))).
Lemma relcycle_group_def {A : Type'} : (@relcycle_group A) = (fun _999622 : prod N (prod (Topology A) (A -> Prop)) => @subgroup_generated (frag ((N -> R) -> A)) (@chain_group A (@pair N (Topology A) (@fst N (prod (Topology A) (A -> Prop)) _999622) (@fst (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _999622)))) (@singular_relcycle A (@pair N (prod (Topology A) (A -> Prop)) (@fst N (prod (Topology A) (A -> Prop)) _999622) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _999622)) (@snd (Topology A) (A -> Prop) (@snd N (prod (Topology A) (A -> Prop)) _999622)))))).
Proof. exact (eq_refl (@relcycle_group A)). Qed.
Definition relative_homology_group {A : Type'} : (prod Z (prod (Topology A) (A -> Prop))) -> Group ((frag ((N -> R) -> A)) -> Prop) := fun _999635 : prod Z (prod (Topology A) (A -> Prop)) => @COND (Group ((frag ((N -> R) -> A)) -> Prop)) (Z.lt (@fst Z (prod (Topology A) (A -> Prop)) _999635) (Z_of_N (NUMERAL 0%N))) (@singleton_group ((frag ((N -> R) -> A)) -> Prop) (@ARB ((frag ((N -> R) -> A)) -> Prop))) (@quotient_group (frag ((N -> R) -> A)) (@relcycle_group A (@pair N (prod (Topology A) (A -> Prop)) (num_of_int (@fst Z (prod (Topology A) (A -> Prop)) _999635)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635)) (@snd (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635))))) (@singular_relboundary A (@pair N (prod (Topology A) (A -> Prop)) (num_of_int (@fst Z (prod (Topology A) (A -> Prop)) _999635)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635)) (@snd (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635)))))).
Lemma relative_homology_group_def {A : Type'} : (@relative_homology_group A) = (fun _999635 : prod Z (prod (Topology A) (A -> Prop)) => @COND (Group ((frag ((N -> R) -> A)) -> Prop)) (Z.lt (@fst Z (prod (Topology A) (A -> Prop)) _999635) (Z_of_N (NUMERAL 0%N))) (@singleton_group ((frag ((N -> R) -> A)) -> Prop) (@ARB ((frag ((N -> R) -> A)) -> Prop))) (@quotient_group (frag ((N -> R) -> A)) (@relcycle_group A (@pair N (prod (Topology A) (A -> Prop)) (num_of_int (@fst Z (prod (Topology A) (A -> Prop)) _999635)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635)) (@snd (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635))))) (@singular_relboundary A (@pair N (prod (Topology A) (A -> Prop)) (num_of_int (@fst Z (prod (Topology A) (A -> Prop)) _999635)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635)) (@snd (Topology A) (A -> Prop) (@snd Z (prod (Topology A) (A -> Prop)) _999635))))))).
Proof. exact (eq_refl (@relative_homology_group A)). Qed.
Definition homology_group {A : Type'} : (prod Z (Topology A)) -> Group ((frag ((N -> R) -> A)) -> Prop) := fun _999648 : prod Z (Topology A) => @relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) (@fst Z (Topology A) _999648) (@pair (Topology A) (A -> Prop) (@snd Z (Topology A) _999648) (@EMPTY A))).
Lemma homology_group_def {A : Type'} : (@homology_group A) = (fun _999648 : prod Z (Topology A) => @relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) (@fst Z (Topology A) _999648) (@pair (Topology A) (A -> Prop) (@snd Z (Topology A) _999648) (@EMPTY A)))).
Proof. exact (eq_refl (@homology_group A)). Qed.
Definition hom_boundary {A : Type'} : Z -> (prod (Topology A) (A -> Prop)) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> A)) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> A)) -> Prop) (fun d : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> A)) -> Prop => forall _1000274 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))), (forall p : Z, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((N -> R) -> A)) -> Prop, (~ (@IN ((frag ((N -> R) -> A)) -> Prop) c (@group_carrier ((frag ((N -> R) -> A)) -> Prop) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))) -> (d _1000274 p (@pair (Topology A) (A -> Prop) top s) c) = (@group_id ((frag ((N -> R) -> A)) -> Prop) (@homology_group A (@pair Z (Topology A) (Z.sub p (Z_of_N (NUMERAL (BIT1 0%N)))) (@subtopology A top s))))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, @group_homomorphism ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> A)) -> Prop) (@pair (Group ((frag ((N -> R) -> A)) -> Prop)) (Group ((frag ((N -> R) -> A)) -> Prop)) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@homology_group A (@pair Z (Topology A) (Z.sub p (Z_of_N (NUMERAL (BIT1 0%N)))) (@subtopology A top s)))) (d _1000274 p (@pair (Topology A) (A -> Prop) top s))) /\ ((forall p : N, forall top : Topology A, forall s : A -> Prop, forall c : frag ((N -> R) -> A), ((@singular_relcycle A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c) /\ (N.le (NUMERAL (BIT1 0%N)) p)) -> (d _1000274 (Z_of_N p) (@pair (Topology A) (A -> Prop) top s) (@homologous_rel A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel A (@pair N (prod (Topology A) (A -> Prop)) (N.sub p (NUMERAL (BIT1 0%N))) (@pair (Topology A) (A -> Prop) (@subtopology A top s) (@EMPTY A))) (@chain_boundary A p c))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, (d _1000274 p (@pair (Topology A) (A -> Prop) top s)) = (d _1000274 p (@pair (Topology A) (A -> Prop) top (@INTER A (@topspace A top) s)))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((N -> R) -> A)) -> Prop, @IN ((frag ((N -> R) -> A)) -> Prop) (d _1000274 p (@pair (Topology A) (A -> Prop) top s) c) (@group_carrier ((frag ((N -> R) -> A)) -> Prop) (@homology_group A (@pair Z (Topology A) (Z.sub p (Z_of_N (NUMERAL (BIT1 0%N)))) (@subtopology A top s))))) /\ (forall p : Z, (Z.le p (Z_of_N (NUMERAL 0%N))) -> (d _1000274 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : (frag ((N -> R) -> A)) -> Prop => @ARB ((frag ((N -> R) -> A)) -> Prop)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))))).
Lemma hom_boundary_def {A : Type'} : (@hom_boundary A) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> A)) -> Prop) (fun d : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> A)) -> Prop => forall _1000274 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))), (forall p : Z, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((N -> R) -> A)) -> Prop, (~ (@IN ((frag ((N -> R) -> A)) -> Prop) c (@group_carrier ((frag ((N -> R) -> A)) -> Prop) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))) -> (d _1000274 p (@pair (Topology A) (A -> Prop) top s) c) = (@group_id ((frag ((N -> R) -> A)) -> Prop) (@homology_group A (@pair Z (Topology A) (Z.sub p (Z_of_N (NUMERAL (BIT1 0%N)))) (@subtopology A top s))))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, @group_homomorphism ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> A)) -> Prop) (@pair (Group ((frag ((N -> R) -> A)) -> Prop)) (Group ((frag ((N -> R) -> A)) -> Prop)) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@homology_group A (@pair Z (Topology A) (Z.sub p (Z_of_N (NUMERAL (BIT1 0%N)))) (@subtopology A top s)))) (d _1000274 p (@pair (Topology A) (A -> Prop) top s))) /\ ((forall p : N, forall top : Topology A, forall s : A -> Prop, forall c : frag ((N -> R) -> A), ((@singular_relcycle A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c) /\ (N.le (NUMERAL (BIT1 0%N)) p)) -> (d _1000274 (Z_of_N p) (@pair (Topology A) (A -> Prop) top s) (@homologous_rel A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel A (@pair N (prod (Topology A) (A -> Prop)) (N.sub p (NUMERAL (BIT1 0%N))) (@pair (Topology A) (A -> Prop) (@subtopology A top s) (@EMPTY A))) (@chain_boundary A p c))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, (d _1000274 p (@pair (Topology A) (A -> Prop) top s)) = (d _1000274 p (@pair (Topology A) (A -> Prop) top (@INTER A (@topspace A top) s)))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((N -> R) -> A)) -> Prop, @IN ((frag ((N -> R) -> A)) -> Prop) (d _1000274 p (@pair (Topology A) (A -> Prop) top s) c) (@group_carrier ((frag ((N -> R) -> A)) -> Prop) (@homology_group A (@pair Z (Topology A) (Z.sub p (Z_of_N (NUMERAL (BIT1 0%N)))) (@subtopology A top s))))) /\ (forall p : Z, (Z.le p (Z_of_N (NUMERAL 0%N))) -> (d _1000274 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : (frag ((N -> R) -> A)) -> Prop => @ARB ((frag ((N -> R) -> A)) -> Prop)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))))))).
Proof. exact (eq_refl (@hom_boundary A)). Qed.
Definition hom_induced {A B : Type'} : Z -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> B)) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> B)) -> Prop) (fun hom_relmap' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> B)) -> Prop => forall _1005060 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), (forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : (frag ((N -> R) -> A)) -> Prop, (~ ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@SUBSET B (@IMAGE A B f (@INTER A (@topspace A top) s)) t) /\ (@IN ((frag ((N -> R) -> A)) -> Prop) c (@group_carrier ((frag ((N -> R) -> A)) -> Prop) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))))) -> (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) = (@group_id ((frag ((N -> R) -> B)) -> Prop) (@relative_homology_group B (@pair Z (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, @group_homomorphism ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> B)) -> Prop) (@pair (Group ((frag ((N -> R) -> A)) -> Prop)) (Group ((frag ((N -> R) -> B)) -> Prop)) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@relative_homology_group B (@pair Z (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)))) (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f)) /\ ((forall p : N, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : frag ((N -> R) -> A), ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@SUBSET B (@IMAGE A B f (@INTER A (@topspace A top) s)) t) /\ (@singular_relcycle A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c))) -> (hom_relmap' _1005060 (Z_of_N p) (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f (@homologous_rel A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel B (@pair N (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)) (@chain_map A B p f c))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t)) = (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top (@INTER A (@topspace A top) s)) (@pair (Topology B) (B -> Prop) top' (@INTER B (@topspace B top') t)))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall f : A -> B, forall t : B -> Prop, forall c : (frag ((N -> R) -> A)) -> Prop, @IN ((frag ((N -> R) -> B)) -> Prop) (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) (@group_carrier ((frag ((N -> R) -> B)) -> Prop) (@relative_homology_group B (@pair Z (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ (forall p : Z, (Z.lt p (Z_of_N (NUMERAL 0%N))) -> (hom_relmap' _1005060 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : prod (Topology B) (B -> Prop) => fun s : A -> B => fun t : (frag ((N -> R) -> A)) -> Prop => @ARB ((frag ((N -> R) -> B)) -> Prop)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))).
Lemma hom_induced_def {A B : Type'} : (@hom_induced A B) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> B)) -> Prop) (fun hom_relmap' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> Z -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> B)) -> Prop => forall _1005060 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), (forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : (frag ((N -> R) -> A)) -> Prop, (~ ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@SUBSET B (@IMAGE A B f (@INTER A (@topspace A top) s)) t) /\ (@IN ((frag ((N -> R) -> A)) -> Prop) c (@group_carrier ((frag ((N -> R) -> A)) -> Prop) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))))) -> (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) = (@group_id ((frag ((N -> R) -> B)) -> Prop) (@relative_homology_group B (@pair Z (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, @group_homomorphism ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> B)) -> Prop) (@pair (Group ((frag ((N -> R) -> A)) -> Prop)) (Group ((frag ((N -> R) -> B)) -> Prop)) (@relative_homology_group A (@pair Z (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@relative_homology_group B (@pair Z (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)))) (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f)) /\ ((forall p : N, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : frag ((N -> R) -> A), ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@SUBSET B (@IMAGE A B f (@INTER A (@topspace A top) s)) t) /\ (@singular_relcycle A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c))) -> (hom_relmap' _1005060 (Z_of_N p) (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f (@homologous_rel A (@pair N (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel B (@pair N (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)) (@chain_map A B p f c))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t)) = (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top (@INTER A (@topspace A top) s)) (@pair (Topology B) (B -> Prop) top' (@INTER B (@topspace B top') t)))) /\ ((forall p : Z, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall f : A -> B, forall t : B -> Prop, forall c : (frag ((N -> R) -> A)) -> Prop, @IN ((frag ((N -> R) -> B)) -> Prop) (hom_relmap' _1005060 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) (@group_carrier ((frag ((N -> R) -> B)) -> Prop) (@relative_homology_group B (@pair Z (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ (forall p : Z, (Z.lt p (Z_of_N (NUMERAL 0%N))) -> (hom_relmap' _1005060 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : prod (Topology B) (B -> Prop) => fun s : A -> B => fun t : (frag ((N -> R) -> A)) -> Prop => @ARB ((frag ((N -> R) -> B)) -> Prop)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))).
Proof. exact (eq_refl (@hom_induced A B)). Qed.
Definition hom_relboundary {A : Type'} : Z -> (prod (Topology A) (prod (A -> Prop) (A -> Prop))) -> ((frag ((N -> R) -> A)) -> Prop) -> (frag ((N -> R) -> A)) -> Prop := fun _1021298 : Z => fun _1021299 : prod (Topology A) (prod (A -> Prop) (A -> Prop)) => @o ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> A)) -> Prop) (@hom_induced A A (Z.sub _1021298 (Z_of_N (NUMERAL (BIT1 0%N)))) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))) (@EMPTY A)) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))) (@snd (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))) (fun x : A => x)) (@hom_boundary A _1021298 (@pair (Topology A) (A -> Prop) (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299)))).
Lemma hom_relboundary_def {A : Type'} : (@hom_relboundary A) = (fun _1021298 : Z => fun _1021299 : prod (Topology A) (prod (A -> Prop) (A -> Prop)) => @o ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> A)) -> Prop) (@hom_induced A A (Z.sub _1021298 (Z_of_N (NUMERAL (BIT1 0%N)))) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))) (@EMPTY A)) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))) (@snd (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))) (fun x : A => x)) (@hom_boundary A _1021298 (@pair (Topology A) (A -> Prop) (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1021299))))).
Proof. exact (eq_refl (@hom_relboundary A)). Qed.
Definition reduced_homology_group {A : Type'} : (prod Z (Topology A)) -> Group ((frag ((N -> R) -> A)) -> Prop) := fun _1022814 : prod Z (Topology A) => @subgroup_generated ((frag ((N -> R) -> A)) -> Prop) (@homology_group A (@pair Z (Topology A) (@fst Z (Topology A) _1022814) (@snd Z (Topology A) _1022814))) (@group_kernel ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> unit)) -> Prop) (@pair (Group ((frag ((N -> R) -> A)) -> Prop)) (Group ((frag ((N -> R) -> unit)) -> Prop)) (@homology_group A (@pair Z (Topology A) (@fst Z (Topology A) _1022814) (@snd Z (Topology A) _1022814))) (@homology_group unit (@pair Z (Topology unit) (@fst Z (Topology A) _1022814) (@discrete_topology unit (@INSERT unit tt (@EMPTY unit)))))) (@hom_induced A unit (@fst Z (Topology A) _1022814) (@pair (Topology A) (A -> Prop) (@snd Z (Topology A) _1022814) (@EMPTY A)) (@pair (Topology unit) (unit -> Prop) (@discrete_topology unit (@INSERT unit tt (@EMPTY unit))) (@EMPTY unit)) (fun x : A => tt))).
Lemma reduced_homology_group_def {A : Type'} : (@reduced_homology_group A) = (fun _1022814 : prod Z (Topology A) => @subgroup_generated ((frag ((N -> R) -> A)) -> Prop) (@homology_group A (@pair Z (Topology A) (@fst Z (Topology A) _1022814) (@snd Z (Topology A) _1022814))) (@group_kernel ((frag ((N -> R) -> A)) -> Prop) ((frag ((N -> R) -> unit)) -> Prop) (@pair (Group ((frag ((N -> R) -> A)) -> Prop)) (Group ((frag ((N -> R) -> unit)) -> Prop)) (@homology_group A (@pair Z (Topology A) (@fst Z (Topology A) _1022814) (@snd Z (Topology A) _1022814))) (@homology_group unit (@pair Z (Topology unit) (@fst Z (Topology A) _1022814) (@discrete_topology unit (@INSERT unit tt (@EMPTY unit)))))) (@hom_induced A unit (@fst Z (Topology A) _1022814) (@pair (Topology A) (A -> Prop) (@snd Z (Topology A) _1022814) (@EMPTY A)) (@pair (Topology unit) (unit -> Prop) (@discrete_topology unit (@INSERT unit tt (@EMPTY unit))) (@EMPTY unit)) (fun x : A => tt)))).
Proof. exact (eq_refl (@reduced_homology_group A)). Qed.
Definition brouwer_degree2 : N -> ((N -> R) -> N -> R) -> Z := fun _1028894 : N => fun _1028895 : (N -> R) -> N -> R => @ε Z (fun d : Z => forall x : (frag ((N -> R) -> N -> R)) -> Prop, (@IN ((frag ((N -> R) -> N -> R)) -> Prop) x (@group_carrier ((frag ((N -> R) -> N -> R)) -> Prop) (@reduced_homology_group (N -> R) (@pair Z (Topology (N -> R)) (Z_of_N _1028894) (nsphere _1028894))))) -> (@hom_induced (N -> R) (N -> R) (Z_of_N _1028894) (@pair (Topology (N -> R)) ((N -> R) -> Prop) (nsphere _1028894) (@EMPTY (N -> R))) (@pair (Topology (N -> R)) ((N -> R) -> Prop) (nsphere _1028894) (@EMPTY (N -> R))) _1028895 x) = (@group_zpow ((frag ((N -> R) -> N -> R)) -> Prop) (@reduced_homology_group (N -> R) (@pair Z (Topology (N -> R)) (Z_of_N _1028894) (nsphere _1028894))) x d)).
Lemma brouwer_degree2_def : brouwer_degree2 = (fun _1028894 : N => fun _1028895 : (N -> R) -> N -> R => @ε Z (fun d : Z => forall x : (frag ((N -> R) -> N -> R)) -> Prop, (@IN ((frag ((N -> R) -> N -> R)) -> Prop) x (@group_carrier ((frag ((N -> R) -> N -> R)) -> Prop) (@reduced_homology_group (N -> R) (@pair Z (Topology (N -> R)) (Z_of_N _1028894) (nsphere _1028894))))) -> (@hom_induced (N -> R) (N -> R) (Z_of_N _1028894) (@pair (Topology (N -> R)) ((N -> R) -> Prop) (nsphere _1028894) (@EMPTY (N -> R))) (@pair (Topology (N -> R)) ((N -> R) -> Prop) (nsphere _1028894) (@EMPTY (N -> R))) _1028895 x) = (@group_zpow ((frag ((N -> R) -> N -> R)) -> Prop) (@reduced_homology_group (N -> R) (@pair Z (Topology (N -> R)) (Z_of_N _1028894) (nsphere _1028894))) x d))).
Proof. exact (eq_refl brouwer_degree2). Qed.
Definition vector_add {N' : Type'} : (cart R N') -> (cart R N') -> cart R N' := fun _1111949 : cart R N' => fun _1111950 : cart R N' => @lambda R N' (fun i : N => Rplus (@dollar R N' _1111949 i) (@dollar R N' _1111950 i)).
Lemma vector_add_def {N' : Type'} : (@vector_add N') = (fun _1111949 : cart R N' => fun _1111950 : cart R N' => @lambda R N' (fun i : N => Rplus (@dollar R N' _1111949 i) (@dollar R N' _1111950 i))).
Proof. exact (eq_refl (@vector_add N')). Qed.
Definition vector_sub {N' : Type'} : (cart R N') -> (cart R N') -> cart R N' := fun _1111961 : cart R N' => fun _1111962 : cart R N' => @lambda R N' (fun i : N => Rminus (@dollar R N' _1111961 i) (@dollar R N' _1111962 i)).
Lemma vector_sub_def {N' : Type'} : (@vector_sub N') = (fun _1111961 : cart R N' => fun _1111962 : cart R N' => @lambda R N' (fun i : N => Rminus (@dollar R N' _1111961 i) (@dollar R N' _1111962 i))).
Proof. exact (eq_refl (@vector_sub N')). Qed.
Definition vector_neg {N' : Type'} : (cart R N') -> cart R N' := fun _1111973 : cart R N' => @lambda R N' (fun i : N => Ropp (@dollar R N' _1111973 i)).
Lemma vector_neg_def {N' : Type'} : (@vector_neg N') = (fun _1111973 : cart R N' => @lambda R N' (fun i : N => Ropp (@dollar R N' _1111973 i))).
Proof. exact (eq_refl (@vector_neg N')). Qed.
Definition percent {N' : Type'} : R -> (cart R N') -> cart R N' := fun _1111978 : R => fun _1111979 : cart R N' => @lambda R N' (fun i : N => Rmult _1111978 (@dollar R N' _1111979 i)).
Lemma percent_def {N' : Type'} : (@percent N') = (fun _1111978 : R => fun _1111979 : cart R N' => @lambda R N' (fun i : N => Rmult _1111978 (@dollar R N' _1111979 i))).
Proof. exact (eq_refl (@percent N')). Qed.
Definition vec {N' : Type'} : N -> cart R N' := fun _1111990 : N => @lambda R N' (fun i : N => R_of_N _1111990).
Lemma vec_def {N' : Type'} : (@vec N') = (fun _1111990 : N => @lambda R N' (fun i : N => R_of_N _1111990)).
Proof. exact (eq_refl (@vec N')). Qed.
Definition dot {N' : Type'} : (cart R N') -> (cart R N') -> R := fun _1111995 : cart R N' => fun _1111996 : cart R N' => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => Rmult (@dollar R N' _1111995 i) (@dollar R N' _1111996 i)).
Lemma dot_def {N' : Type'} : (@dot N') = (fun _1111995 : cart R N' => fun _1111996 : cart R N' => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => Rmult (@dollar R N' _1111995 i) (@dollar R N' _1111996 i))).
Proof. exact (eq_refl (@dot N')). Qed.
Definition vector_norm {_584973 : Type'} : (cart R _584973) -> R := fun _1112751 : cart R _584973 => sqrt (@dot _584973 _1112751 _1112751).
Lemma vector_norm_def {_584973 : Type'} : (@vector_norm _584973) = (fun _1112751 : cart R _584973 => sqrt (@dot _584973 _1112751 _1112751)).
Proof. exact (eq_refl (@vector_norm _584973)). Qed.
Definition distance {_584998 : Type'} : (prod (cart R _584998) (cart R _584998)) -> R := fun _1112756 : prod (cart R _584998) (cart R _584998) => @vector_norm _584998 (@vector_sub _584998 (@fst (cart R _584998) (cart R _584998) _1112756) (@snd (cart R _584998) (cart R _584998) _1112756)).
Lemma distance_def {_584998 : Type'} : (@distance _584998) = (fun _1112756 : prod (cart R _584998) (cart R _584998) => @vector_norm _584998 (@vector_sub _584998 (@fst (cart R _584998) (cart R _584998) _1112756) (@snd (cart R _584998) (cart R _584998) _1112756))).
Proof. exact (eq_refl (@distance _584998)). Qed.
Definition vsum {A N' : Type'} : (A -> Prop) -> (A -> cart R N') -> cart R N' := fun _1114553 : A -> Prop => fun _1114554 : A -> cart R N' => @lambda R N' (fun i : N => @sum A _1114553 (fun x : A => @dollar R N' (_1114554 x) i)).
Lemma vsum_def {A N' : Type'} : (@vsum A N') = (fun _1114553 : A -> Prop => fun _1114554 : A -> cart R N' => @lambda R N' (fun i : N => @sum A _1114553 (fun x : A => @dollar R N' (_1114554 x) i))).
Proof. exact (eq_refl (@vsum A N')). Qed.
Definition basis {_594269 : Type'} : N -> cart R _594269 := fun _1116234 : N => @lambda R _594269 (fun i : N => @COND R (i = _1116234) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))).
Lemma basis_def {_594269 : Type'} : (@basis _594269) = (fun _1116234 : N => @lambda R _594269 (fun i : N => @COND R (i = _1116234) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl (@basis _594269)). Qed.
Definition orthogonal {_594971 : Type'} : (cart R _594971) -> (cart R _594971) -> Prop := fun _1116440 : cart R _594971 => fun _1116441 : cart R _594971 => (@dot _594971 _1116440 _1116441) = (R_of_N (NUMERAL 0%N)).
Lemma orthogonal_def {_594971 : Type'} : (@orthogonal _594971) = (fun _1116440 : cart R _594971 => fun _1116441 : cart R _594971 => (@dot _594971 _1116440 _1116441) = (R_of_N (NUMERAL 0%N))).
Proof. exact (eq_refl (@orthogonal _594971)). Qed.
Definition linear {M N' : Type'} : ((cart R M) -> cart R N') -> Prop := fun _1116618 : (cart R M) -> cart R N' => (forall x : cart R M, forall y : cart R M, (_1116618 (@vector_add M x y)) = (@vector_add N' (_1116618 x) (_1116618 y))) /\ (forall c : R, forall x : cart R M, (_1116618 (@percent M c x)) = (@percent N' c (_1116618 x))).
Lemma linear_def {M N' : Type'} : (@linear M N') = (fun _1116618 : (cart R M) -> cart R N' => (forall x : cart R M, forall y : cart R M, (_1116618 (@vector_add M x y)) = (@vector_add N' (_1116618 x) (_1116618 y))) /\ (forall c : R, forall x : cart R M, (_1116618 (@percent M c x)) = (@percent N' c (_1116618 x)))).
Proof. exact (eq_refl (@linear M N')). Qed.
Definition bilinear {_597144 _597145 _597155 : Type'} : ((cart R _597155) -> (cart R _597144) -> cart R _597145) -> Prop := fun _1116940 : (cart R _597155) -> (cart R _597144) -> cart R _597145 => (forall x : cart R _597155, @linear _597144 _597145 (fun y : cart R _597144 => _1116940 x y)) /\ (forall y : cart R _597144, @linear _597155 _597145 (fun x : cart R _597155 => _1116940 x y)).
Lemma bilinear_def {_597144 _597145 _597155 : Type'} : (@bilinear _597144 _597145 _597155) = (fun _1116940 : (cart R _597155) -> (cart R _597144) -> cart R _597145 => (forall x : cart R _597155, @linear _597144 _597145 (fun y : cart R _597144 => _1116940 x y)) /\ (forall y : cart R _597144, @linear _597155 _597145 (fun x : cart R _597155 => _1116940 x y))).
Proof. exact (eq_refl (@bilinear _597144 _597145 _597155)). Qed.
Definition adjoint {M N' : Type'} : ((cart R M) -> cart R N') -> (cart R N') -> cart R M := fun _1117512 : (cart R M) -> cart R N' => @ε ((cart R N') -> cart R M) (fun f' : (cart R N') -> cart R M => forall x : cart R M, forall y : cart R N', (@dot N' (_1117512 x) y) = (@dot M x (f' y))).
Lemma adjoint_def {M N' : Type'} : (@adjoint M N') = (fun _1117512 : (cart R M) -> cart R N' => @ε ((cart R N') -> cart R M) (fun f' : (cart R N') -> cart R M => forall x : cart R M, forall y : cart R N', (@dot N' (_1117512 x) y) = (@dot M x (f' y)))).
Proof. exact (eq_refl (@adjoint M N')). Qed.
Definition __ {M N' : Type'} : R -> (cart (cart R N') M) -> cart (cart R N') M := fun _1117715 : R => fun _1117716 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Rmult _1117715 (@dollar R N' (@dollar (cart R N') M _1117716 i) j))).
Lemma ___def {M N' : Type'} : (@__ M N') = (fun _1117715 : R => fun _1117716 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Rmult _1117715 (@dollar R N' (@dollar (cart R N') M _1117716 i) j)))).
Proof. exact (eq_refl (@__ M N')). Qed.
Definition matrix_neg {M N' : Type'} : (cart (cart R N') M) -> cart (cart R N') M := fun _1117727 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Ropp (@dollar R N' (@dollar (cart R N') M _1117727 i) j))).
Lemma matrix_neg_def {M N' : Type'} : (@matrix_neg M N') = (fun _1117727 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Ropp (@dollar R N' (@dollar (cart R N') M _1117727 i) j)))).
Proof. exact (eq_refl (@matrix_neg M N')). Qed.
Definition matrix_add {M N' : Type'} : (cart (cart R N') M) -> (cart (cart R N') M) -> cart (cart R N') M := fun _1117732 : cart (cart R N') M => fun _1117733 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Rplus (@dollar R N' (@dollar (cart R N') M _1117732 i) j) (@dollar R N' (@dollar (cart R N') M _1117733 i) j))).
Lemma matrix_add_def {M N' : Type'} : (@matrix_add M N') = (fun _1117732 : cart (cart R N') M => fun _1117733 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Rplus (@dollar R N' (@dollar (cart R N') M _1117732 i) j) (@dollar R N' (@dollar (cart R N') M _1117733 i) j)))).
Proof. exact (eq_refl (@matrix_add M N')). Qed.
Definition matrix_sub {M N' : Type'} : (cart (cart R N') M) -> (cart (cart R N') M) -> cart (cart R N') M := fun _1117744 : cart (cart R N') M => fun _1117745 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Rminus (@dollar R N' (@dollar (cart R N') M _1117744 i) j) (@dollar R N' (@dollar (cart R N') M _1117745 i) j))).
Lemma matrix_sub_def {M N' : Type'} : (@matrix_sub M N') = (fun _1117744 : cart (cart R N') M => fun _1117745 : cart (cart R N') M => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => Rminus (@dollar R N' (@dollar (cart R N') M _1117744 i) j) (@dollar R N' (@dollar (cart R N') M _1117745 i) j)))).
Proof. exact (eq_refl (@matrix_sub M N')). Qed.
Definition matrix_mul {M N' P : Type'} : (cart (cart R N') M) -> (cart (cart R P) N') -> cart (cart R P) M := fun _1117756 : cart (cart R N') M => fun _1117757 : cart (cart R P) N' => @lambda (cart R P) M (fun i : N => @lambda R P (fun j : N => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun k : N => Rmult (@dollar R N' (@dollar (cart R N') M _1117756 i) k) (@dollar R P (@dollar (cart R P) N' _1117757 k) j)))).
Lemma matrix_mul_def {M N' P : Type'} : (@matrix_mul M N' P) = (fun _1117756 : cart (cart R N') M => fun _1117757 : cart (cart R P) N' => @lambda (cart R P) M (fun i : N => @lambda R P (fun j : N => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun k : N => Rmult (@dollar R N' (@dollar (cart R N') M _1117756 i) k) (@dollar R P (@dollar (cart R P) N' _1117757 k) j))))).
Proof. exact (eq_refl (@matrix_mul M N' P)). Qed.
Definition matrix_vector_mul {M N' : Type'} : (cart (cart R N') M) -> (cart R N') -> cart R M := fun _1117768 : cart (cart R N') M => fun _1117769 : cart R N' => @lambda R M (fun i : N => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun j : N => Rmult (@dollar R N' (@dollar (cart R N') M _1117768 i) j) (@dollar R N' _1117769 j))).
Lemma matrix_vector_mul_def {M N' : Type'} : (@matrix_vector_mul M N') = (fun _1117768 : cart (cart R N') M => fun _1117769 : cart R N' => @lambda R M (fun i : N => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun j : N => Rmult (@dollar R N' (@dollar (cart R N') M _1117768 i) j) (@dollar R N' _1117769 j)))).
Proof. exact (eq_refl (@matrix_vector_mul M N')). Qed.
Definition vector_matrix_mul {M N' : Type'} : (cart R M) -> (cart (cart R N') M) -> cart R N' := fun _1117780 : cart R M => fun _1117781 : cart (cart R N') M => @lambda R N' (fun j : N => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex M (@UNIV M))) (fun i : N => Rmult (@dollar R N' (@dollar (cart R N') M _1117781 i) j) (@dollar R M _1117780 i))).
Lemma vector_matrix_mul_def {M N' : Type'} : (@vector_matrix_mul M N') = (fun _1117780 : cart R M => fun _1117781 : cart (cart R N') M => @lambda R N' (fun j : N => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex M (@UNIV M))) (fun i : N => Rmult (@dollar R N' (@dollar (cart R N') M _1117781 i) j) (@dollar R M _1117780 i)))).
Proof. exact (eq_refl (@vector_matrix_mul M N')). Qed.
Definition mat {M N' : Type'} : N -> cart (cart R N') M := fun _1117792 : N => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => @COND R (i = j) (R_of_N _1117792) (R_of_N (NUMERAL 0%N)))).
Lemma mat_def {M N' : Type'} : (@mat M N') = (fun _1117792 : N => @lambda (cart R N') M (fun i : N => @lambda R N' (fun j : N => @COND R (i = j) (R_of_N _1117792) (R_of_N (NUMERAL 0%N))))).
Proof. exact (eq_refl (@mat M N')). Qed.
Definition transp {M N' : Type'} : (cart (cart R N') M) -> cart (cart R M) N' := fun _1117797 : cart (cart R N') M => @lambda (cart R M) N' (fun i : N => @lambda R M (fun j : N => @dollar R N' (@dollar (cart R N') M _1117797 j) i)).
Lemma transp_def {M N' : Type'} : (@transp M N') = (fun _1117797 : cart (cart R N') M => @lambda (cart R M) N' (fun i : N => @lambda R M (fun j : N => @dollar R N' (@dollar (cart R N') M _1117797 j) i))).
Proof. exact (eq_refl (@transp M N')). Qed.
Definition row {M N' : Type'} : N -> (cart (cart R N') M) -> cart R N' := fun _1117802 : N => fun _1117803 : cart (cart R N') M => @lambda R N' (fun j : N => @dollar R N' (@dollar (cart R N') M _1117803 _1117802) j).
Lemma row_def {M N' : Type'} : (@row M N') = (fun _1117802 : N => fun _1117803 : cart (cart R N') M => @lambda R N' (fun j : N => @dollar R N' (@dollar (cart R N') M _1117803 _1117802) j)).
Proof. exact (eq_refl (@row M N')). Qed.
Definition column {M N' : Type'} : N -> (cart (cart R N') M) -> cart R M := fun _1117814 : N => fun _1117815 : cart (cart R N') M => @lambda R M (fun i : N => @dollar R N' (@dollar (cart R N') M _1117815 i) _1117814).
Lemma column_def {M N' : Type'} : (@column M N') = (fun _1117814 : N => fun _1117815 : cart (cart R N') M => @lambda R M (fun i : N => @dollar R N' (@dollar (cart R N') M _1117815 i) _1117814)).
Proof. exact (eq_refl (@column M N')). Qed.
Definition rows {M N' : Type'} : (cart (cart R N') M) -> (cart R N') -> Prop := fun _1117826 : cart (cart R N') M => @GSPEC (cart R N') (fun GEN_PVAR_2385 : cart R N' => exists i : N, @SETSPEC (cart R N') GEN_PVAR_2385 ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex M (@UNIV M)))) (@row M N' i _1117826)).
Lemma rows_def {M N' : Type'} : (@rows M N') = (fun _1117826 : cart (cart R N') M => @GSPEC (cart R N') (fun GEN_PVAR_2385 : cart R N' => exists i : N, @SETSPEC (cart R N') GEN_PVAR_2385 ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex M (@UNIV M)))) (@row M N' i _1117826))).
Proof. exact (eq_refl (@rows M N')). Qed.
Definition columns {M N' : Type'} : (cart (cart R N') M) -> (cart R M) -> Prop := fun _1117831 : cart (cart R N') M => @GSPEC (cart R M) (fun GEN_PVAR_2386 : cart R M => exists i : N, @SETSPEC (cart R M) GEN_PVAR_2386 ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) (@column M N' i _1117831)).
Lemma columns_def {M N' : Type'} : (@columns M N') = (fun _1117831 : cart (cart R N') M => @GSPEC (cart R M) (fun GEN_PVAR_2386 : cart R M => exists i : N, @SETSPEC (cart R M) GEN_PVAR_2386 ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) (@column M N' i _1117831))).
Proof. exact (eq_refl (@columns M N')). Qed.
Definition symmetric_matrix {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1117896 : cart (cart R N') N' => (@transp N' N' _1117896) = _1117896.
Lemma symmetric_matrix_def {N' : Type'} : (@symmetric_matrix N') = (fun _1117896 : cart (cart R N') N' => (@transp N' N' _1117896) = _1117896).
Proof. exact (eq_refl (@symmetric_matrix N')). Qed.
Definition normal_matrix {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1117901 : cart (cart R N') N' => (@matrix_mul N' N' N' (@transp N' N' _1117901) _1117901) = (@matrix_mul N' N' N' _1117901 (@transp N' N' _1117901)).
Lemma normal_matrix_def {N' : Type'} : (@normal_matrix N') = (fun _1117901 : cart (cart R N') N' => (@matrix_mul N' N' N' (@transp N' N' _1117901) _1117901) = (@matrix_mul N' N' N' _1117901 (@transp N' N' _1117901))).
Proof. exact (eq_refl (@normal_matrix N')). Qed.
Definition invertible {M N' : Type'} : (cart (cart R N') M) -> Prop := fun _1118423 : cart (cart R N') M => exists A' : cart (cart R M) N', ((@matrix_mul M N' M _1118423 A') = (@mat M M (NUMERAL (BIT1 0%N)))) /\ ((@matrix_mul N' M N' A' _1118423) = (@mat N' N' (NUMERAL (BIT1 0%N)))).
Lemma invertible_def {M N' : Type'} : (@invertible M N') = (fun _1118423 : cart (cart R N') M => exists A' : cart (cart R M) N', ((@matrix_mul M N' M _1118423 A') = (@mat M M (NUMERAL (BIT1 0%N)))) /\ ((@matrix_mul N' M N' A' _1118423) = (@mat N' N' (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl (@invertible M N')). Qed.
Definition matrix {M N' : Type'} : ((cart R M) -> cart R N') -> cart (cart R M) N' := fun _1118640 : (cart R M) -> cart R N' => @lambda (cart R M) N' (fun i : N => @lambda R M (fun j : N => @dollar R N' (_1118640 (@basis M j)) i)).
Lemma matrix_def {M N' : Type'} : (@matrix M N') = (fun _1118640 : (cart R M) -> cart R N' => @lambda (cart R M) N' (fun i : N => @lambda R M (fun j : N => @dollar R N' (_1118640 (@basis M j)) i))).
Proof. exact (eq_refl (@matrix M N')). Qed.
Definition onorm {M N' : Type'} : ((cart R M) -> cart R N') -> R := fun _1118728 : (cart R M) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_2387 : R => exists x : cart R M, @SETSPEC R GEN_PVAR_2387 ((@vector_norm M x) = (R_of_N (NUMERAL (BIT1 0%N)))) (@vector_norm N' (_1118728 x)))).
Lemma onorm_def {M N' : Type'} : (@onorm M N') = (fun _1118728 : (cart R M) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_2387 : R => exists x : cart R M, @SETSPEC R GEN_PVAR_2387 ((@vector_norm M x) = (R_of_N (NUMERAL (BIT1 0%N)))) (@vector_norm N' (_1118728 x))))).
Proof. exact (eq_refl (@onorm M N')). Qed.
Definition lift : R -> cart R unit := fun _1120564 : R => @lambda R unit (fun i : N => _1120564).
Lemma lift_def : lift = (fun _1120564 : R => @lambda R unit (fun i : N => _1120564)).
Proof. exact (eq_refl lift). Qed.
Definition drop : (cart R unit) -> R := fun _1120569 : cart R unit => @dollar R unit _1120569 (NUMERAL (BIT1 0%N)).
Lemma drop_def : drop = (fun _1120569 : cart R unit => @dollar R unit _1120569 (NUMERAL (BIT1 0%N))).
Proof. exact (eq_refl drop). Qed.
Definition indicator {M : Type'} : ((cart R M) -> Prop) -> (cart R M) -> cart R unit := fun _1122337 : (cart R M) -> Prop => fun x : cart R M => @COND (cart R unit) (@IN (cart R M) x _1122337) (@vec unit (NUMERAL (BIT1 0%N))) (@vec unit (NUMERAL 0%N)).
Lemma indicator_def {M : Type'} : (@indicator M) = (fun _1122337 : (cart R M) -> Prop => fun x : cart R M => @COND (cart R unit) (@IN (cart R M) x _1122337) (@vec unit (NUMERAL (BIT1 0%N))) (@vec unit (NUMERAL 0%N))).
Proof. exact (eq_refl (@indicator M)). Qed.
Definition dropout {M N' : Type'} : N -> (cart R M) -> cart R N' := fun _1122860 : N => fun _1122861 : cart R M => @lambda R N' (fun i : N => @COND R ((N.lt i _1122860) /\ (N.le i (@dimindex M (@UNIV M)))) (@dollar R M _1122861 i) (@COND R (N.le (N.add i (NUMERAL (BIT1 0%N))) (@dimindex M (@UNIV M))) (@dollar R M _1122861 (N.add i (NUMERAL (BIT1 0%N)))) (R_of_N (NUMERAL 0%N)))).
Lemma dropout_def {M N' : Type'} : (@dropout M N') = (fun _1122860 : N => fun _1122861 : cart R M => @lambda R N' (fun i : N => @COND R ((N.lt i _1122860) /\ (N.le i (@dimindex M (@UNIV M)))) (@dollar R M _1122861 i) (@COND R (N.le (N.add i (NUMERAL (BIT1 0%N))) (@dimindex M (@UNIV M))) (@dollar R M _1122861 (N.add i (NUMERAL (BIT1 0%N)))) (R_of_N (NUMERAL 0%N))))).
Proof. exact (eq_refl (@dropout M N')). Qed.
Definition pushin {_611181 _611182 _611193 : Type'} : N -> _611182 -> (cart _611182 _611193) -> cart _611182 _611181 := fun _1122872 : N => fun _1122873 : _611182 => fun _1122874 : cart _611182 _611193 => @lambda _611182 _611181 (fun i : N => @COND _611182 (N.lt i _1122872) (@dollar _611182 _611193 _1122874 i) (@COND _611182 (i = _1122872) _1122873 (@dollar _611182 _611193 _1122874 (N.sub i (NUMERAL (BIT1 0%N)))))).
Lemma pushin_def {_611181 _611182 _611193 : Type'} : (@pushin _611181 _611182 _611193) = (fun _1122872 : N => fun _1122873 : _611182 => fun _1122874 : cart _611182 _611193 => @lambda _611182 _611181 (fun i : N => @COND _611182 (N.lt i _1122872) (@dollar _611182 _611193 _1122874 i) (@COND _611182 (i = _1122872) _1122873 (@dollar _611182 _611193 _1122874 (N.sub i (NUMERAL (BIT1 0%N))))))).
Proof. exact (eq_refl (@pushin _611181 _611182 _611193)). Qed.
Definition subspace {_612295 : Type'} : ((cart R _612295) -> Prop) -> Prop := fun _1123276 : (cart R _612295) -> Prop => (@IN (cart R _612295) (@vec _612295 (NUMERAL 0%N)) _1123276) /\ ((forall x : cart R _612295, forall y : cart R _612295, ((@IN (cart R _612295) x _1123276) /\ (@IN (cart R _612295) y _1123276)) -> @IN (cart R _612295) (@vector_add _612295 x y) _1123276) /\ (forall c : R, forall x : cart R _612295, (@IN (cart R _612295) x _1123276) -> @IN (cart R _612295) (@percent _612295 c x) _1123276)).
Lemma subspace_def {_612295 : Type'} : (@subspace _612295) = (fun _1123276 : (cart R _612295) -> Prop => (@IN (cart R _612295) (@vec _612295 (NUMERAL 0%N)) _1123276) /\ ((forall x : cart R _612295, forall y : cart R _612295, ((@IN (cart R _612295) x _1123276) /\ (@IN (cart R _612295) y _1123276)) -> @IN (cart R _612295) (@vector_add _612295 x y) _1123276) /\ (forall c : R, forall x : cart R _612295, (@IN (cart R _612295) x _1123276) -> @IN (cart R _612295) (@percent _612295 c x) _1123276))).
Proof. exact (eq_refl (@subspace _612295)). Qed.
Definition span {_612307 : Type'} : ((cart R _612307) -> Prop) -> (cart R _612307) -> Prop := fun _1123281 : (cart R _612307) -> Prop => @hull (cart R _612307) (@subspace _612307) _1123281.
Lemma span_def {_612307 : Type'} : (@span _612307) = (fun _1123281 : (cart R _612307) -> Prop => @hull (cart R _612307) (@subspace _612307) _1123281).
Proof. exact (eq_refl (@span _612307)). Qed.
Definition dependent {_612325 : Type'} : ((cart R _612325) -> Prop) -> Prop := fun _1123286 : (cart R _612325) -> Prop => exists a : cart R _612325, (@IN (cart R _612325) a _1123286) /\ (@IN (cart R _612325) a (@span _612325 (@DELETE (cart R _612325) _1123286 a))).
Lemma dependent_def {_612325 : Type'} : (@dependent _612325) = (fun _1123286 : (cart R _612325) -> Prop => exists a : cart R _612325, (@IN (cart R _612325) a _1123286) /\ (@IN (cart R _612325) a (@span _612325 (@DELETE (cart R _612325) _1123286 a)))).
Proof. exact (eq_refl (@dependent _612325)). Qed.
Definition independent {_612335 : Type'} : ((cart R _612335) -> Prop) -> Prop := fun _1123291 : (cart R _612335) -> Prop => ~ (@dependent _612335 _1123291).
Lemma independent_def {_612335 : Type'} : (@independent _612335) = (fun _1123291 : (cart R _612335) -> Prop => ~ (@dependent _612335 _1123291)).
Proof. exact (eq_refl (@independent _612335)). Qed.
Definition dim {N' : Type'} : ((cart R N') -> Prop) -> N := fun _1132010 : (cart R N') -> Prop => @ε N (fun n : N => exists b : (cart R N') -> Prop, (@SUBSET (cart R N') b _1132010) /\ ((@independent N' b) /\ ((@SUBSET (cart R N') _1132010 (@span N' b)) /\ (@HAS_SIZE (cart R N') b n)))).
Lemma dim_def {N' : Type'} : (@dim N') = (fun _1132010 : (cart R N') -> Prop => @ε N (fun n : N => exists b : (cart R N') -> Prop, (@SUBSET (cart R N') b _1132010) /\ ((@independent N' b) /\ ((@SUBSET (cart R N') _1132010 (@span N' b)) /\ (@HAS_SIZE (cart R N') b n))))).
Proof. exact (eq_refl (@dim N')). Qed.
Definition euclidean_matroid {N' : Type'} : Matroid (cart R N') := @matroid (cart R N') (@pair ((cart R N') -> Prop) (((cart R N') -> Prop) -> (cart R N') -> Prop) (@UNIV (cart R N')) (@span N')).
Lemma euclidean_matroid_def {N' : Type'} : (@euclidean_matroid N') = (@matroid (cart R N') (@pair ((cart R N') -> Prop) (((cart R N') -> Prop) -> (cart R N') -> Prop) (@UNIV (cart R N')) (@span N'))).
Proof. exact (eq_refl (@euclidean_matroid N')). Qed.
Definition rowvector {N' : Type'} : (cart R N') -> cart (cart R N') unit := fun _1147082 : cart R N' => @lambda (cart R N') unit (fun i : N => @lambda R N' (fun j : N => @dollar R N' _1147082 j)).
Lemma rowvector_def {N' : Type'} : (@rowvector N') = (fun _1147082 : cart R N' => @lambda (cart R N') unit (fun i : N => @lambda R N' (fun j : N => @dollar R N' _1147082 j))).
Proof. exact (eq_refl (@rowvector N')). Qed.
Definition columnvector {N' : Type'} : (cart R N') -> cart (cart R unit) N' := fun _1147087 : cart R N' => @lambda (cart R unit) N' (fun i : N => @lambda R unit (fun j : N => @dollar R N' _1147087 i)).
Lemma columnvector_def {N' : Type'} : (@columnvector N') = (fun _1147087 : cart R N' => @lambda (cart R unit) N' (fun i : N => @lambda R unit (fun j : N => @dollar R N' _1147087 i))).
Proof. exact (eq_refl (@columnvector N')). Qed.
Definition rank {M N' : Type'} : (cart (cart R M) N') -> N := fun _1147313 : cart (cart R M) N' => @dim N' (@columns N' M _1147313).
Lemma rank_def {M N' : Type'} : (@rank M N') = (fun _1147313 : cart (cart R M) N' => @dim N' (@columns N' M _1147313)).
Proof. exact (eq_refl (@rank M N')). Qed.
Definition matrix_inv {M N' : Type'} : (cart (cart R M) N') -> cart (cart R N') M := fun _1165244 : cart (cart R M) N' => @matrix N' M (fun y : cart R N' => @ε (cart R M) (fun x : cart R M => (forall w : cart R M, ((@matrix_vector_mul N' M _1165244 w) = (@vec N' (NUMERAL 0%N))) -> @orthogonal M x w) /\ (forall z : cart R M, @orthogonal N' (@vector_sub N' y (@matrix_vector_mul N' M _1165244 x)) (@matrix_vector_mul N' M _1165244 z)))).
Lemma matrix_inv_def {M N' : Type'} : (@matrix_inv M N') = (fun _1165244 : cart (cart R M) N' => @matrix N' M (fun y : cart R N' => @ε (cart R M) (fun x : cart R M => (forall w : cart R M, ((@matrix_vector_mul N' M _1165244 w) = (@vec N' (NUMERAL 0%N))) -> @orthogonal M x w) /\ (forall z : cart R M, @orthogonal N' (@vector_sub N' y (@matrix_vector_mul N' M _1165244 x)) (@matrix_vector_mul N' M _1165244 z))))).
Proof. exact (eq_refl (@matrix_inv M N')). Qed.
Definition infnorm {N' : Type'} : (cart R N') -> R := @ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (cart R N') -> R) (fun infnorm' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (cart R N') -> R => forall _1167722 : prod N (prod N (prod N (prod N (prod N (prod N N))))), forall x : cart R N', (infnorm' _1167722 x) = (sup (@GSPEC R (fun GEN_PVAR_2493 : R => exists i : N, @SETSPEC R GEN_PVAR_2493 ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) (Rabs (@dollar R N' x i)))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))).
Lemma infnorm_def {N' : Type'} : (@infnorm N') = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (cart R N') -> R) (fun infnorm' : (prod N (prod N (prod N (prod N (prod N (prod N N)))))) -> (cart R N') -> R => forall _1167722 : prod N (prod N (prod N (prod N (prod N (prod N N))))), forall x : cart R N', (infnorm' _1167722 x) = (sup (@GSPEC R (fun GEN_PVAR_2493 : R => exists i : N, @SETSPEC R GEN_PVAR_2493 ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) (Rabs (@dollar R N' x i)))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))).
Proof. exact (eq_refl (@infnorm N')). Qed.
Definition collinear {_645714 : Type'} : ((cart R _645714) -> Prop) -> Prop := fun _1168150 : (cart R _645714) -> Prop => exists u : cart R _645714, forall x : cart R _645714, forall y : cart R _645714, ((@IN (cart R _645714) x _1168150) /\ (@IN (cart R _645714) y _1168150)) -> exists c : R, (@vector_sub _645714 x y) = (@percent _645714 c u).
Lemma collinear_def {_645714 : Type'} : (@collinear _645714) = (fun _1168150 : (cart R _645714) -> Prop => exists u : cart R _645714, forall x : cart R _645714, forall y : cart R _645714, ((@IN (cart R _645714) x _1168150) /\ (@IN (cart R _645714) y _1168150)) -> exists c : R, (@vector_sub _645714 x y) = (@percent _645714 c u)).
Proof. exact (eq_refl (@collinear _645714)). Qed.
Definition between {_647401 : Type'} : (cart R _647401) -> (prod (cart R _647401) (cart R _647401)) -> Prop := fun _1169678 : cart R _647401 => fun _1169679 : prod (cart R _647401) (cart R _647401) => (@distance _647401 (@pair (cart R _647401) (cart R _647401) (@fst (cart R _647401) (cart R _647401) _1169679) (@snd (cart R _647401) (cart R _647401) _1169679))) = (Rplus (@distance _647401 (@pair (cart R _647401) (cart R _647401) (@fst (cart R _647401) (cart R _647401) _1169679) _1169678)) (@distance _647401 (@pair (cart R _647401) (cart R _647401) _1169678 (@snd (cart R _647401) (cart R _647401) _1169679)))).
Lemma between_def {_647401 : Type'} : (@between _647401) = (fun _1169678 : cart R _647401 => fun _1169679 : prod (cart R _647401) (cart R _647401) => (@distance _647401 (@pair (cart R _647401) (cart R _647401) (@fst (cart R _647401) (cart R _647401) _1169679) (@snd (cart R _647401) (cart R _647401) _1169679))) = (Rplus (@distance _647401 (@pair (cart R _647401) (cart R _647401) (@fst (cart R _647401) (cart R _647401) _1169679) _1169678)) (@distance _647401 (@pair (cart R _647401) (cart R _647401) _1169678 (@snd (cart R _647401) (cart R _647401) _1169679))))).
Proof. exact (eq_refl (@between _647401)). Qed.
Definition midpoint {_648572 : Type'} : (prod (cart R _648572) (cart R _648572)) -> cart R _648572 := fun _1170342 : prod (cart R _648572) (cart R _648572) => @percent _648572 (Rinv (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))) (@vector_add _648572 (@fst (cart R _648572) (cart R _648572) _1170342) (@snd (cart R _648572) (cart R _648572) _1170342)).
Lemma midpoint_def {_648572 : Type'} : (@midpoint _648572) = (fun _1170342 : prod (cart R _648572) (cart R _648572) => @percent _648572 (Rinv (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))) (@vector_add _648572 (@fst (cart R _648572) (cart R _648572) _1170342) (@snd (cart R _648572) (cart R _648572) _1170342))).
Proof. exact (eq_refl (@midpoint _648572)). Qed.
Definition open_interval {N' : Type'} : (prod (cart R N') (cart R N')) -> (cart R N') -> Prop := fun _1170425 : prod (cart R N') (cart R N') => @GSPEC (cart R N') (fun GEN_PVAR_2498 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2498 (forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> (Rlt (@dollar R N' (@fst (cart R N') (cart R N') _1170425) i) (@dollar R N' x i)) /\ (Rlt (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') _1170425) i))) x).
Lemma open_interval_def {N' : Type'} : (@open_interval N') = (fun _1170425 : prod (cart R N') (cart R N') => @GSPEC (cart R N') (fun GEN_PVAR_2498 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2498 (forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> (Rlt (@dollar R N' (@fst (cart R N') (cart R N') _1170425) i) (@dollar R N' x i)) /\ (Rlt (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') _1170425) i))) x)).
Proof. exact (eq_refl (@open_interval N')). Qed.
Definition closed_interval {N' : Type'} : (list (prod (cart R N') (cart R N'))) -> (cart R N') -> Prop := fun _1170434 : list (prod (cart R N') (cart R N')) => @GSPEC (cart R N') (fun GEN_PVAR_2499 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2499 (forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> (Rle (@dollar R N' (@fst (cart R N') (cart R N') (@hd (prod (cart R N') (cart R N')) _1170434)) i) (@dollar R N' x i)) /\ (Rle (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') (@hd (prod (cart R N') (cart R N')) _1170434)) i))) x).
Lemma closed_interval_def {N' : Type'} : (@closed_interval N') = (fun _1170434 : list (prod (cart R N') (cart R N')) => @GSPEC (cart R N') (fun GEN_PVAR_2499 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2499 (forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> (Rle (@dollar R N' (@fst (cart R N') (cart R N') (@hd (prod (cart R N') (cart R N')) _1170434)) i) (@dollar R N' x i)) /\ (Rle (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') (@hd (prod (cart R N') (cart R N')) _1170434)) i))) x)).
Proof. exact (eq_refl (@closed_interval N')). Qed.
Definition trace {N' : Type'} : (cart (cart R N') N') -> R := fun _1177860 : cart (cart R N') N' => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => @dollar R N' (@dollar (cart R N') N' _1177860 i) i).
Lemma trace_def {N' : Type'} : (@trace N') = (fun _1177860 : cart (cart R N') N' => @sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => @dollar R N' (@dollar (cart R N') N' _1177860 i) i)).
Proof. exact (eq_refl (@trace N')). Qed.
Definition det {N' : Type'} : (cart (cart R N') N') -> R := fun _1177873 : cart (cart R N') N' => @sum (N -> N) (@GSPEC (N -> N) (fun GEN_PVAR_2514 : N -> N => exists p : N -> N, @SETSPEC (N -> N) GEN_PVAR_2514 (@permutes N p (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) p)) (fun p : N -> N => Rmult (@sign N p) (@product N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => @dollar R N' (@dollar (cart R N') N' _1177873 i) (p i)))).
Lemma det_def {N' : Type'} : (@det N') = (fun _1177873 : cart (cart R N') N' => @sum (N -> N) (@GSPEC (N -> N) (fun GEN_PVAR_2514 : N -> N => exists p : N -> N, @SETSPEC (N -> N) GEN_PVAR_2514 (@permutes N p (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) p)) (fun p : N -> N => Rmult (@sign N p) (@product N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => @dollar R N' (@dollar (cart R N') N' _1177873 i) (p i))))).
Proof. exact (eq_refl (@det N')). Qed.
Definition cofactor {N' : Type'} : (cart (cart R N') N') -> cart (cart R N') N' := fun _1183022 : cart (cart R N') N' => @lambda (cart R N') N' (fun i : N => @lambda R N' (fun j : N => @det N' (@lambda (cart R N') N' (fun k : N => @lambda R N' (fun l : N => @COND R ((k = i) /\ (l = j)) (R_of_N (NUMERAL (BIT1 0%N))) (@COND R ((k = i) \/ (l = j)) (R_of_N (NUMERAL 0%N)) (@dollar R N' (@dollar (cart R N') N' _1183022 k) l))))))).
Lemma cofactor_def {N' : Type'} : (@cofactor N') = (fun _1183022 : cart (cart R N') N' => @lambda (cart R N') N' (fun i : N => @lambda R N' (fun j : N => @det N' (@lambda (cart R N') N' (fun k : N => @lambda R N' (fun l : N => @COND R ((k = i) /\ (l = j)) (R_of_N (NUMERAL (BIT1 0%N))) (@COND R ((k = i) \/ (l = j)) (R_of_N (NUMERAL 0%N)) (@dollar R N' (@dollar (cart R N') N' _1183022 k) l)))))))).
Proof. exact (eq_refl (@cofactor N')). Qed.
Definition diagonal_matrix {M N' : Type'} : (cart (cart R N') M) -> Prop := fun _1189826 : cart (cart R N') M => forall i : N, forall j : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ ((N.le i (@dimindex M (@UNIV M))) /\ ((N.le (NUMERAL (BIT1 0%N)) j) /\ ((N.le j (@dimindex N' (@UNIV N'))) /\ (~ (i = j)))))) -> (@dollar R N' (@dollar (cart R N') M _1189826 i) j) = (R_of_N (NUMERAL 0%N)).
Lemma diagonal_matrix_def {M N' : Type'} : (@diagonal_matrix M N') = (fun _1189826 : cart (cart R N') M => forall i : N, forall j : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ ((N.le i (@dimindex M (@UNIV M))) /\ ((N.le (NUMERAL (BIT1 0%N)) j) /\ ((N.le j (@dimindex N' (@UNIV N'))) /\ (~ (i = j)))))) -> (@dollar R N' (@dollar (cart R N') M _1189826 i) j) = (R_of_N (NUMERAL 0%N))).
Proof. exact (eq_refl (@diagonal_matrix M N')). Qed.
Definition positive_semidefinite {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1190646 : cart (cart R N') N' => (@symmetric_matrix N' _1190646) /\ (forall x : cart R N', Rle (R_of_N (NUMERAL 0%N)) (@dot N' x (@matrix_vector_mul N' N' _1190646 x))).
Lemma positive_semidefinite_def {N' : Type'} : (@positive_semidefinite N') = (fun _1190646 : cart (cart R N') N' => (@symmetric_matrix N' _1190646) /\ (forall x : cart R N', Rle (R_of_N (NUMERAL 0%N)) (@dot N' x (@matrix_vector_mul N' N' _1190646 x)))).
Proof. exact (eq_refl (@positive_semidefinite N')). Qed.
Definition positive_definite {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1191270 : cart (cart R N') N' => (@symmetric_matrix N' _1191270) /\ (forall x : cart R N', (~ (x = (@vec N' (NUMERAL 0%N)))) -> Rlt (R_of_N (NUMERAL 0%N)) (@dot N' x (@matrix_vector_mul N' N' _1191270 x))).
Lemma positive_definite_def {N' : Type'} : (@positive_definite N') = (fun _1191270 : cart (cart R N') N' => (@symmetric_matrix N' _1191270) /\ (forall x : cart R N', (~ (x = (@vec N' (NUMERAL 0%N)))) -> Rlt (R_of_N (NUMERAL 0%N)) (@dot N' x (@matrix_vector_mul N' N' _1191270 x)))).
Proof. exact (eq_refl (@positive_definite N')). Qed.
Definition orthogonal_transformation {N' : Type'} : ((cart R N') -> cart R N') -> Prop := fun _1191979 : (cart R N') -> cart R N' => (@linear N' N' _1191979) /\ (forall v : cart R N', forall w : cart R N', (@dot N' (_1191979 v) (_1191979 w)) = (@dot N' v w)).
Lemma orthogonal_transformation_def {N' : Type'} : (@orthogonal_transformation N') = (fun _1191979 : (cart R N') -> cart R N' => (@linear N' N' _1191979) /\ (forall v : cart R N', forall w : cart R N', (@dot N' (_1191979 v) (_1191979 w)) = (@dot N' v w))).
Proof. exact (eq_refl (@orthogonal_transformation N')). Qed.
Definition orthogonal_matrix {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1192144 : cart (cart R N') N' => ((@matrix_mul N' N' N' (@transp N' N' _1192144) _1192144) = (@mat N' N' (NUMERAL (BIT1 0%N)))) /\ ((@matrix_mul N' N' N' _1192144 (@transp N' N' _1192144)) = (@mat N' N' (NUMERAL (BIT1 0%N)))).
Lemma orthogonal_matrix_def {N' : Type'} : (@orthogonal_matrix N') = (fun _1192144 : cart (cart R N') N' => ((@matrix_mul N' N' N' (@transp N' N' _1192144) _1192144) = (@mat N' N' (NUMERAL (BIT1 0%N)))) /\ ((@matrix_mul N' N' N' _1192144 (@transp N' N' _1192144)) = (@mat N' N' (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl (@orthogonal_matrix N')). Qed.
Definition rotation_matrix {_680518 : Type'} : (cart (cart R _680518) _680518) -> Prop := fun _1200201 : cart (cart R _680518) _680518 => (@orthogonal_matrix _680518 _1200201) /\ ((@det _680518 _1200201) = (R_of_N (NUMERAL (BIT1 0%N)))).
Lemma rotation_matrix_def {_680518 : Type'} : (@rotation_matrix _680518) = (fun _1200201 : cart (cart R _680518) _680518 => (@orthogonal_matrix _680518 _1200201) /\ ((@det _680518 _1200201) = (R_of_N (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl (@rotation_matrix _680518)). Qed.
Definition rotoinversion_matrix {_680533 : Type'} : (cart (cart R _680533) _680533) -> Prop := fun _1200206 : cart (cart R _680533) _680533 => (@orthogonal_matrix _680533 _1200206) /\ ((@det _680533 _1200206) = (Ropp (R_of_N (NUMERAL (BIT1 0%N))))).
Lemma rotoinversion_matrix_def {_680533 : Type'} : (@rotoinversion_matrix _680533) = (fun _1200206 : cart (cart R _680533) _680533 => (@orthogonal_matrix _680533 _1200206) /\ ((@det _680533 _1200206) = (Ropp (R_of_N (NUMERAL (BIT1 0%N)))))).
Proof. exact (eq_refl (@rotoinversion_matrix _680533)). Qed.
Definition reflect_along {N' : Type'} : (cart R N') -> (cart R N') -> cart R N' := fun _1204900 : cart R N' => fun _1204901 : cart R N' => @vector_sub N' _1204901 (@percent N' (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) (Rdiv (@dot N' _1204901 _1204900) (@dot N' _1204900 _1204900))) _1204900).
Lemma reflect_along_def {N' : Type'} : (@reflect_along N') = (fun _1204900 : cart R N' => fun _1204901 : cart R N' => @vector_sub N' _1204901 (@percent N' (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) (Rdiv (@dot N' _1204901 _1204900) (@dot N' _1204900 _1204900))) _1204900)).
Proof. exact (eq_refl (@reflect_along N')). Qed.
Definition _open {_688489 : Type'} : ((cart R _688489) -> Prop) -> Prop := fun _1207063 : (cart R _688489) -> Prop => forall x : cart R _688489, (@IN (cart R _688489) x _1207063) -> exists e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) /\ (forall x' : cart R _688489, (Rlt (@distance _688489 (@pair (cart R _688489) (cart R _688489) x' x)) e) -> @IN (cart R _688489) x' _1207063).
Lemma _open_def {_688489 : Type'} : (@_open _688489) = (fun _1207063 : (cart R _688489) -> Prop => forall x : cart R _688489, (@IN (cart R _688489) x _1207063) -> exists e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) /\ (forall x' : cart R _688489, (Rlt (@distance _688489 (@pair (cart R _688489) (cart R _688489) x' x)) e) -> @IN (cart R _688489) x' _1207063)).
Proof. exact (eq_refl (@_open _688489)). Qed.
Definition euclidean {_688505 : Type'} : Topology (cart R _688505) := @topology (cart R _688505) (@_open _688505).
Lemma euclidean_def {_688505 : Type'} : (@euclidean _688505) = (@topology (cart R _688505) (@_open _688505)).
Proof. exact (eq_refl (@euclidean _688505)). Qed.
Definition euclidean_metric {N' : Type'} : Metric (cart R N') := @metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@UNIV (cart R N')) (@distance N')).
Lemma euclidean_metric_def {N' : Type'} : (@euclidean_metric N') = (@metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@UNIV (cart R N')) (@distance N'))).
Proof. exact (eq_refl (@euclidean_metric N')). Qed.
Definition closed {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1207093 : (cart R N') -> Prop => @_open N' (@DIFF (cart R N') (@UNIV (cart R N')) _1207093).
Lemma closed_def {N' : Type'} : (@closed N') = (fun _1207093 : (cart R N') -> Prop => @_open N' (@DIFF (cart R N') (@UNIV (cart R N')) _1207093)).
Proof. exact (eq_refl (@closed N')). Qed.
Definition ball {_690257 : Type'} : (prod (cart R _690257) R) -> (cart R _690257) -> Prop := fun _1207490 : prod (cart R _690257) R => @GSPEC (cart R _690257) (fun GEN_PVAR_2710 : cart R _690257 => exists y : cart R _690257, @SETSPEC (cart R _690257) GEN_PVAR_2710 (Rlt (@distance _690257 (@pair (cart R _690257) (cart R _690257) (@fst (cart R _690257) R _1207490) y)) (@snd (cart R _690257) R _1207490)) y).
Lemma ball_def {_690257 : Type'} : (@ball _690257) = (fun _1207490 : prod (cart R _690257) R => @GSPEC (cart R _690257) (fun GEN_PVAR_2710 : cart R _690257 => exists y : cart R _690257, @SETSPEC (cart R _690257) GEN_PVAR_2710 (Rlt (@distance _690257 (@pair (cart R _690257) (cart R _690257) (@fst (cart R _690257) R _1207490) y)) (@snd (cart R _690257) R _1207490)) y)).
Proof. exact (eq_refl (@ball _690257)). Qed.
Definition cball {_690350 : Type'} : (prod (cart R _690350) R) -> (cart R _690350) -> Prop := fun _1207499 : prod (cart R _690350) R => @GSPEC (cart R _690350) (fun GEN_PVAR_2711 : cart R _690350 => exists y : cart R _690350, @SETSPEC (cart R _690350) GEN_PVAR_2711 (Rle (@distance _690350 (@pair (cart R _690350) (cart R _690350) (@fst (cart R _690350) R _1207499) y)) (@snd (cart R _690350) R _1207499)) y).
Lemma cball_def {_690350 : Type'} : (@cball _690350) = (fun _1207499 : prod (cart R _690350) R => @GSPEC (cart R _690350) (fun GEN_PVAR_2711 : cart R _690350 => exists y : cart R _690350, @SETSPEC (cart R _690350) GEN_PVAR_2711 (Rle (@distance _690350 (@pair (cart R _690350) (cart R _690350) (@fst (cart R _690350) R _1207499) y)) (@snd (cart R _690350) R _1207499)) y)).
Proof. exact (eq_refl (@cball _690350)). Qed.
Definition sphere {_690443 : Type'} : (prod (cart R _690443) R) -> (cart R _690443) -> Prop := fun _1207508 : prod (cart R _690443) R => @GSPEC (cart R _690443) (fun GEN_PVAR_2712 : cart R _690443 => exists y : cart R _690443, @SETSPEC (cart R _690443) GEN_PVAR_2712 ((@distance _690443 (@pair (cart R _690443) (cart R _690443) (@fst (cart R _690443) R _1207508) y)) = (@snd (cart R _690443) R _1207508)) y).
Lemma sphere_def {_690443 : Type'} : (@sphere _690443) = (fun _1207508 : prod (cart R _690443) R => @GSPEC (cart R _690443) (fun GEN_PVAR_2712 : cart R _690443 => exists y : cart R _690443, @SETSPEC (cart R _690443) GEN_PVAR_2712 ((@distance _690443 (@pair (cart R _690443) (cart R _690443) (@fst (cart R _690443) R _1207508) y)) = (@snd (cart R _690443) R _1207508)) y)).
Proof. exact (eq_refl (@sphere _690443)). Qed.
Definition manhattan {N' : Type'} : Metric (cart R N') := @metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@UNIV (cart R N')) (@GABS ((prod (cart R N') (cart R N')) -> R) (fun f : (prod (cart R N') (cart R N')) -> R => forall x : cart R N', forall y : cart R N', @GEQ R (f (@pair (cart R N') (cart R N') x y)) (@sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => Rabs (Rminus (@dollar R N' x i) (@dollar R N' y i))))))).
Lemma manhattan_def {N' : Type'} : (@manhattan N') = (@metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@UNIV (cart R N')) (@GABS ((prod (cart R N') (cart R N')) -> R) (fun f : (prod (cart R N') (cart R N')) -> R => forall x : cart R N', forall y : cart R N', @GEQ R (f (@pair (cart R N') (cart R N') x y)) (@sum N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => Rabs (Rminus (@dollar R N' x i) (@dollar R N' y i)))))))).
Proof. exact (eq_refl (@manhattan N')). Qed.
Definition closed_segment {_693754 : Type'} : (list (prod (cart R _693754) (cart R _693754))) -> (cart R _693754) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) -> (list (prod (cart R _693754) (cart R _693754))) -> (cart R _693754) -> Prop) (fun closed_segment' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) -> (list (prod (cart R _693754) (cart R _693754))) -> (cart R _693754) -> Prop => forall _1209706 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))), forall a : cart R _693754, forall b : cart R _693754, (closed_segment' _1209706 (@cons (prod (cart R _693754) (cart R _693754)) (@pair (cart R _693754) (cart R _693754) a b) (@nil (prod (cart R _693754) (cart R _693754))))) = (@GSPEC (cart R _693754) (fun GEN_PVAR_2714 : cart R _693754 => exists u : R, @SETSPEC (cart R _693754) GEN_PVAR_2714 ((Rle (R_of_N (NUMERAL 0%N)) u) /\ (Rle u (R_of_N (NUMERAL (BIT1 0%N))))) (@vector_add _693754 (@percent _693754 (Rminus (R_of_N (NUMERAL (BIT1 0%N))) u) a) (@percent _693754 u b))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))))))).
Lemma closed_segment_def {_693754 : Type'} : (@closed_segment _693754) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) -> (list (prod (cart R _693754) (cart R _693754))) -> (cart R _693754) -> Prop) (fun closed_segment' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) -> (list (prod (cart R _693754) (cart R _693754))) -> (cart R _693754) -> Prop => forall _1209706 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))), forall a : cart R _693754, forall b : cart R _693754, (closed_segment' _1209706 (@cons (prod (cart R _693754) (cart R _693754)) (@pair (cart R _693754) (cart R _693754) a b) (@nil (prod (cart R _693754) (cart R _693754))))) = (@GSPEC (cart R _693754) (fun GEN_PVAR_2714 : cart R _693754 => exists u : R, @SETSPEC (cart R _693754) GEN_PVAR_2714 ((Rle (R_of_N (NUMERAL 0%N)) u) /\ (Rle u (R_of_N (NUMERAL (BIT1 0%N))))) (@vector_add _693754 (@percent _693754 (Rminus (R_of_N (NUMERAL (BIT1 0%N))) u) a) (@percent _693754 u b))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))))))))).
Proof. exact (eq_refl (@closed_segment _693754)). Qed.
Definition open_segment {_693771 : Type'} : (prod (cart R _693771) (cart R _693771)) -> (cart R _693771) -> Prop := fun _1209707 : prod (cart R _693771) (cart R _693771) => @DIFF (cart R _693771) (@closed_segment _693771 (@cons (prod (cart R _693771) (cart R _693771)) (@pair (cart R _693771) (cart R _693771) (@fst (cart R _693771) (cart R _693771) _1209707) (@snd (cart R _693771) (cart R _693771) _1209707)) (@nil (prod (cart R _693771) (cart R _693771))))) (@INSERT (cart R _693771) (@fst (cart R _693771) (cart R _693771) _1209707) (@INSERT (cart R _693771) (@snd (cart R _693771) (cart R _693771) _1209707) (@EMPTY (cart R _693771)))).
Lemma open_segment_def {_693771 : Type'} : (@open_segment _693771) = (fun _1209707 : prod (cart R _693771) (cart R _693771) => @DIFF (cart R _693771) (@closed_segment _693771 (@cons (prod (cart R _693771) (cart R _693771)) (@pair (cart R _693771) (cart R _693771) (@fst (cart R _693771) (cart R _693771) _1209707) (@snd (cart R _693771) (cart R _693771) _1209707)) (@nil (prod (cart R _693771) (cart R _693771))))) (@INSERT (cart R _693771) (@fst (cart R _693771) (cart R _693771) _1209707) (@INSERT (cart R _693771) (@snd (cart R _693771) (cart R _693771) _1209707) (@EMPTY (cart R _693771))))).
Proof. exact (eq_refl (@open_segment _693771)). Qed.
Definition connected {_696240 : Type'} : ((cart R _696240) -> Prop) -> Prop := fun _1210817 : (cart R _696240) -> Prop => ~ (exists e1 : (cart R _696240) -> Prop, exists e2 : (cart R _696240) -> Prop, (@_open _696240 e1) /\ ((@_open _696240 e2) /\ ((@SUBSET (cart R _696240) _1210817 (@UNION (cart R _696240) e1 e2)) /\ (((@INTER (cart R _696240) e1 (@INTER (cart R _696240) e2 _1210817)) = (@EMPTY (cart R _696240))) /\ ((~ ((@INTER (cart R _696240) e1 _1210817) = (@EMPTY (cart R _696240)))) /\ (~ ((@INTER (cart R _696240) e2 _1210817) = (@EMPTY (cart R _696240))))))))).
Lemma connected_def {_696240 : Type'} : (@connected _696240) = (fun _1210817 : (cart R _696240) -> Prop => ~ (exists e1 : (cart R _696240) -> Prop, exists e2 : (cart R _696240) -> Prop, (@_open _696240 e1) /\ ((@_open _696240 e2) /\ ((@SUBSET (cart R _696240) _1210817 (@UNION (cart R _696240) e1 e2)) /\ (((@INTER (cart R _696240) e1 (@INTER (cart R _696240) e2 _1210817)) = (@EMPTY (cart R _696240))) /\ ((~ ((@INTER (cart R _696240) e1 _1210817) = (@EMPTY (cart R _696240)))) /\ (~ ((@INTER (cart R _696240) e2 _1210817) = (@EMPTY (cart R _696240)))))))))).
Proof. exact (eq_refl (@connected _696240)). Qed.
Definition limit_point_of {_698817 : Type'} : (cart R _698817) -> ((cart R _698817) -> Prop) -> Prop := fun _1213240 : cart R _698817 => fun _1213241 : (cart R _698817) -> Prop => forall t : (cart R _698817) -> Prop, ((@IN (cart R _698817) _1213240 t) /\ (@_open _698817 t)) -> exists y : cart R _698817, (~ (y = _1213240)) /\ ((@IN (cart R _698817) y _1213241) /\ (@IN (cart R _698817) y t)).
Lemma limit_point_of_def {_698817 : Type'} : (@limit_point_of _698817) = (fun _1213240 : cart R _698817 => fun _1213241 : (cart R _698817) -> Prop => forall t : (cart R _698817) -> Prop, ((@IN (cart R _698817) _1213240 t) /\ (@_open _698817 t)) -> exists y : cart R _698817, (~ (y = _1213240)) /\ ((@IN (cart R _698817) y _1213241) /\ (@IN (cart R _698817) y t))).
Proof. exact (eq_refl (@limit_point_of _698817)). Qed.
Definition interior {_700106 : Type'} : ((cart R _700106) -> Prop) -> (cart R _700106) -> Prop := fun _1214074 : (cart R _700106) -> Prop => @GSPEC (cart R _700106) (fun GEN_PVAR_2727 : cart R _700106 => exists x : cart R _700106, @SETSPEC (cart R _700106) GEN_PVAR_2727 (exists t : (cart R _700106) -> Prop, (@_open _700106 t) /\ ((@IN (cart R _700106) x t) /\ (@SUBSET (cart R _700106) t _1214074))) x).
Lemma interior_def {_700106 : Type'} : (@interior _700106) = (fun _1214074 : (cart R _700106) -> Prop => @GSPEC (cart R _700106) (fun GEN_PVAR_2727 : cart R _700106 => exists x : cart R _700106, @SETSPEC (cart R _700106) GEN_PVAR_2727 (exists t : (cart R _700106) -> Prop, (@_open _700106 t) /\ ((@IN (cart R _700106) x t) /\ (@SUBSET (cart R _700106) t _1214074))) x)).
Proof. exact (eq_refl (@interior _700106)). Qed.
Definition closure {_700740 : Type'} : ((cart R _700740) -> Prop) -> (cart R _700740) -> Prop := fun _1214504 : (cart R _700740) -> Prop => @UNION (cart R _700740) _1214504 (@GSPEC (cart R _700740) (fun GEN_PVAR_2729 : cart R _700740 => exists x : cart R _700740, @SETSPEC (cart R _700740) GEN_PVAR_2729 (@limit_point_of _700740 x _1214504) x)).
Lemma closure_def {_700740 : Type'} : (@closure _700740) = (fun _1214504 : (cart R _700740) -> Prop => @UNION (cart R _700740) _1214504 (@GSPEC (cart R _700740) (fun GEN_PVAR_2729 : cart R _700740 => exists x : cart R _700740, @SETSPEC (cart R _700740) GEN_PVAR_2729 (@limit_point_of _700740 x _1214504) x))).
Proof. exact (eq_refl (@closure _700740)). Qed.
Definition frontier {_703071 : Type'} : ((cart R _703071) -> Prop) -> (cart R _703071) -> Prop := fun _1215236 : (cart R _703071) -> Prop => @DIFF (cart R _703071) (@closure _703071 _1215236) (@interior _703071 _1215236).
Lemma frontier_def {_703071 : Type'} : (@frontier _703071) = (fun _1215236 : (cart R _703071) -> Prop => @DIFF (cart R _703071) (@closure _703071 _1215236) (@interior _703071 _1215236)).
Proof. exact (eq_refl (@frontier _703071)). Qed.
Definition _at {_704829 : Type'} : (cart R _704829) -> net (cart R _704829) := fun _1217412 : cart R _704829 => @atpointof (cart R _704829) (@euclidean _704829) _1217412.
Lemma _at_def {_704829 : Type'} : (@_at _704829) = (fun _1217412 : cart R _704829 => @atpointof (cart R _704829) (@euclidean _704829) _1217412).
Proof. exact (eq_refl (@_at _704829)). Qed.
Definition at_infinity {_704872 : Type'} : net (cart R _704872) := @mk_net (cart R _704872) (@pair (((cart R _704872) -> Prop) -> Prop) ((cart R _704872) -> Prop) (@GSPEC ((cart R _704872) -> Prop) (fun GEN_PVAR_2739 : (cart R _704872) -> Prop => exists b : R, @SETSPEC ((cart R _704872) -> Prop) GEN_PVAR_2739 (@IN R b (@UNIV R)) (@GSPEC (cart R _704872) (fun GEN_PVAR_2738 : cart R _704872 => exists x : cart R _704872, @SETSPEC (cart R _704872) GEN_PVAR_2738 (Rle b (@vector_norm _704872 x)) x)))) (@EMPTY (cart R _704872))).
Lemma at_infinity_def {_704872 : Type'} : (@at_infinity _704872) = (@mk_net (cart R _704872) (@pair (((cart R _704872) -> Prop) -> Prop) ((cart R _704872) -> Prop) (@GSPEC ((cart R _704872) -> Prop) (fun GEN_PVAR_2739 : (cart R _704872) -> Prop => exists b : R, @SETSPEC ((cart R _704872) -> Prop) GEN_PVAR_2739 (@IN R b (@UNIV R)) (@GSPEC (cart R _704872) (fun GEN_PVAR_2738 : cart R _704872 => exists x : cart R _704872, @SETSPEC (cart R _704872) GEN_PVAR_2738 (Rle b (@vector_norm _704872 x)) x)))) (@EMPTY (cart R _704872)))).
Proof. exact (eq_refl (@at_infinity _704872)). Qed.
Definition at_posinfinity : net R := @mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2742 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2742 (@IN R a (@UNIV R)) (@GSPEC R (fun GEN_PVAR_2741 : R => exists x : R, @SETSPEC R GEN_PVAR_2741 (Rle a x) x)))) (@EMPTY R)).
Lemma at_posinfinity_def : at_posinfinity = (@mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2742 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2742 (@IN R a (@UNIV R)) (@GSPEC R (fun GEN_PVAR_2741 : R => exists x : R, @SETSPEC R GEN_PVAR_2741 (Rle a x) x)))) (@EMPTY R))).
Proof. exact (eq_refl at_posinfinity). Qed.
Definition at_neginfinity : net R := @mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2745 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2745 (@IN R a (@UNIV R)) (@GSPEC R (fun GEN_PVAR_2744 : R => exists x : R, @SETSPEC R GEN_PVAR_2744 (Rle x a) x)))) (@EMPTY R)).
Lemma at_neginfinity_def : at_neginfinity = (@mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2745 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2745 (@IN R a (@UNIV R)) (@GSPEC R (fun GEN_PVAR_2744 : R => exists x : R, @SETSPEC R GEN_PVAR_2744 (Rle x a) x)))) (@EMPTY R))).
Proof. exact (eq_refl at_neginfinity). Qed.
Definition in_direction {_705005 : Type'} : (cart R _705005) -> (cart R _705005) -> net (cart R _705005) := fun _1217417 : cart R _705005 => fun _1217418 : cart R _705005 => @within (cart R _705005) (@_at _705005 _1217417) (@GSPEC (cart R _705005) (fun GEN_PVAR_2746 : cart R _705005 => exists b : cart R _705005, @SETSPEC (cart R _705005) GEN_PVAR_2746 (exists c : R, (Rle (R_of_N (NUMERAL 0%N)) c) /\ ((@vector_sub _705005 b _1217417) = (@percent _705005 c _1217418))) b)).
Lemma in_direction_def {_705005 : Type'} : (@in_direction _705005) = (fun _1217417 : cart R _705005 => fun _1217418 : cart R _705005 => @within (cart R _705005) (@_at _705005 _1217417) (@GSPEC (cart R _705005) (fun GEN_PVAR_2746 : cart R _705005 => exists b : cart R _705005, @SETSPEC (cart R _705005) GEN_PVAR_2746 (exists c : R, (Rle (R_of_N (NUMERAL 0%N)) c) /\ ((@vector_sub _705005 b _1217417) = (@percent _705005 c _1217418))) b))).
Proof. exact (eq_refl (@in_direction _705005)). Qed.
Definition FImp {_706965 _706970 : Type'} : (_706970 -> cart R _706965) -> (cart R _706965) -> (net _706970) -> Prop := fun _1217848 : _706970 -> cart R _706965 => fun _1217849 : cart R _706965 => fun _1217850 : net _706970 => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> @eventually _706970 (fun x : _706970 => Rlt (@distance _706965 (@pair (cart R _706965) (cart R _706965) (_1217848 x) _1217849)) e) _1217850.
Lemma FImp_def {_706965 _706970 : Type'} : (@FImp _706965 _706970) = (fun _1217848 : _706970 -> cart R _706965 => fun _1217849 : cart R _706965 => fun _1217850 : net _706970 => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> @eventually _706970 (fun x : _706970 => Rlt (@distance _706965 (@pair (cart R _706965) (cart R _706965) (_1217848 x) _1217849)) e) _1217850).
Proof. exact (eq_refl (@FImp _706965 _706970)). Qed.
Definition lim {_707013 _707014 : Type'} : (net _707014) -> (_707014 -> cart R _707013) -> cart R _707013 := fun _1217869 : net _707014 => fun _1217870 : _707014 -> cart R _707013 => @ε (cart R _707013) (fun l : cart R _707013 => @FImp _707013 _707014 _1217870 l _1217869).
Lemma lim_def {_707013 _707014 : Type'} : (@lim _707013 _707014) = (fun _1217869 : net _707014 => fun _1217870 : _707014 -> cart R _707013 => @ε (cart R _707013) (fun l : cart R _707013 => @FImp _707013 _707014 _1217870 l _1217869)).
Proof. exact (eq_refl (@lim _707013 _707014)). Qed.
Definition condensation_point_of {_709863 : Type'} : (cart R _709863) -> ((cart R _709863) -> Prop) -> Prop := fun _1219011 : cart R _709863 => fun _1219012 : (cart R _709863) -> Prop => forall t : (cart R _709863) -> Prop, ((@IN (cart R _709863) _1219011 t) /\ (@_open _709863 t)) -> ~ (@COUNTABLE (cart R _709863) (@INTER (cart R _709863) _1219012 t)).
Lemma condensation_point_of_def {_709863 : Type'} : (@condensation_point_of _709863) = (fun _1219011 : cart R _709863 => fun _1219012 : (cart R _709863) -> Prop => forall t : (cart R _709863) -> Prop, ((@IN (cart R _709863) _1219011 t) /\ (@_open _709863 t)) -> ~ (@COUNTABLE (cart R _709863) (@INTER (cart R _709863) _1219012 t))).
Proof. exact (eq_refl (@condensation_point_of _709863)). Qed.
Definition bounded {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1222599 : (cart R N') -> Prop => exists a : R, forall x : cart R N', (@IN (cart R N') x _1222599) -> Rle (@vector_norm N' x) a.
Lemma bounded_def {N' : Type'} : (@bounded N') = (fun _1222599 : (cart R N') -> Prop => exists a : R, forall x : cart R N', (@IN (cart R N') x _1222599) -> Rle (@vector_norm N' x) a).
Proof. exact (eq_refl (@bounded N')). Qed.
Definition compact {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1224696 : (cart R N') -> Prop => forall f : N -> cart R N', (forall n : N, @IN (cart R N') (f n) _1224696) -> exists l : cart R N', exists r : N -> N, (@IN (cart R N') l _1224696) /\ ((forall m : N, forall n : N, (N.lt m n) -> N.lt (r m) (r n)) /\ (@FImp N' N (@o N N (cart R N') f r) l sequentially)).
Lemma compact_def {N' : Type'} : (@compact N') = (fun _1224696 : (cart R N') -> Prop => forall f : N -> cart R N', (forall n : N, @IN (cart R N') (f n) _1224696) -> exists l : cart R N', exists r : N -> N, (@IN (cart R N') l _1224696) /\ ((forall m : N, forall n : N, (N.lt m n) -> N.lt (r m) (r n)) /\ (@FImp N' N (@o N N (cart R N') f r) l sequentially))).
Proof. exact (eq_refl (@compact N')). Qed.
Definition cauchy {N' : Type'} : (N -> cart R N') -> Prop := fun _1224849 : N -> cart R N' => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists N'' : N, forall m : N, forall n : N, ((N.ge m N'') /\ (N.ge n N'')) -> Rlt (@distance N' (@pair (cart R N') (cart R N') (_1224849 m) (_1224849 n))) e.
Lemma cauchy_def {N' : Type'} : (@cauchy N') = (fun _1224849 : N -> cart R N' => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists N'' : N, forall m : N, forall n : N, ((N.ge m N'') /\ (N.ge n N'')) -> Rlt (@distance N' (@pair (cart R N') (cart R N') (_1224849 m) (_1224849 n))) e).
Proof. exact (eq_refl (@cauchy N')). Qed.
Definition complete {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1224856 : (cart R N') -> Prop => forall f : N -> cart R N', ((forall n : N, @IN (cart R N') (f n) _1224856) /\ (@cauchy N' f)) -> exists l : cart R N', (@IN (cart R N') l _1224856) /\ (@FImp N' N f l sequentially).
Lemma complete_def {N' : Type'} : (@complete N') = (fun _1224856 : (cart R N') -> Prop => forall f : N -> cart R N', ((forall n : N, @IN (cart R N') (f n) _1224856) /\ (@cauchy N' f)) -> exists l : cart R N', (@IN (cart R N') l _1224856) /\ (@FImp N' N f l sequentially)).
Proof. exact (eq_refl (@complete N')). Qed.
Definition continuous {_726086 _726088 : Type'} : (_726088 -> cart R _726086) -> (net _726088) -> Prop := fun _1227427 : _726088 -> cart R _726086 => fun _1227428 : net _726088 => @FImp _726086 _726088 _1227427 (_1227427 (@netlimit _726088 _1227428)) _1227428.
Lemma continuous_def {_726086 _726088 : Type'} : (@continuous _726086 _726088) = (fun _1227427 : _726088 -> cart R _726086 => fun _1227428 : net _726088 => @FImp _726086 _726088 _1227427 (_1227427 (@netlimit _726088 _1227428)) _1227428).
Proof. exact (eq_refl (@continuous _726086 _726088)). Qed.
Definition continuous_on {_727321 _727330 : Type'} : ((cart R _727321) -> cart R _727330) -> ((cart R _727321) -> Prop) -> Prop := fun _1228561 : (cart R _727321) -> cart R _727330 => fun _1228562 : (cart R _727321) -> Prop => forall x : cart R _727321, (@IN (cart R _727321) x _1228562) -> forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x' : cart R _727321, ((@IN (cart R _727321) x' _1228562) /\ (Rlt (@distance _727321 (@pair (cart R _727321) (cart R _727321) x' x)) d)) -> Rlt (@distance _727330 (@pair (cart R _727330) (cart R _727330) (_1228561 x') (_1228561 x))) e).
Lemma continuous_on_def {_727321 _727330 : Type'} : (@continuous_on _727321 _727330) = (fun _1228561 : (cart R _727321) -> cart R _727330 => fun _1228562 : (cart R _727321) -> Prop => forall x : cart R _727321, (@IN (cart R _727321) x _1228562) -> forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x' : cart R _727321, ((@IN (cart R _727321) x' _1228562) /\ (Rlt (@distance _727321 (@pair (cart R _727321) (cart R _727321) x' x)) d)) -> Rlt (@distance _727330 (@pair (cart R _727330) (cart R _727330) (_1228561 x') (_1228561 x))) e)).
Proof. exact (eq_refl (@continuous_on _727321 _727330)). Qed.
Definition uniformly_continuous_on {_727392 _727401 : Type'} : ((cart R _727392) -> cart R _727401) -> ((cart R _727392) -> Prop) -> Prop := fun _1228573 : (cart R _727392) -> cart R _727401 => fun _1228574 : (cart R _727392) -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x : cart R _727392, forall x' : cart R _727392, ((@IN (cart R _727392) x _1228574) /\ ((@IN (cart R _727392) x' _1228574) /\ (Rlt (@distance _727392 (@pair (cart R _727392) (cart R _727392) x' x)) d))) -> Rlt (@distance _727401 (@pair (cart R _727401) (cart R _727401) (_1228573 x') (_1228573 x))) e).
Lemma uniformly_continuous_on_def {_727392 _727401 : Type'} : (@uniformly_continuous_on _727392 _727401) = (fun _1228573 : (cart R _727392) -> cart R _727401 => fun _1228574 : (cart R _727392) -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x : cart R _727392, forall x' : cart R _727392, ((@IN (cart R _727392) x _1228574) /\ ((@IN (cart R _727392) x' _1228574) /\ (Rlt (@distance _727392 (@pair (cart R _727392) (cart R _727392) x' x)) d))) -> Rlt (@distance _727401 (@pair (cart R _727401) (cart R _727401) (_1228573 x') (_1228573 x))) e)).
Proof. exact (eq_refl (@uniformly_continuous_on _727392 _727401)). Qed.
Definition connected_component {_754293 : Type'} : ((cart R _754293) -> Prop) -> (cart R _754293) -> (cart R _754293) -> Prop := fun _1257668 : (cart R _754293) -> Prop => fun _1257669 : cart R _754293 => fun _1257670 : cart R _754293 => exists t : (cart R _754293) -> Prop, (@connected _754293 t) /\ ((@SUBSET (cart R _754293) t _1257668) /\ ((@IN (cart R _754293) _1257669 t) /\ (@IN (cart R _754293) _1257670 t))).
Lemma connected_component_def {_754293 : Type'} : (@connected_component _754293) = (fun _1257668 : (cart R _754293) -> Prop => fun _1257669 : cart R _754293 => fun _1257670 : cart R _754293 => exists t : (cart R _754293) -> Prop, (@connected _754293 t) /\ ((@SUBSET (cart R _754293) t _1257668) /\ ((@IN (cart R _754293) _1257669 t) /\ (@IN (cart R _754293) _1257670 t)))).
Proof. exact (eq_refl (@connected_component _754293)). Qed.
Definition components {N' : Type'} : ((cart R N') -> Prop) -> ((cart R N') -> Prop) -> Prop := fun _1258274 : (cart R N') -> Prop => @GSPEC ((cart R N') -> Prop) (fun GEN_PVAR_3076 : (cart R N') -> Prop => exists x : cart R N', @SETSPEC ((cart R N') -> Prop) GEN_PVAR_3076 (@IN (cart R N') x _1258274) (@connected_component N' _1258274 x)).
Lemma components_def {N' : Type'} : (@components N') = (fun _1258274 : (cart R N') -> Prop => @GSPEC ((cart R N') -> Prop) (fun GEN_PVAR_3076 : (cart R N') -> Prop => exists x : cart R N', @SETSPEC ((cart R N') -> Prop) GEN_PVAR_3076 (@IN (cart R N') x _1258274) (@connected_component N' _1258274 x))).
Proof. exact (eq_refl (@components N')). Qed.
Definition diameter {_764049 : Type'} : ((cart R _764049) -> Prop) -> R := fun _1265847 : (cart R _764049) -> Prop => @COND R (_1265847 = (@EMPTY (cart R _764049))) (R_of_N (NUMERAL 0%N)) (sup (@GSPEC R (fun GEN_PVAR_3108 : R => exists x : cart R _764049, exists y : cart R _764049, @SETSPEC R GEN_PVAR_3108 ((@IN (cart R _764049) x _1265847) /\ (@IN (cart R _764049) y _1265847)) (@vector_norm _764049 (@vector_sub _764049 x y))))).
Lemma diameter_def {_764049 : Type'} : (@diameter _764049) = (fun _1265847 : (cart R _764049) -> Prop => @COND R (_1265847 = (@EMPTY (cart R _764049))) (R_of_N (NUMERAL 0%N)) (sup (@GSPEC R (fun GEN_PVAR_3108 : R => exists x : cart R _764049, exists y : cart R _764049, @SETSPEC R GEN_PVAR_3108 ((@IN (cart R _764049) x _1265847) /\ (@IN (cart R _764049) y _1265847)) (@vector_norm _764049 (@vector_sub _764049 x y)))))).
Proof. exact (eq_refl (@diameter _764049)). Qed.
Definition is_interval {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1273091 : (cart R N') -> Prop => forall a : cart R N', forall b : cart R N', forall x : cart R N', ((@IN (cart R N') a _1273091) /\ ((@IN (cart R N') b _1273091) /\ (forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> ((Rle (@dollar R N' a i) (@dollar R N' x i)) /\ (Rle (@dollar R N' x i) (@dollar R N' b i))) \/ ((Rle (@dollar R N' b i) (@dollar R N' x i)) /\ (Rle (@dollar R N' x i) (@dollar R N' a i)))))) -> @IN (cart R N') x _1273091.
Lemma is_interval_def {N' : Type'} : (@is_interval N') = (fun _1273091 : (cart R N') -> Prop => forall a : cart R N', forall b : cart R N', forall x : cart R N', ((@IN (cart R N') a _1273091) /\ ((@IN (cart R N') b _1273091) /\ (forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> ((Rle (@dollar R N' a i) (@dollar R N' x i)) /\ (Rle (@dollar R N' x i) (@dollar R N' b i))) \/ ((Rle (@dollar R N' b i) (@dollar R N' x i)) /\ (Rle (@dollar R N' x i) (@dollar R N' a i)))))) -> @IN (cart R N') x _1273091).
Proof. exact (eq_refl (@is_interval N')). Qed.
Definition homeomorphism {_787178 _787179 : Type'} : (prod ((cart R _787178) -> Prop) ((cart R _787179) -> Prop)) -> (prod ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178)) -> Prop := fun _1280632 : prod ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) => fun _1280633 : prod ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) => (forall x : cart R _787178, (@IN (cart R _787178) x (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) -> (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 x)) = x) /\ (((@IMAGE (cart R _787178) (cart R _787179) (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) = (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) /\ ((@continuous_on _787178 _787179 (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) /\ ((forall y : cart R _787179, (@IN (cart R _787179) y (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) -> (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 y)) = y) /\ (((@IMAGE (cart R _787179) (cart R _787178) (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) = (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) /\ (@continuous_on _787179 _787178 (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)))))).
Lemma homeomorphism_def {_787178 _787179 : Type'} : (@homeomorphism _787178 _787179) = (fun _1280632 : prod ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) => fun _1280633 : prod ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) => (forall x : cart R _787178, (@IN (cart R _787178) x (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) -> (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 x)) = x) /\ (((@IMAGE (cart R _787178) (cart R _787179) (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) = (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) /\ ((@continuous_on _787178 _787179 (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) /\ ((forall y : cart R _787179, (@IN (cart R _787179) y (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) -> (@fst ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633 y)) = y) /\ (((@IMAGE (cart R _787179) (cart R _787178) (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) = (@fst ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632)) /\ (@continuous_on _787179 _787178 (@snd ((cart R _787178) -> cart R _787179) ((cart R _787179) -> cart R _787178) _1280633) (@snd ((cart R _787178) -> Prop) ((cart R _787179) -> Prop) _1280632))))))).
Proof. exact (eq_refl (@homeomorphism _787178 _787179)). Qed.
Definition homeomorphic {_787195 _787196 : Type'} : ((cart R _787196) -> Prop) -> ((cart R _787195) -> Prop) -> Prop := fun _1280654 : (cart R _787196) -> Prop => fun _1280655 : (cart R _787195) -> Prop => exists f : (cart R _787196) -> cart R _787195, exists g : (cart R _787195) -> cart R _787196, @homeomorphism _787196 _787195 (@pair ((cart R _787196) -> Prop) ((cart R _787195) -> Prop) _1280654 _1280655) (@pair ((cart R _787196) -> cart R _787195) ((cart R _787195) -> cart R _787196) f g).
Lemma homeomorphic_def {_787195 _787196 : Type'} : (@homeomorphic _787195 _787196) = (fun _1280654 : (cart R _787196) -> Prop => fun _1280655 : (cart R _787195) -> Prop => exists f : (cart R _787196) -> cart R _787195, exists g : (cart R _787195) -> cart R _787196, @homeomorphism _787196 _787195 (@pair ((cart R _787196) -> Prop) ((cart R _787195) -> Prop) _1280654 _1280655) (@pair ((cart R _787196) -> cart R _787195) ((cart R _787195) -> cart R _787196) f g)).
Proof. exact (eq_refl (@homeomorphic _787195 _787196)). Qed.
Definition sums {_819656 : Type'} : (N -> cart R _819656) -> (cart R _819656) -> (N -> Prop) -> Prop := fun _1332344 : N -> cart R _819656 => fun _1332345 : cart R _819656 => fun _1332346 : N -> Prop => @FImp _819656 N (fun n : N => @vsum N _819656 (@INTER N _1332346 (dotdot (NUMERAL 0%N) n)) _1332344) _1332345 sequentially.
Lemma sums_def {_819656 : Type'} : (@sums _819656) = (fun _1332344 : N -> cart R _819656 => fun _1332345 : cart R _819656 => fun _1332346 : N -> Prop => @FImp _819656 N (fun n : N => @vsum N _819656 (@INTER N _1332346 (dotdot (NUMERAL 0%N) n)) _1332344) _1332345 sequentially).
Proof. exact (eq_refl (@sums _819656)). Qed.
Definition infsum {_819675 : Type'} : (N -> Prop) -> (N -> cart R _819675) -> cart R _819675 := fun _1332365 : N -> Prop => fun _1332366 : N -> cart R _819675 => @ε (cart R _819675) (fun l : cart R _819675 => @sums _819675 _1332366 l _1332365).
Lemma infsum_def {_819675 : Type'} : (@infsum _819675) = (fun _1332365 : N -> Prop => fun _1332366 : N -> cart R _819675 => @ε (cart R _819675) (fun l : cart R _819675 => @sums _819675 _1332366 l _1332365)).
Proof. exact (eq_refl (@infsum _819675)). Qed.
Definition summable {_819689 : Type'} : (N -> Prop) -> (N -> cart R _819689) -> Prop := fun _1332377 : N -> Prop => fun _1332378 : N -> cart R _819689 => exists l : cart R _819689, @sums _819689 _1332378 l _1332377.
Lemma summable_def {_819689 : Type'} : (@summable _819689) = (fun _1332377 : N -> Prop => fun _1332378 : N -> cart R _819689 => exists l : cart R _819689, @sums _819689 _1332378 l _1332377).
Proof. exact (eq_refl (@summable _819689)). Qed.
Definition closest_point {_832524 : Type'} : ((cart R _832524) -> Prop) -> (cart R _832524) -> cart R _832524 := fun _1340306 : (cart R _832524) -> Prop => fun _1340307 : cart R _832524 => @ε (cart R _832524) (fun x : cart R _832524 => (@IN (cart R _832524) x _1340306) /\ (forall y : cart R _832524, (@IN (cart R _832524) y _1340306) -> Rle (@distance _832524 (@pair (cart R _832524) (cart R _832524) _1340307 x)) (@distance _832524 (@pair (cart R _832524) (cart R _832524) _1340307 y)))).
Lemma closest_point_def {_832524 : Type'} : (@closest_point _832524) = (fun _1340306 : (cart R _832524) -> Prop => fun _1340307 : cart R _832524 => @ε (cart R _832524) (fun x : cart R _832524 => (@IN (cart R _832524) x _1340306) /\ (forall y : cart R _832524, (@IN (cart R _832524) y _1340306) -> Rle (@distance _832524 (@pair (cart R _832524) (cart R _832524) _1340307 x)) (@distance _832524 (@pair (cart R _832524) (cart R _832524) _1340307 y))))).
Proof. exact (eq_refl (@closest_point _832524)). Qed.
Definition setdist {_833496 : Type'} : (prod ((cart R _833496) -> Prop) ((cart R _833496) -> Prop)) -> R := fun _1341166 : prod ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) => @COND R (((@fst ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166) = (@EMPTY (cart R _833496))) \/ ((@snd ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166) = (@EMPTY (cart R _833496)))) (R_of_N (NUMERAL 0%N)) (inf (@GSPEC R (fun GEN_PVAR_3332 : R => exists x : cart R _833496, exists y : cart R _833496, @SETSPEC R GEN_PVAR_3332 ((@IN (cart R _833496) x (@fst ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166)) /\ (@IN (cart R _833496) y (@snd ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166))) (@distance _833496 (@pair (cart R _833496) (cart R _833496) x y))))).
Lemma setdist_def {_833496 : Type'} : (@setdist _833496) = (fun _1341166 : prod ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) => @COND R (((@fst ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166) = (@EMPTY (cart R _833496))) \/ ((@snd ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166) = (@EMPTY (cart R _833496)))) (R_of_N (NUMERAL 0%N)) (inf (@GSPEC R (fun GEN_PVAR_3332 : R => exists x : cart R _833496, exists y : cart R _833496, @SETSPEC R GEN_PVAR_3332 ((@IN (cart R _833496) x (@fst ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166)) /\ (@IN (cart R _833496) y (@snd ((cart R _833496) -> Prop) ((cart R _833496) -> Prop) _1341166))) (@distance _833496 (@pair (cart R _833496) (cart R _833496) x y)))))).
Proof. exact (eq_refl (@setdist _833496)). Qed.
Definition hausdist {N' : Type'} : (prod ((cart R N') -> Prop) ((cart R N') -> Prop)) -> R := fun _1347090 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => @LET (R -> Prop) R (fun ds : R -> Prop => @LET_END R (@COND R ((~ (ds = (@EMPTY R))) /\ (exists b : R, forall d : R, (@IN R d ds) -> Rle d b)) (sup ds) (R_of_N (NUMERAL 0%N)))) (@UNION R (@GSPEC R (fun GEN_PVAR_3360 : R => exists x : cart R N', @SETSPEC R GEN_PVAR_3360 (@IN (cart R N') x (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') x (@EMPTY (cart R N'))) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090))))) (@GSPEC R (fun GEN_PVAR_3361 : R => exists y : cart R N', @SETSPEC R GEN_PVAR_3361 (@IN (cart R N') y (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') y (@EMPTY (cart R N'))) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090)))))).
Lemma hausdist_def {N' : Type'} : (@hausdist N') = (fun _1347090 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => @LET (R -> Prop) R (fun ds : R -> Prop => @LET_END R (@COND R ((~ (ds = (@EMPTY R))) /\ (exists b : R, forall d : R, (@IN R d ds) -> Rle d b)) (sup ds) (R_of_N (NUMERAL 0%N)))) (@UNION R (@GSPEC R (fun GEN_PVAR_3360 : R => exists x : cart R N', @SETSPEC R GEN_PVAR_3360 (@IN (cart R N') x (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') x (@EMPTY (cart R N'))) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090))))) (@GSPEC R (fun GEN_PVAR_3361 : R => exists y : cart R N', @SETSPEC R GEN_PVAR_3361 (@IN (cart R N') y (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') y (@EMPTY (cart R N'))) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1347090))))))).
Proof. exact (eq_refl (@hausdist N')). Qed.
Definition locally {N' : Type'} : (((cart R N') -> Prop) -> Prop) -> ((cart R N') -> Prop) -> Prop := fun _1369114 : ((cart R N') -> Prop) -> Prop => fun _1369115 : (cart R N') -> Prop => forall w : (cart R N') -> Prop, forall x : cart R N', ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1369115) w) /\ (@IN (cart R N') x w)) -> exists u : (cart R N') -> Prop, exists v : (cart R N') -> Prop, (@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1369115) u) /\ ((_1369114 v) /\ ((@IN (cart R N') x u) /\ ((@SUBSET (cart R N') u v) /\ (@SUBSET (cart R N') v w)))).
Lemma locally_def {N' : Type'} : (@locally N') = (fun _1369114 : ((cart R N') -> Prop) -> Prop => fun _1369115 : (cart R N') -> Prop => forall w : (cart R N') -> Prop, forall x : cart R N', ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1369115) w) /\ (@IN (cart R N') x w)) -> exists u : (cart R N') -> Prop, exists v : (cart R N') -> Prop, (@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1369115) u) /\ ((_1369114 v) /\ ((@IN (cart R N') x u) /\ ((@SUBSET (cart R N') u v) /\ (@SUBSET (cart R N') v w))))).
Proof. exact (eq_refl (@locally N')). Qed.
Definition gdelta {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1381315 : (cart R N') -> Prop => @INTERSECTION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@_open N') _1381315.
Lemma gdelta_def {N' : Type'} : (@gdelta N') = (fun _1381315 : (cart R N') -> Prop => @INTERSECTION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@_open N') _1381315).
Proof. exact (eq_refl (@gdelta N')). Qed.
Definition fsigma {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1381320 : (cart R N') -> Prop => @UNION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@closed N') _1381320.
Lemma fsigma_def {N' : Type'} : (@fsigma N') = (fun _1381320 : (cart R N') -> Prop => @UNION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@closed N') _1381320).
Proof. exact (eq_refl (@fsigma N')). Qed.
Definition borel {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun a : (cart R N') -> Prop => forall borel' : ((cart R N') -> Prop) -> Prop, (forall a' : (cart R N') -> Prop, ((@_open N' a') \/ ((exists s : (cart R N') -> Prop, (a' = (@DIFF (cart R N') (@UNIV (cart R N')) s)) /\ (borel' s)) \/ (exists u : ((cart R N') -> Prop) -> Prop, (a' = (@UNIONS (cart R N') u)) /\ ((@COUNTABLE ((cart R N') -> Prop) u) /\ (forall s : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) s u) -> borel' s))))) -> borel' a') -> borel' a.
Lemma borel_def {N' : Type'} : (@borel N') = (fun a : (cart R N') -> Prop => forall borel' : ((cart R N') -> Prop) -> Prop, (forall a' : (cart R N') -> Prop, ((@_open N' a') \/ ((exists s : (cart R N') -> Prop, (a' = (@DIFF (cart R N') (@UNIV (cart R N')) s)) /\ (borel' s)) \/ (exists u : ((cart R N') -> Prop) -> Prop, (a' = (@UNIONS (cart R N') u)) /\ ((@COUNTABLE ((cart R N') -> Prop) u) /\ (forall s : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) s u) -> borel' s))))) -> borel' a') -> borel' a).
Proof. exact (eq_refl (@borel N')). Qed.
Definition baire {M N' : Type'} : N -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop := @ε ((prod N (prod N (prod N (prod N N)))) -> N -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop) (fun baire' : (prod N (prod N (prod N (prod N N)))) -> N -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop => forall _1397567 : prod N (prod N (prod N (prod N N))), (forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1397567 (NUMERAL 0%N) s f) = (@continuous_on M N' f s)) /\ (forall n : N, forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1397567 (N.succ n) s f) = (exists g : N -> (cart R M) -> cart R N', (forall k : N, baire' _1397567 n s (g k)) /\ (forall x : cart R M, (@IN (cart R M) x s) -> @FImp N' N (fun k : N => g k x) (f x) sequentially)))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))).
Lemma baire_def {M N' : Type'} : (@baire M N') = (@ε ((prod N (prod N (prod N (prod N N)))) -> N -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop) (fun baire' : (prod N (prod N (prod N (prod N N)))) -> N -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop => forall _1397567 : prod N (prod N (prod N (prod N N))), (forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1397567 (NUMERAL 0%N) s f) = (@continuous_on M N' f s)) /\ (forall n : N, forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1397567 (N.succ n) s f) = (exists g : N -> (cart R M) -> cart R N', (forall k : N, baire' _1397567 n s (g k)) /\ (forall x : cart R M, (@IN (cart R M) x s) -> @FImp N' N (fun k : N => g k x) (f x) sequentially)))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))).
Proof. exact (eq_refl (@baire M N')). Qed.
Definition borel_measurable_on {M N' : Type'} : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun a0 : (cart R M) -> cart R N' => fun a1 : (cart R M) -> Prop => forall borel_measurable_on' : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop, (forall a0' : (cart R M) -> cart R N', forall a1' : (cart R M) -> Prop, ((@continuous_on M N' a0' a1') \/ (exists f : N -> (cart R M) -> cart R N', (forall n : N, borel_measurable_on' (f n) a1') /\ (forall x : cart R M, (@IN (cart R M) x a1') -> @FImp N' N (fun n : N => f n x) (a0' x) sequentially))) -> borel_measurable_on' a0' a1') -> borel_measurable_on' a0 a1.
Lemma borel_measurable_on_def {M N' : Type'} : (@borel_measurable_on M N') = (fun a0 : (cart R M) -> cart R N' => fun a1 : (cart R M) -> Prop => forall borel_measurable_on' : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop, (forall a0' : (cart R M) -> cart R N', forall a1' : (cart R M) -> Prop, ((@continuous_on M N' a0' a1') \/ (exists f : N -> (cart R M) -> cart R N', (forall n : N, borel_measurable_on' (f n) a1') /\ (forall x : cart R M, (@IN (cart R M) x a1') -> @FImp N' N (fun n : N => f n x) (a0' x) sequentially))) -> borel_measurable_on' a0' a1') -> borel_measurable_on' a0 a1).
Proof. exact (eq_refl (@borel_measurable_on M N')). Qed.
Definition analytic {_893426 : Type'} : ((cart R _893426) -> Prop) -> Prop := fun _1419650 : (cart R _893426) -> Prop => @suslin (cart R _893426) (@compact _893426) _1419650.
Lemma analytic_def {_893426 : Type'} : (@analytic _893426) = (fun _1419650 : (cart R _893426) -> Prop => @suslin (cart R _893426) (@compact _893426) _1419650).
Proof. exact (eq_refl (@analytic _893426)). Qed.
Definition affine {_900445 : Type'} : ((cart R _900445) -> Prop) -> Prop := fun _1427422 : (cart R _900445) -> Prop => forall x : cart R _900445, forall y : cart R _900445, forall u : R, forall v : R, ((@IN (cart R _900445) x _1427422) /\ ((@IN (cart R _900445) y _1427422) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))) -> @IN (cart R _900445) (@vector_add _900445 (@percent _900445 u x) (@percent _900445 v y)) _1427422.
Lemma affine_def {_900445 : Type'} : (@affine _900445) = (fun _1427422 : (cart R _900445) -> Prop => forall x : cart R _900445, forall y : cart R _900445, forall u : R, forall v : R, ((@IN (cart R _900445) x _1427422) /\ ((@IN (cart R _900445) y _1427422) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))) -> @IN (cart R _900445) (@vector_add _900445 (@percent _900445 u x) (@percent _900445 v y)) _1427422).
Proof. exact (eq_refl (@affine _900445)). Qed.
Definition convex {_906283 : Type'} : ((cart R _906283) -> Prop) -> Prop := fun _1431937 : (cart R _906283) -> Prop => forall x : cart R _906283, forall y : cart R _906283, forall u : R, forall v : R, ((@IN (cart R _906283) x _1431937) /\ ((@IN (cart R _906283) y _1431937) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> @IN (cart R _906283) (@vector_add _906283 (@percent _906283 u x) (@percent _906283 v y)) _1431937.
Lemma convex_def {_906283 : Type'} : (@convex _906283) = (fun _1431937 : (cart R _906283) -> Prop => forall x : cart R _906283, forall y : cart R _906283, forall u : R, forall v : R, ((@IN (cart R _906283) x _1431937) /\ ((@IN (cart R _906283) y _1431937) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> @IN (cart R _906283) (@vector_add _906283 (@percent _906283 u x) (@percent _906283 v y)) _1431937).
Proof. exact (eq_refl (@convex _906283)). Qed.
Definition conic {_909275 : Type'} : ((cart R _909275) -> Prop) -> Prop := fun _1433786 : (cart R _909275) -> Prop => forall x : cart R _909275, forall c : R, ((@IN (cart R _909275) x _1433786) /\ (Rle (R_of_N (NUMERAL 0%N)) c)) -> @IN (cart R _909275) (@percent _909275 c x) _1433786.
Lemma conic_def {_909275 : Type'} : (@conic _909275) = (fun _1433786 : (cart R _909275) -> Prop => forall x : cart R _909275, forall c : R, ((@IN (cart R _909275) x _1433786) /\ (Rle (R_of_N (NUMERAL 0%N)) c)) -> @IN (cart R _909275) (@percent _909275 c x) _1433786).
Proof. exact (eq_refl (@conic _909275)). Qed.
Definition affine_dependent {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1435299 : (cart R N') -> Prop => exists x : cart R N', (@IN (cart R N') x _1435299) /\ (@IN (cart R N') x (@hull (cart R N') (@affine N') (@DELETE (cart R N') _1435299 x))).
Lemma affine_dependent_def {N' : Type'} : (@affine_dependent N') = (fun _1435299 : (cart R N') -> Prop => exists x : cart R N', (@IN (cart R N') x _1435299) /\ (@IN (cart R N') x (@hull (cart R N') (@affine N') (@DELETE (cart R N') _1435299 x)))).
Proof. exact (eq_refl (@affine_dependent N')). Qed.
Definition coplanar {_911989 : Type'} : ((cart R _911989) -> Prop) -> Prop := fun _1436217 : (cart R _911989) -> Prop => exists u : cart R _911989, exists v : cart R _911989, exists w : cart R _911989, @SUBSET (cart R _911989) _1436217 (@hull (cart R _911989) (@affine _911989) (@INSERT (cart R _911989) u (@INSERT (cart R _911989) v (@INSERT (cart R _911989) w (@EMPTY (cart R _911989)))))).
Lemma coplanar_def {_911989 : Type'} : (@coplanar _911989) = (fun _1436217 : (cart R _911989) -> Prop => exists u : cart R _911989, exists v : cart R _911989, exists w : cart R _911989, @SUBSET (cart R _911989) _1436217 (@hull (cart R _911989) (@affine _911989) (@INSERT (cart R _911989) u (@INSERT (cart R _911989) v (@INSERT (cart R _911989) w (@EMPTY (cart R _911989))))))).
Proof. exact (eq_refl (@coplanar _911989)). Qed.
Definition convex_on {_913183 : Type'} : ((cart R _913183) -> R) -> ((cart R _913183) -> Prop) -> Prop := fun _1437459 : (cart R _913183) -> R => fun _1437460 : (cart R _913183) -> Prop => forall x : cart R _913183, forall y : cart R _913183, forall u : R, forall v : R, ((@IN (cart R _913183) x _1437460) /\ ((@IN (cart R _913183) y _1437460) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> Rle (_1437459 (@vector_add _913183 (@percent _913183 u x) (@percent _913183 v y))) (Rplus (Rmult u (_1437459 x)) (Rmult v (_1437459 y))).
Lemma convex_on_def {_913183 : Type'} : (@convex_on _913183) = (fun _1437459 : (cart R _913183) -> R => fun _1437460 : (cart R _913183) -> Prop => forall x : cart R _913183, forall y : cart R _913183, forall u : R, forall v : R, ((@IN (cart R _913183) x _1437460) /\ ((@IN (cart R _913183) y _1437460) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> Rle (_1437459 (@vector_add _913183 (@percent _913183 u x) (@percent _913183 v y))) (Rplus (Rmult u (_1437459 x)) (Rmult v (_1437459 y)))).
Proof. exact (eq_refl (@convex_on _913183)). Qed.
Definition aff_dim {_926023 : Type'} : ((cart R _926023) -> Prop) -> Z := fun _1448705 : (cart R _926023) -> Prop => @ε Z (fun d : Z => exists b : (cart R _926023) -> Prop, ((@hull (cart R _926023) (@affine _926023) b) = (@hull (cart R _926023) (@affine _926023) _1448705)) /\ ((~ (@affine_dependent _926023 b)) /\ ((Z_of_N (@CARD (cart R _926023) b)) = (Z.add d (Z_of_N (NUMERAL (BIT1 0%N))))))).
Lemma aff_dim_def {_926023 : Type'} : (@aff_dim _926023) = (fun _1448705 : (cart R _926023) -> Prop => @ε Z (fun d : Z => exists b : (cart R _926023) -> Prop, ((@hull (cart R _926023) (@affine _926023) b) = (@hull (cart R _926023) (@affine _926023) _1448705)) /\ ((~ (@affine_dependent _926023 b)) /\ ((Z_of_N (@CARD (cart R _926023) b)) = (Z.add d (Z_of_N (NUMERAL (BIT1 0%N)))))))).
Proof. exact (eq_refl (@aff_dim _926023)). Qed.
Definition polar_dual {N' : Type'} : ((cart R N') -> Prop) -> (cart R N') -> Prop := fun _1478895 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4503 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4503 (forall u : cart R N', (@IN (cart R N') u _1478895) -> Rge (@dot N' u x) (Ropp (R_of_N (NUMERAL (BIT1 0%N))))) x).
Lemma polar_dual_def {N' : Type'} : (@polar_dual N') = (fun _1478895 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4503 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4503 (forall u : cart R N', (@IN (cart R N') u _1478895) -> Rge (@dot N' u x) (Ropp (R_of_N (NUMERAL (BIT1 0%N))))) x)).
Proof. exact (eq_refl (@polar_dual N')). Qed.
Definition convex_cone {_959290 : Type'} : ((cart R _959290) -> Prop) -> Prop := fun _1505656 : (cart R _959290) -> Prop => (~ (_1505656 = (@EMPTY (cart R _959290)))) /\ ((@convex _959290 _1505656) /\ (@conic _959290 _1505656)).
Lemma convex_cone_def {_959290 : Type'} : (@convex_cone _959290) = (fun _1505656 : (cart R _959290) -> Prop => (~ (_1505656 = (@EMPTY (cart R _959290)))) /\ ((@convex _959290 _1505656) /\ (@conic _959290 _1505656))).
Proof. exact (eq_refl (@convex_cone _959290)). Qed.
Definition epigraph {N' : Type'} : ((cart R N') -> Prop) -> ((cart R N') -> R) -> (cart R (finite_sum N' unit)) -> Prop := fun _1508805 : (cart R N') -> Prop => fun _1508806 : (cart R N') -> R => @GSPEC (cart R (finite_sum N' unit)) (fun GEN_PVAR_4578 : cart R (finite_sum N' unit) => exists xy : cart R (finite_sum N' unit), @SETSPEC (cart R (finite_sum N' unit)) GEN_PVAR_4578 ((@IN (cart R N') (@fstcart R N' unit xy) _1508805) /\ (Rle (_1508806 (@fstcart R N' unit xy)) (drop (@sndcart R N' unit xy)))) xy).
Lemma epigraph_def {N' : Type'} : (@epigraph N') = (fun _1508805 : (cart R N') -> Prop => fun _1508806 : (cart R N') -> R => @GSPEC (cart R (finite_sum N' unit)) (fun GEN_PVAR_4578 : cart R (finite_sum N' unit) => exists xy : cart R (finite_sum N' unit), @SETSPEC (cart R (finite_sum N' unit)) GEN_PVAR_4578 ((@IN (cart R N') (@fstcart R N' unit xy) _1508805) /\ (Rle (_1508806 (@fstcart R N' unit xy)) (drop (@sndcart R N' unit xy)))) xy)).
Proof. exact (eq_refl (@epigraph N')). Qed.
Definition starlike {_964271 : Type'} : ((cart R _964271) -> Prop) -> Prop := fun _1510785 : (cart R _964271) -> Prop => exists a : cart R _964271, (@IN (cart R _964271) a _1510785) /\ (forall x : cart R _964271, (@IN (cart R _964271) x _1510785) -> @SUBSET (cart R _964271) (@closed_segment _964271 (@cons (prod (cart R _964271) (cart R _964271)) (@pair (cart R _964271) (cart R _964271) a x) (@nil (prod (cart R _964271) (cart R _964271))))) _1510785).
Lemma starlike_def {_964271 : Type'} : (@starlike _964271) = (fun _1510785 : (cart R _964271) -> Prop => exists a : cart R _964271, (@IN (cart R _964271) a _1510785) /\ (forall x : cart R _964271, (@IN (cart R _964271) x _1510785) -> @SUBSET (cart R _964271) (@closed_segment _964271 (@cons (prod (cart R _964271) (cart R _964271)) (@pair (cart R _964271) (cart R _964271) a x) (@nil (prod (cart R _964271) (cart R _964271))))) _1510785)).
Proof. exact (eq_refl (@starlike _964271)). Qed.
Definition relative_interior {_967920 : Type'} : ((cart R _967920) -> Prop) -> (cart R _967920) -> Prop := fun _1512879 : (cart R _967920) -> Prop => @GSPEC (cart R _967920) (fun GEN_PVAR_4598 : cart R _967920 => exists x : cart R _967920, @SETSPEC (cart R _967920) GEN_PVAR_4598 (exists t : (cart R _967920) -> Prop, (@open_in (cart R _967920) (@subtopology (cart R _967920) (@euclidean _967920) (@hull (cart R _967920) (@affine _967920) _1512879)) t) /\ ((@IN (cart R _967920) x t) /\ (@SUBSET (cart R _967920) t _1512879))) x).
Lemma relative_interior_def {_967920 : Type'} : (@relative_interior _967920) = (fun _1512879 : (cart R _967920) -> Prop => @GSPEC (cart R _967920) (fun GEN_PVAR_4598 : cart R _967920 => exists x : cart R _967920, @SETSPEC (cart R _967920) GEN_PVAR_4598 (exists t : (cart R _967920) -> Prop, (@open_in (cart R _967920) (@subtopology (cart R _967920) (@euclidean _967920) (@hull (cart R _967920) (@affine _967920) _1512879)) t) /\ ((@IN (cart R _967920) x t) /\ (@SUBSET (cart R _967920) t _1512879))) x)).
Proof. exact (eq_refl (@relative_interior _967920)). Qed.
Definition relative_frontier {_967940 : Type'} : ((cart R _967940) -> Prop) -> (cart R _967940) -> Prop := fun _1512884 : (cart R _967940) -> Prop => @DIFF (cart R _967940) (@closure _967940 _1512884) (@relative_interior _967940 _1512884).
Lemma relative_frontier_def {_967940 : Type'} : (@relative_frontier _967940) = (fun _1512884 : (cart R _967940) -> Prop => @DIFF (cart R _967940) (@closure _967940 _1512884) (@relative_interior _967940 _1512884)).
Proof. exact (eq_refl (@relative_frontier _967940)). Qed.
Definition barycentre {_1005137 : Type'} : ((cart R _1005137) -> Prop) -> cart R _1005137 := fun _1550498 : (cart R _1005137) -> Prop => @COND (cart R _1005137) (@FINITE (cart R _1005137) _1550498) (@vsum (cart R _1005137) _1005137 _1550498 (fun x : cart R _1005137 => @percent _1005137 (Rinv (R_of_N (@CARD (cart R _1005137) _1550498))) x)) (@vec _1005137 (NUMERAL 0%N)).
Lemma barycentre_def {_1005137 : Type'} : (@barycentre _1005137) = (fun _1550498 : (cart R _1005137) -> Prop => @COND (cart R _1005137) (@FINITE (cart R _1005137) _1550498) (@vsum (cart R _1005137) _1005137 _1550498 (fun x : cart R _1005137 => @percent _1005137 (Rinv (R_of_N (@CARD (cart R _1005137) _1550498))) x)) (@vec _1005137 (NUMERAL 0%N))).
Proof. exact (eq_refl (@barycentre _1005137)). Qed.
Definition path {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _1555906 : (cart R unit) -> cart R N' => @continuous_on unit N' _1555906 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))).
Lemma path_def {N' : Type'} : (@path N') = (fun _1555906 : (cart R unit) -> cart R N' => @continuous_on unit N' _1555906 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))).
Proof. exact (eq_refl (@path N')). Qed.
Definition pathstart {N' : Type'} : ((cart R unit) -> cart R N') -> cart R N' := fun _1555911 : (cart R unit) -> cart R N' => _1555911 (@vec unit (NUMERAL 0%N)).
Lemma pathstart_def {N' : Type'} : (@pathstart N') = (fun _1555911 : (cart R unit) -> cart R N' => _1555911 (@vec unit (NUMERAL 0%N))).
Proof. exact (eq_refl (@pathstart N')). Qed.
Definition pathfinish {N' : Type'} : ((cart R unit) -> cart R N') -> cart R N' := fun _1555916 : (cart R unit) -> cart R N' => _1555916 (@vec unit (NUMERAL (BIT1 0%N))).
Lemma pathfinish_def {N' : Type'} : (@pathfinish N') = (fun _1555916 : (cart R unit) -> cart R N' => _1555916 (@vec unit (NUMERAL (BIT1 0%N)))).
Proof. exact (eq_refl (@pathfinish N')). Qed.
Definition path_image {N' : Type'} : ((cart R unit) -> cart R N') -> (cart R N') -> Prop := fun _1555921 : (cart R unit) -> cart R N' => @IMAGE (cart R unit) (cart R N') _1555921 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))).
Lemma path_image_def {N' : Type'} : (@path_image N') = (fun _1555921 : (cart R unit) -> cart R N' => @IMAGE (cart R unit) (cart R N') _1555921 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))).
Proof. exact (eq_refl (@path_image N')). Qed.
Definition reversepath {N' : Type'} : ((cart R unit) -> cart R N') -> (cart R unit) -> cart R N' := fun _1555926 : (cart R unit) -> cart R N' => fun x : cart R unit => _1555926 (@vector_sub unit (@vec unit (NUMERAL (BIT1 0%N))) x).
Lemma reversepath_def {N' : Type'} : (@reversepath N') = (fun _1555926 : (cart R unit) -> cart R N' => fun x : cart R unit => _1555926 (@vector_sub unit (@vec unit (NUMERAL (BIT1 0%N))) x)).
Proof. exact (eq_refl (@reversepath N')). Qed.
Definition addadd {_1009590 : Type'} : ((cart R unit) -> _1009590) -> ((cart R unit) -> _1009590) -> (cart R unit) -> _1009590 := fun _1555931 : (cart R unit) -> _1009590 => fun _1555932 : (cart R unit) -> _1009590 => fun x : cart R unit => @COND _1009590 (Rle (drop x) (Rdiv (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (_1555931 (@percent unit (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) x)) (_1555932 (@vector_sub unit (@percent unit (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) x) (@vec unit (NUMERAL (BIT1 0%N))))).
Lemma addadd_def {_1009590 : Type'} : (@addadd _1009590) = (fun _1555931 : (cart R unit) -> _1009590 => fun _1555932 : (cart R unit) -> _1009590 => fun x : cart R unit => @COND _1009590 (Rle (drop x) (Rdiv (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (_1555931 (@percent unit (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) x)) (_1555932 (@vector_sub unit (@percent unit (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) x) (@vec unit (NUMERAL (BIT1 0%N)))))).
Proof. exact (eq_refl (@addadd _1009590)). Qed.
Definition simple_path {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _1555943 : (cart R unit) -> cart R N' => (@path N' _1555943) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1555943 x) = (_1555943 y)))) -> (x = y) \/ (((x = (@vec unit (NUMERAL 0%N))) /\ (y = (@vec unit (NUMERAL (BIT1 0%N))))) \/ ((x = (@vec unit (NUMERAL (BIT1 0%N)))) /\ (y = (@vec unit (NUMERAL 0%N)))))).
Lemma simple_path_def {N' : Type'} : (@simple_path N') = (fun _1555943 : (cart R unit) -> cart R N' => (@path N' _1555943) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1555943 x) = (_1555943 y)))) -> (x = y) \/ (((x = (@vec unit (NUMERAL 0%N))) /\ (y = (@vec unit (NUMERAL (BIT1 0%N))))) \/ ((x = (@vec unit (NUMERAL (BIT1 0%N)))) /\ (y = (@vec unit (NUMERAL 0%N))))))).
Proof. exact (eq_refl (@simple_path N')). Qed.
Definition arc {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _1555948 : (cart R unit) -> cart R N' => (@path N' _1555948) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1555948 x) = (_1555948 y)))) -> x = y).
Lemma arc_def {N' : Type'} : (@arc N') = (fun _1555948 : (cart R unit) -> cart R N' => (@path N' _1555948) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1555948 x) = (_1555948 y)))) -> x = y)).
Proof. exact (eq_refl (@arc N')). Qed.
Definition shiftpath {N' : Type'} : (cart R unit) -> ((cart R unit) -> cart R N') -> (cart R unit) -> cart R N' := fun _1560988 : cart R unit => fun _1560989 : (cart R unit) -> cart R N' => fun x : cart R unit => @COND (cart R N') (Rle (drop (@vector_add unit _1560988 x)) (R_of_N (NUMERAL (BIT1 0%N)))) (_1560989 (@vector_add unit _1560988 x)) (_1560989 (@vector_add unit _1560988 (@vector_sub unit x (@vec unit (NUMERAL (BIT1 0%N)))))).
Lemma shiftpath_def {N' : Type'} : (@shiftpath N') = (fun _1560988 : cart R unit => fun _1560989 : (cart R unit) -> cart R N' => fun x : cart R unit => @COND (cart R N') (Rle (drop (@vector_add unit _1560988 x)) (R_of_N (NUMERAL (BIT1 0%N)))) (_1560989 (@vector_add unit _1560988 x)) (_1560989 (@vector_add unit _1560988 (@vector_sub unit x (@vec unit (NUMERAL (BIT1 0%N))))))).
Proof. exact (eq_refl (@shiftpath N')). Qed.
Definition subpath {_1015740 : Type'} : (cart R unit) -> (cart R unit) -> ((cart R unit) -> _1015740) -> (cart R unit) -> _1015740 := fun _1561150 : cart R unit => fun _1561151 : cart R unit => fun _1561152 : (cart R unit) -> _1015740 => fun x : cart R unit => _1561152 (@vector_add unit _1561150 (@percent unit (drop (@vector_sub unit _1561151 _1561150)) x)).
Lemma subpath_def {_1015740 : Type'} : (@subpath _1015740) = (fun _1561150 : cart R unit => fun _1561151 : cart R unit => fun _1561152 : (cart R unit) -> _1015740 => fun x : cart R unit => _1561152 (@vector_add unit _1561150 (@percent unit (drop (@vector_sub unit _1561151 _1561150)) x))).
Proof. exact (eq_refl (@subpath _1015740)). Qed.
Definition linepath {_1019931 : Type'} : (prod (cart R _1019931) (cart R _1019931)) -> (cart R unit) -> cart R _1019931 := fun _1568604 : prod (cart R _1019931) (cart R _1019931) => fun x : cart R unit => @vector_add _1019931 (@percent _1019931 (Rminus (R_of_N (NUMERAL (BIT1 0%N))) (drop x)) (@fst (cart R _1019931) (cart R _1019931) _1568604)) (@percent _1019931 (drop x) (@snd (cart R _1019931) (cart R _1019931) _1568604)).
Lemma linepath_def {_1019931 : Type'} : (@linepath _1019931) = (fun _1568604 : prod (cart R _1019931) (cart R _1019931) => fun x : cart R unit => @vector_add _1019931 (@percent _1019931 (Rminus (R_of_N (NUMERAL (BIT1 0%N))) (drop x)) (@fst (cart R _1019931) (cart R _1019931) _1568604)) (@percent _1019931 (drop x) (@snd (cart R _1019931) (cart R _1019931) _1568604))).
Proof. exact (eq_refl (@linepath _1019931)). Qed.
Definition path_component {_1022096 : Type'} : ((cart R _1022096) -> Prop) -> (cart R _1022096) -> (cart R _1022096) -> Prop := fun _1576556 : (cart R _1022096) -> Prop => fun _1576557 : cart R _1022096 => fun _1576558 : cart R _1022096 => exists g : (cart R unit) -> cart R _1022096, (@path _1022096 g) /\ ((@SUBSET (cart R _1022096) (@path_image _1022096 g) _1576556) /\ (((@pathstart _1022096 g) = _1576557) /\ ((@pathfinish _1022096 g) = _1576558))).
Lemma path_component_def {_1022096 : Type'} : (@path_component _1022096) = (fun _1576556 : (cart R _1022096) -> Prop => fun _1576557 : cart R _1022096 => fun _1576558 : cart R _1022096 => exists g : (cart R unit) -> cart R _1022096, (@path _1022096 g) /\ ((@SUBSET (cart R _1022096) (@path_image _1022096 g) _1576556) /\ (((@pathstart _1022096 g) = _1576557) /\ ((@pathfinish _1022096 g) = _1576558)))).
Proof. exact (eq_refl (@path_component _1022096)). Qed.
Definition path_components {_1022138 : Type'} : ((cart R _1022138) -> Prop) -> ((cart R _1022138) -> Prop) -> Prop := fun _1576577 : (cart R _1022138) -> Prop => @GSPEC ((cart R _1022138) -> Prop) (fun GEN_PVAR_4704 : (cart R _1022138) -> Prop => exists x : cart R _1022138, @SETSPEC ((cart R _1022138) -> Prop) GEN_PVAR_4704 (@IN (cart R _1022138) x _1576577) (@path_component _1022138 _1576577 x)).
Lemma path_components_def {_1022138 : Type'} : (@path_components _1022138) = (fun _1576577 : (cart R _1022138) -> Prop => @GSPEC ((cart R _1022138) -> Prop) (fun GEN_PVAR_4704 : (cart R _1022138) -> Prop => exists x : cart R _1022138, @SETSPEC ((cart R _1022138) -> Prop) GEN_PVAR_4704 (@IN (cart R _1022138) x _1576577) (@path_component _1022138 _1576577 x))).
Proof. exact (eq_refl (@path_components _1022138)). Qed.
Definition path_connected {_1022636 : Type'} : ((cart R _1022636) -> Prop) -> Prop := fun _1576774 : (cart R _1022636) -> Prop => forall x : cart R _1022636, forall y : cart R _1022636, ((@IN (cart R _1022636) x _1576774) /\ (@IN (cart R _1022636) y _1576774)) -> exists g : (cart R unit) -> cart R _1022636, (@path _1022636 g) /\ ((@SUBSET (cart R _1022636) (@path_image _1022636 g) _1576774) /\ (((@pathstart _1022636 g) = x) /\ ((@pathfinish _1022636 g) = y))).
Lemma path_connected_def {_1022636 : Type'} : (@path_connected _1022636) = (fun _1576774 : (cart R _1022636) -> Prop => forall x : cart R _1022636, forall y : cart R _1022636, ((@IN (cart R _1022636) x _1576774) /\ (@IN (cart R _1022636) y _1576774)) -> exists g : (cart R unit) -> cart R _1022636, (@path _1022636 g) /\ ((@SUBSET (cart R _1022636) (@path_image _1022636 g) _1576774) /\ (((@pathstart _1022636 g) = x) /\ ((@pathfinish _1022636 g) = y)))).
Proof. exact (eq_refl (@path_connected _1022636)). Qed.
Definition inside {N' : Type'} : ((cart R N') -> Prop) -> (cart R N') -> Prop := fun _1759705 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4971 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4971 ((~ (@IN (cart R N') x _1759705)) /\ (@bounded N' (@connected_component N' (@DIFF (cart R N') (@UNIV (cart R N')) _1759705) x))) x).
Lemma inside_def {N' : Type'} : (@inside N') = (fun _1759705 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4971 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4971 ((~ (@IN (cart R N') x _1759705)) /\ (@bounded N' (@connected_component N' (@DIFF (cart R N') (@UNIV (cart R N')) _1759705) x))) x)).
Proof. exact (eq_refl (@inside N')). Qed.
Definition outside {N' : Type'} : ((cart R N') -> Prop) -> (cart R N') -> Prop := fun _1759710 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4972 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4972 ((~ (@IN (cart R N') x _1759710)) /\ (~ (@bounded N' (@connected_component N' (@DIFF (cart R N') (@UNIV (cart R N')) _1759710) x)))) x).
Lemma outside_def {N' : Type'} : (@outside N') = (fun _1759710 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4972 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4972 ((~ (@IN (cart R N') x _1759710)) /\ (~ (@bounded N' (@connected_component N' (@DIFF (cart R N') (@UNIV (cart R N')) _1759710) x)))) x)).
Proof. exact (eq_refl (@outside N')). Qed.
Definition homotopic_paths {_1101971 : Type'} : ((cart R _1101971) -> Prop) -> ((cart R unit) -> cart R _1101971) -> ((cart R unit) -> cart R _1101971) -> Prop := fun _1765749 : (cart R _1101971) -> Prop => fun _1765750 : (cart R unit) -> cart R _1101971 => fun _1765751 : (cart R unit) -> cart R _1101971 => @homotopic_with (cart R _1101971) (cart R unit) (fun r : (cart R unit) -> cart R _1101971 => ((@pathstart _1101971 r) = (@pathstart _1101971 _1765750)) /\ ((@pathfinish _1101971 r) = (@pathfinish _1101971 _1765750))) (@pair (Topology (cart R unit)) (Topology (cart R _1101971)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1101971) (@euclidean _1101971) _1765749)) _1765750 _1765751.
Lemma homotopic_paths_def {_1101971 : Type'} : (@homotopic_paths _1101971) = (fun _1765749 : (cart R _1101971) -> Prop => fun _1765750 : (cart R unit) -> cart R _1101971 => fun _1765751 : (cart R unit) -> cart R _1101971 => @homotopic_with (cart R _1101971) (cart R unit) (fun r : (cart R unit) -> cart R _1101971 => ((@pathstart _1101971 r) = (@pathstart _1101971 _1765750)) /\ ((@pathfinish _1101971 r) = (@pathfinish _1101971 _1765750))) (@pair (Topology (cart R unit)) (Topology (cart R _1101971)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1101971) (@euclidean _1101971) _1765749)) _1765750 _1765751).
Proof. exact (eq_refl (@homotopic_paths _1101971)). Qed.
Definition homotopic_loops {_1104574 : Type'} : ((cart R _1104574) -> Prop) -> ((cart R unit) -> cart R _1104574) -> ((cart R unit) -> cart R _1104574) -> Prop := fun _1769541 : (cart R _1104574) -> Prop => fun _1769542 : (cart R unit) -> cart R _1104574 => fun _1769543 : (cart R unit) -> cart R _1104574 => @homotopic_with (cart R _1104574) (cart R unit) (fun r : (cart R unit) -> cart R _1104574 => (@pathfinish _1104574 r) = (@pathstart _1104574 r)) (@pair (Topology (cart R unit)) (Topology (cart R _1104574)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1104574) (@euclidean _1104574) _1769541)) _1769542 _1769543.
Lemma homotopic_loops_def {_1104574 : Type'} : (@homotopic_loops _1104574) = (fun _1769541 : (cart R _1104574) -> Prop => fun _1769542 : (cart R unit) -> cart R _1104574 => fun _1769543 : (cart R unit) -> cart R _1104574 => @homotopic_with (cart R _1104574) (cart R unit) (fun r : (cart R unit) -> cart R _1104574 => (@pathfinish _1104574 r) = (@pathstart _1104574 r)) (@pair (Topology (cart R unit)) (Topology (cart R _1104574)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1104574) (@euclidean _1104574) _1769541)) _1769542 _1769543).
Proof. exact (eq_refl (@homotopic_loops _1104574)). Qed.
Definition simply_connected {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1777269 : (cart R N') -> Prop => forall p : (cart R unit) -> cart R N', forall q : (cart R unit) -> cart R N', ((@path N' p) /\ (((@pathfinish N' p) = (@pathstart N' p)) /\ ((@SUBSET (cart R N') (@path_image N' p) _1777269) /\ ((@path N' q) /\ (((@pathfinish N' q) = (@pathstart N' q)) /\ (@SUBSET (cart R N') (@path_image N' q) _1777269)))))) -> @homotopic_loops N' _1777269 p q.
Lemma simply_connected_def {N' : Type'} : (@simply_connected N') = (fun _1777269 : (cart R N') -> Prop => forall p : (cart R unit) -> cart R N', forall q : (cart R unit) -> cart R N', ((@path N' p) /\ (((@pathfinish N' p) = (@pathstart N' p)) /\ ((@SUBSET (cart R N') (@path_image N' p) _1777269) /\ ((@path N' q) /\ (((@pathfinish N' q) = (@pathstart N' q)) /\ (@SUBSET (cart R N') (@path_image N' q) _1777269)))))) -> @homotopic_loops N' _1777269 p q).
Proof. exact (eq_refl (@simply_connected N')). Qed.
Definition fundamental_group {N' : Type'} : (prod ((cart R N') -> Prop) (cart R N')) -> (((cart R unit) -> cart R N') -> Prop) -> Prop := fun _1779012 : prod ((cart R N') -> Prop) (cart R N') => @GSPEC (((cart R unit) -> cart R N') -> Prop) (fun GEN_PVAR_4998 : ((cart R unit) -> cart R N') -> Prop => exists p : (cart R unit) -> cart R N', @SETSPEC (((cart R unit) -> cart R N') -> Prop) GEN_PVAR_4998 ((@path N' p) /\ ((@SUBSET (cart R N') (@path_image N' p) (@fst ((cart R N') -> Prop) (cart R N') _1779012)) /\ (((@pathstart N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1779012)) /\ ((@pathfinish N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1779012))))) (@homotopic_paths N' (@fst ((cart R N') -> Prop) (cart R N') _1779012) p)).
Lemma fundamental_group_def {N' : Type'} : (@fundamental_group N') = (fun _1779012 : prod ((cart R N') -> Prop) (cart R N') => @GSPEC (((cart R unit) -> cart R N') -> Prop) (fun GEN_PVAR_4998 : ((cart R unit) -> cart R N') -> Prop => exists p : (cart R unit) -> cart R N', @SETSPEC (((cart R unit) -> cart R N') -> Prop) GEN_PVAR_4998 ((@path N' p) /\ ((@SUBSET (cart R N') (@path_image N' p) (@fst ((cart R N') -> Prop) (cart R N') _1779012)) /\ (((@pathstart N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1779012)) /\ ((@pathfinish N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1779012))))) (@homotopic_paths N' (@fst ((cart R N') -> Prop) (cart R N') _1779012) p))).
Proof. exact (eq_refl (@fundamental_group N')). Qed.
Definition homotopy_equivalent {M N' : Type'} : ((cart R M) -> Prop) -> ((cart R N') -> Prop) -> Prop := fun _1780697 : (cart R M) -> Prop => fun _1780698 : (cart R N') -> Prop => exists f : (cart R M) -> cart R N', exists g : (cart R N') -> cart R M, (@continuous_on M N' f _1780697) /\ ((@SUBSET (cart R N') (@IMAGE (cart R M) (cart R N') f _1780697) _1780698) /\ ((@continuous_on N' M g _1780698) /\ ((@SUBSET (cart R M) (@IMAGE (cart R N') (cart R M) g _1780698) _1780697) /\ ((@homotopic_with (cart R M) (cart R M) (fun x : (cart R M) -> cart R M => True) (@pair (Topology (cart R M)) (Topology (cart R M)) (@subtopology (cart R M) (@euclidean M) _1780697) (@subtopology (cart R M) (@euclidean M) _1780697)) (@o (cart R M) (cart R N') (cart R M) g f) (@I (cart R M))) /\ (@homotopic_with (cart R N') (cart R N') (fun x : (cart R N') -> cart R N' => True) (@pair (Topology (cart R N')) (Topology (cart R N')) (@subtopology (cart R N') (@euclidean N') _1780698) (@subtopology (cart R N') (@euclidean N') _1780698)) (@o (cart R N') (cart R M) (cart R N') f g) (@I (cart R N'))))))).
Lemma homotopy_equivalent_def {M N' : Type'} : (@homotopy_equivalent M N') = (fun _1780697 : (cart R M) -> Prop => fun _1780698 : (cart R N') -> Prop => exists f : (cart R M) -> cart R N', exists g : (cart R N') -> cart R M, (@continuous_on M N' f _1780697) /\ ((@SUBSET (cart R N') (@IMAGE (cart R M) (cart R N') f _1780697) _1780698) /\ ((@continuous_on N' M g _1780698) /\ ((@SUBSET (cart R M) (@IMAGE (cart R N') (cart R M) g _1780698) _1780697) /\ ((@homotopic_with (cart R M) (cart R M) (fun x : (cart R M) -> cart R M => True) (@pair (Topology (cart R M)) (Topology (cart R M)) (@subtopology (cart R M) (@euclidean M) _1780697) (@subtopology (cart R M) (@euclidean M) _1780697)) (@o (cart R M) (cart R N') (cart R M) g f) (@I (cart R M))) /\ (@homotopic_with (cart R N') (cart R N') (fun x : (cart R N') -> cart R N' => True) (@pair (Topology (cart R N')) (Topology (cart R N')) (@subtopology (cart R N') (@euclidean N') _1780698) (@subtopology (cart R N') (@euclidean N') _1780698)) (@o (cart R N') (cart R M) (cart R N') f g) (@I (cart R N')))))))).
Proof. exact (eq_refl (@homotopy_equivalent M N')). Qed.
Definition contractible {_1116691 : Type'} : ((cart R _1116691) -> Prop) -> Prop := fun _1787051 : (cart R _1116691) -> Prop => exists a : cart R _1116691, @homotopic_with (cart R _1116691) (cart R _1116691) (fun x : (cart R _1116691) -> cart R _1116691 => True) (@pair (Topology (cart R _1116691)) (Topology (cart R _1116691)) (@subtopology (cart R _1116691) (@euclidean _1116691) _1787051) (@subtopology (cart R _1116691) (@euclidean _1116691) _1787051)) (fun x : cart R _1116691 => x) (fun x : cart R _1116691 => a).
Lemma contractible_def {_1116691 : Type'} : (@contractible _1116691) = (fun _1787051 : (cart R _1116691) -> Prop => exists a : cart R _1116691, @homotopic_with (cart R _1116691) (cart R _1116691) (fun x : (cart R _1116691) -> cart R _1116691 => True) (@pair (Topology (cart R _1116691)) (Topology (cart R _1116691)) (@subtopology (cart R _1116691) (@euclidean _1116691) _1787051) (@subtopology (cart R _1116691) (@euclidean _1116691) _1787051)) (fun x : cart R _1116691 => x) (fun x : cart R _1116691 => a)).
Proof. exact (eq_refl (@contractible _1116691)). Qed.
Definition dimension {N' : Type'} : ((cart R N') -> Prop) -> Z := fun _1808913 : (cart R N') -> Prop => @COND Z (_1808913 = (@EMPTY (cart R N'))) (Z.opp (Z_of_N (NUMERAL (BIT1 0%N)))) (Z_of_N (minimal (fun n : N => @dimension_le (cart R N') (@subtopology (cart R N') (@euclidean N') _1808913) (Z_of_N n)))).
Lemma dimension_def {N' : Type'} : (@dimension N') = (fun _1808913 : (cart R N') -> Prop => @COND Z (_1808913 = (@EMPTY (cart R N'))) (Z.opp (Z_of_N (NUMERAL (BIT1 0%N)))) (Z_of_N (minimal (fun n : N => @dimension_le (cart R N') (@subtopology (cart R N') (@euclidean N') _1808913) (Z_of_N n))))).
Proof. exact (eq_refl (@dimension N')). Qed.
Definition covering_space {M N' : Type'} : (prod ((cart R M) -> Prop) ((cart R M) -> cart R N')) -> ((cart R N') -> Prop) -> Prop := fun _1821738 : prod ((cart R M) -> Prop) ((cart R M) -> cart R N') => fun _1821739 : (cart R N') -> Prop => (@continuous_on M N' (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) /\ (((@IMAGE (cart R M) (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) = _1821739) /\ (forall x : cart R N', (@IN (cart R N') x _1821739) -> exists t : (cart R N') -> Prop, (@IN (cart R N') x t) /\ ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1821739) t) /\ (exists v : ((cart R M) -> Prop) -> Prop, ((@UNIONS (cart R M) v) = (@GSPEC (cart R M) (fun GEN_PVAR_5060 : cart R M => exists x' : cart R M, @SETSPEC (cart R M) GEN_PVAR_5060 ((@IN (cart R M) x' (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) /\ (@IN (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738 x') t)) x'))) /\ ((forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> @open_in (cart R M) (@subtopology (cart R M) (@euclidean M) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) u) /\ ((@pairwise ((cart R M) -> Prop) (@DISJOINT (cart R M)) v) /\ (forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> exists q : (cart R N') -> cart R M, @homeomorphism M N' (@pair ((cart R M) -> Prop) ((cart R N') -> Prop) u t) (@pair ((cart R M) -> cart R N') ((cart R N') -> cart R M) (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738) q)))))))).
Lemma covering_space_def {M N' : Type'} : (@covering_space M N') = (fun _1821738 : prod ((cart R M) -> Prop) ((cart R M) -> cart R N') => fun _1821739 : (cart R N') -> Prop => (@continuous_on M N' (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) /\ (((@IMAGE (cart R M) (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) = _1821739) /\ (forall x : cart R N', (@IN (cart R N') x _1821739) -> exists t : (cart R N') -> Prop, (@IN (cart R N') x t) /\ ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1821739) t) /\ (exists v : ((cart R M) -> Prop) -> Prop, ((@UNIONS (cart R M) v) = (@GSPEC (cart R M) (fun GEN_PVAR_5060 : cart R M => exists x' : cart R M, @SETSPEC (cart R M) GEN_PVAR_5060 ((@IN (cart R M) x' (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) /\ (@IN (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738 x') t)) x'))) /\ ((forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> @open_in (cart R M) (@subtopology (cart R M) (@euclidean M) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738)) u) /\ ((@pairwise ((cart R M) -> Prop) (@DISJOINT (cart R M)) v) /\ (forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> exists q : (cart R N') -> cart R M, @homeomorphism M N' (@pair ((cart R M) -> Prop) ((cart R N') -> Prop) u t) (@pair ((cart R M) -> cart R N') ((cart R N') -> cart R M) (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1821738) q))))))))).
Proof. exact (eq_refl (@covering_space M N')). Qed.
Definition face_of {_1154071 : Type'} : ((cart R _1154071) -> Prop) -> ((cart R _1154071) -> Prop) -> Prop := fun _1978169 : (cart R _1154071) -> Prop => fun _1978170 : (cart R _1154071) -> Prop => (@SUBSET (cart R _1154071) _1978169 _1978170) /\ ((@convex _1154071 _1978169) /\ (forall a : cart R _1154071, forall b : cart R _1154071, forall x : cart R _1154071, ((@IN (cart R _1154071) a _1978170) /\ ((@IN (cart R _1154071) b _1978170) /\ ((@IN (cart R _1154071) x _1978169) /\ (@IN (cart R _1154071) x (@open_segment _1154071 (@pair (cart R _1154071) (cart R _1154071) a b)))))) -> (@IN (cart R _1154071) a _1978169) /\ (@IN (cart R _1154071) b _1978169))).
Lemma face_of_def {_1154071 : Type'} : (@face_of _1154071) = (fun _1978169 : (cart R _1154071) -> Prop => fun _1978170 : (cart R _1154071) -> Prop => (@SUBSET (cart R _1154071) _1978169 _1978170) /\ ((@convex _1154071 _1978169) /\ (forall a : cart R _1154071, forall b : cart R _1154071, forall x : cart R _1154071, ((@IN (cart R _1154071) a _1978170) /\ ((@IN (cart R _1154071) b _1978170) /\ ((@IN (cart R _1154071) x _1978169) /\ (@IN (cart R _1154071) x (@open_segment _1154071 (@pair (cart R _1154071) (cart R _1154071) a b)))))) -> (@IN (cart R _1154071) a _1978169) /\ (@IN (cart R _1154071) b _1978169)))).
Proof. exact (eq_refl (@face_of _1154071)). Qed.
Definition exposed_face_of {_1160486 : Type'} : ((cart R _1160486) -> Prop) -> ((cart R _1160486) -> Prop) -> Prop := fun _1988689 : (cart R _1160486) -> Prop => fun _1988690 : (cart R _1160486) -> Prop => (@face_of _1160486 _1988689 _1988690) /\ (exists a : cart R _1160486, exists b : R, (@SUBSET (cart R _1160486) _1988690 (@GSPEC (cart R _1160486) (fun GEN_PVAR_5206 : cart R _1160486 => exists x : cart R _1160486, @SETSPEC (cart R _1160486) GEN_PVAR_5206 (Rle (@dot _1160486 a x) b) x))) /\ (_1988689 = (@INTER (cart R _1160486) _1988690 (@GSPEC (cart R _1160486) (fun GEN_PVAR_5207 : cart R _1160486 => exists x : cart R _1160486, @SETSPEC (cart R _1160486) GEN_PVAR_5207 ((@dot _1160486 a x) = b) x))))).
Lemma exposed_face_of_def {_1160486 : Type'} : (@exposed_face_of _1160486) = (fun _1988689 : (cart R _1160486) -> Prop => fun _1988690 : (cart R _1160486) -> Prop => (@face_of _1160486 _1988689 _1988690) /\ (exists a : cart R _1160486, exists b : R, (@SUBSET (cart R _1160486) _1988690 (@GSPEC (cart R _1160486) (fun GEN_PVAR_5206 : cart R _1160486 => exists x : cart R _1160486, @SETSPEC (cart R _1160486) GEN_PVAR_5206 (Rle (@dot _1160486 a x) b) x))) /\ (_1988689 = (@INTER (cart R _1160486) _1988690 (@GSPEC (cart R _1160486) (fun GEN_PVAR_5207 : cart R _1160486 => exists x : cart R _1160486, @SETSPEC (cart R _1160486) GEN_PVAR_5207 ((@dot _1160486 a x) = b) x)))))).
Proof. exact (eq_refl (@exposed_face_of _1160486)). Qed.
Definition extreme_point_of {_1162084 : Type'} : (cart R _1162084) -> ((cart R _1162084) -> Prop) -> Prop := fun _1989434 : cart R _1162084 => fun _1989435 : (cart R _1162084) -> Prop => (@IN (cart R _1162084) _1989434 _1989435) /\ (forall a : cart R _1162084, forall b : cart R _1162084, ((@IN (cart R _1162084) a _1989435) /\ (@IN (cart R _1162084) b _1989435)) -> ~ (@IN (cart R _1162084) _1989434 (@open_segment _1162084 (@pair (cart R _1162084) (cart R _1162084) a b)))).
Lemma extreme_point_of_def {_1162084 : Type'} : (@extreme_point_of _1162084) = (fun _1989434 : cart R _1162084 => fun _1989435 : (cart R _1162084) -> Prop => (@IN (cart R _1162084) _1989434 _1989435) /\ (forall a : cart R _1162084, forall b : cart R _1162084, ((@IN (cart R _1162084) a _1989435) /\ (@IN (cart R _1162084) b _1989435)) -> ~ (@IN (cart R _1162084) _1989434 (@open_segment _1162084 (@pair (cart R _1162084) (cart R _1162084) a b))))).
Proof. exact (eq_refl (@extreme_point_of _1162084)). Qed.
Definition facet_of {_1167038 : Type'} : ((cart R _1167038) -> Prop) -> ((cart R _1167038) -> Prop) -> Prop := fun _1999644 : (cart R _1167038) -> Prop => fun _1999645 : (cart R _1167038) -> Prop => (@face_of _1167038 _1999644 _1999645) /\ ((~ (_1999644 = (@EMPTY (cart R _1167038)))) /\ ((@aff_dim _1167038 _1999644) = (Z.sub (@aff_dim _1167038 _1999645) (Z_of_N (NUMERAL (BIT1 0%N)))))).
Lemma facet_of_def {_1167038 : Type'} : (@facet_of _1167038) = (fun _1999644 : (cart R _1167038) -> Prop => fun _1999645 : (cart R _1167038) -> Prop => (@face_of _1167038 _1999644 _1999645) /\ ((~ (_1999644 = (@EMPTY (cart R _1167038)))) /\ ((@aff_dim _1167038 _1999644) = (Z.sub (@aff_dim _1167038 _1999645) (Z_of_N (NUMERAL (BIT1 0%N))))))).
Proof. exact (eq_refl (@facet_of _1167038)). Qed.
Definition edge_of {_1168282 : Type'} : ((cart R _1168282) -> Prop) -> ((cart R _1168282) -> Prop) -> Prop := fun _2001894 : (cart R _1168282) -> Prop => fun _2001895 : (cart R _1168282) -> Prop => (@face_of _1168282 _2001894 _2001895) /\ ((@aff_dim _1168282 _2001894) = (Z_of_N (NUMERAL (BIT1 0%N)))).
Lemma edge_of_def {_1168282 : Type'} : (@edge_of _1168282) = (fun _2001894 : (cart R _1168282) -> Prop => fun _2001895 : (cart R _1168282) -> Prop => (@face_of _1168282 _2001894 _2001895) /\ ((@aff_dim _1168282 _2001894) = (Z_of_N (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl (@edge_of _1168282)). Qed.
Definition polytope {_1174600 : Type'} : ((cart R _1174600) -> Prop) -> Prop := fun _2007480 : (cart R _1174600) -> Prop => exists v : (cart R _1174600) -> Prop, (@FINITE (cart R _1174600) v) /\ (_2007480 = (@hull (cart R _1174600) (@convex _1174600) v)).
Lemma polytope_def {_1174600 : Type'} : (@polytope _1174600) = (fun _2007480 : (cart R _1174600) -> Prop => exists v : (cart R _1174600) -> Prop, (@FINITE (cart R _1174600) v) /\ (_2007480 = (@hull (cart R _1174600) (@convex _1174600) v))).
Proof. exact (eq_refl (@polytope _1174600)). Qed.
Definition polyhedron {_1176324 : Type'} : ((cart R _1176324) -> Prop) -> Prop := fun _2008072 : (cart R _1176324) -> Prop => exists f : ((cart R _1176324) -> Prop) -> Prop, (@FINITE ((cart R _1176324) -> Prop) f) /\ ((_2008072 = (@INTERS (cart R _1176324) f)) /\ (forall h : (cart R _1176324) -> Prop, (@IN ((cart R _1176324) -> Prop) h f) -> exists a : cart R _1176324, exists b : R, (~ (a = (@vec _1176324 (NUMERAL 0%N)))) /\ (h = (@GSPEC (cart R _1176324) (fun GEN_PVAR_5307 : cart R _1176324 => exists x : cart R _1176324, @SETSPEC (cart R _1176324) GEN_PVAR_5307 (Rle (@dot _1176324 a x) b) x))))).
Lemma polyhedron_def {_1176324 : Type'} : (@polyhedron _1176324) = (fun _2008072 : (cart R _1176324) -> Prop => exists f : ((cart R _1176324) -> Prop) -> Prop, (@FINITE ((cart R _1176324) -> Prop) f) /\ ((_2008072 = (@INTERS (cart R _1176324) f)) /\ (forall h : (cart R _1176324) -> Prop, (@IN ((cart R _1176324) -> Prop) h f) -> exists a : cart R _1176324, exists b : R, (~ (a = (@vec _1176324 (NUMERAL 0%N)))) /\ (h = (@GSPEC (cart R _1176324) (fun GEN_PVAR_5307 : cart R _1176324 => exists x : cart R _1176324, @SETSPEC (cart R _1176324) GEN_PVAR_5307 (Rle (@dot _1176324 a x) b) x)))))).
Proof. exact (eq_refl (@polyhedron _1176324)). Qed.
Definition simplex {_1190765 : Type'} : Z -> ((cart R _1190765) -> Prop) -> Prop := fun _2263361 : Z => fun _2263362 : (cart R _1190765) -> Prop => exists c : (cart R _1190765) -> Prop, (~ (@affine_dependent _1190765 c)) /\ (((Z_of_N (@CARD (cart R _1190765) c)) = (Z.add _2263361 (Z_of_N (NUMERAL (BIT1 0%N))))) /\ (_2263362 = (@hull (cart R _1190765) (@convex _1190765) c))).
Lemma simplex_def {_1190765 : Type'} : (@simplex _1190765) = (fun _2263361 : Z => fun _2263362 : (cart R _1190765) -> Prop => exists c : (cart R _1190765) -> Prop, (~ (@affine_dependent _1190765 c)) /\ (((Z_of_N (@CARD (cart R _1190765) c)) = (Z.add _2263361 (Z_of_N (NUMERAL (BIT1 0%N))))) /\ (_2263362 = (@hull (cart R _1190765) (@convex _1190765) c)))).
Proof. exact (eq_refl (@simplex _1190765)). Qed.
Definition simplicial_complex {_1192993 : Type'} : (((cart R _1192993) -> Prop) -> Prop) -> Prop := fun _2267161 : ((cart R _1192993) -> Prop) -> Prop => (@FINITE ((cart R _1192993) -> Prop) _2267161) /\ ((forall s : (cart R _1192993) -> Prop, (@IN ((cart R _1192993) -> Prop) s _2267161) -> exists n : Z, @simplex _1192993 n s) /\ ((forall f : (cart R _1192993) -> Prop, forall s : (cart R _1192993) -> Prop, ((@IN ((cart R _1192993) -> Prop) s _2267161) /\ (@face_of _1192993 f s)) -> @IN ((cart R _1192993) -> Prop) f _2267161) /\ (forall s : (cart R _1192993) -> Prop, forall s' : (cart R _1192993) -> Prop, ((@IN ((cart R _1192993) -> Prop) s _2267161) /\ (@IN ((cart R _1192993) -> Prop) s' _2267161)) -> (@face_of _1192993 (@INTER (cart R _1192993) s s') s) /\ (@face_of _1192993 (@INTER (cart R _1192993) s s') s')))).
Lemma simplicial_complex_def {_1192993 : Type'} : (@simplicial_complex _1192993) = (fun _2267161 : ((cart R _1192993) -> Prop) -> Prop => (@FINITE ((cart R _1192993) -> Prop) _2267161) /\ ((forall s : (cart R _1192993) -> Prop, (@IN ((cart R _1192993) -> Prop) s _2267161) -> exists n : Z, @simplex _1192993 n s) /\ ((forall f : (cart R _1192993) -> Prop, forall s : (cart R _1192993) -> Prop, ((@IN ((cart R _1192993) -> Prop) s _2267161) /\ (@face_of _1192993 f s)) -> @IN ((cart R _1192993) -> Prop) f _2267161) /\ (forall s : (cart R _1192993) -> Prop, forall s' : (cart R _1192993) -> Prop, ((@IN ((cart R _1192993) -> Prop) s _2267161) /\ (@IN ((cart R _1192993) -> Prop) s' _2267161)) -> (@face_of _1192993 (@INTER (cart R _1192993) s s') s) /\ (@face_of _1192993 (@INTER (cart R _1192993) s s') s'))))).
Proof. exact (eq_refl (@simplicial_complex _1192993)). Qed.
Definition triangulation {N' : Type'} : (((cart R N') -> Prop) -> Prop) -> Prop := fun _2267166 : ((cart R N') -> Prop) -> Prop => (@FINITE ((cart R N') -> Prop) _2267166) /\ ((forall t : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) t _2267166) -> exists n : Z, @simplex N' n t) /\ (forall t : (cart R N') -> Prop, forall t' : (cart R N') -> Prop, ((@IN ((cart R N') -> Prop) t _2267166) /\ (@IN ((cart R N') -> Prop) t' _2267166)) -> (@face_of N' (@INTER (cart R N') t t') t) /\ (@face_of N' (@INTER (cart R N') t t') t'))).
Lemma triangulation_def {N' : Type'} : (@triangulation N') = (fun _2267166 : ((cart R N') -> Prop) -> Prop => (@FINITE ((cart R N') -> Prop) _2267166) /\ ((forall t : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) t _2267166) -> exists n : Z, @simplex N' n t) /\ (forall t : (cart R N') -> Prop, forall t' : (cart R N') -> Prop, ((@IN ((cart R N') -> Prop) t _2267166) /\ (@IN ((cart R N') -> Prop) t' _2267166)) -> (@face_of N' (@INTER (cart R N') t t') t) /\ (@face_of N' (@INTER (cart R N') t t') t')))).
Proof. exact (eq_refl (@triangulation N')). Qed.
Definition brouwer_degree1 {N' : Type'} : N -> ((cart R N') -> cart R N') -> Z := fun _2309665 : N => fun _2309666 : (cart R N') -> cart R N' => @COND Z ((N.le (NUMERAL (BIT1 0%N)) _2309665) /\ (N.le _2309665 (@dimindex N' (@UNIV N')))) (brouwer_degree2 (N.sub _2309665 (NUMERAL (BIT1 0%N))) (@o (N -> R) (cart R N') (N -> R) (fun x : cart R N' => fun i : N => @COND R ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i _2309665)) (@dollar R N' x i) (R_of_N (NUMERAL 0%N))) (@o (N -> R) (cart R N') (cart R N') _2309666 (fun x : N -> R => @lambda R N' (fun i : N => @COND R ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i _2309665)) (x i) (R_of_N (NUMERAL 0%N))))))) (Z_of_N (NUMERAL (BIT1 0%N))).
Lemma brouwer_degree1_def {N' : Type'} : (@brouwer_degree1 N') = (fun _2309665 : N => fun _2309666 : (cart R N') -> cart R N' => @COND Z ((N.le (NUMERAL (BIT1 0%N)) _2309665) /\ (N.le _2309665 (@dimindex N' (@UNIV N')))) (brouwer_degree2 (N.sub _2309665 (NUMERAL (BIT1 0%N))) (@o (N -> R) (cart R N') (N -> R) (fun x : cart R N' => fun i : N => @COND R ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i _2309665)) (@dollar R N' x i) (R_of_N (NUMERAL 0%N))) (@o (N -> R) (cart R N') (cart R N') _2309666 (fun x : N -> R => @lambda R N' (fun i : N => @COND R ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i _2309665)) (x i) (R_of_N (NUMERAL 0%N))))))) (Z_of_N (NUMERAL (BIT1 0%N)))).
Proof. exact (eq_refl (@brouwer_degree1 N')). Qed.
Definition brouwer_degree {N' : Type'} : ((cart R N') -> cart R N') -> Z := fun _2309677 : (cart R N') -> cart R N' => @brouwer_degree1 N' (@dimindex N' (@UNIV N')) _2309677.
Lemma brouwer_degree_def {N' : Type'} : (@brouwer_degree N') = (fun _2309677 : (cart R N') -> cart R N' => @brouwer_degree1 N' (@dimindex N' (@UNIV N')) _2309677).
Proof. exact (eq_refl (@brouwer_degree N')). Qed.
Definition retraction {N' : Type'} : (prod ((cart R N') -> Prop) ((cart R N') -> Prop)) -> ((cart R N') -> cart R N') -> Prop := fun _2316067 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => fun _2316068 : (cart R N') -> cart R N' => (@SUBSET (cart R N') (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) /\ ((@continuous_on N' N' _2316068 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) /\ ((@SUBSET (cart R N') (@IMAGE (cart R N') (cart R N') _2316068 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) /\ (forall x : cart R N', (@IN (cart R N') x (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) -> (_2316068 x) = x))).
Lemma retraction_def {N' : Type'} : (@retraction N') = (fun _2316067 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => fun _2316068 : (cart R N') -> cart R N' => (@SUBSET (cart R N') (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) /\ ((@continuous_on N' N' _2316068 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) /\ ((@SUBSET (cart R N') (@IMAGE (cart R N') (cart R N') _2316068 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) /\ (forall x : cart R N', (@IN (cart R N') x (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2316067)) -> (_2316068 x) = x)))).
Proof. exact (eq_refl (@retraction N')). Qed.
Definition retract_of {_1201478 : Type'} : ((cart R _1201478) -> Prop) -> ((cart R _1201478) -> Prop) -> Prop := fun _2316084 : (cart R _1201478) -> Prop => fun _2316085 : (cart R _1201478) -> Prop => exists r : (cart R _1201478) -> cart R _1201478, @retraction _1201478 (@pair ((cart R _1201478) -> Prop) ((cart R _1201478) -> Prop) _2316085 _2316084) r.
Lemma retract_of_def {_1201478 : Type'} : (@retract_of _1201478) = (fun _2316084 : (cart R _1201478) -> Prop => fun _2316085 : (cart R _1201478) -> Prop => exists r : (cart R _1201478) -> cart R _1201478, @retraction _1201478 (@pair ((cart R _1201478) -> Prop) ((cart R _1201478) -> Prop) _2316085 _2316084) r).
Proof. exact (eq_refl (@retract_of _1201478)). Qed.
Definition AR {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _2361783 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2361783 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> @retract_of (finite_sum N' unit) s' u.
Lemma AR_def {N' : Type'} : (@AR N') = (fun _2361783 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2361783 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> @retract_of (finite_sum N' unit) s' u).
Proof. exact (eq_refl (@AR N')). Qed.
Definition ANR {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _2361788 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2361788 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> exists t : (cart R (finite_sum N' unit)) -> Prop, (@open_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) t) /\ (@retract_of (finite_sum N' unit) s' t).
Lemma ANR_def {N' : Type'} : (@ANR N') = (fun _2361788 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2361788 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> exists t : (cart R (finite_sum N' unit)) -> Prop, (@open_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) t) /\ (@retract_of (finite_sum N' unit) s' t)).
Proof. exact (eq_refl (@ANR N')). Qed.
Definition ENR {_1210526 : Type'} : ((cart R _1210526) -> Prop) -> Prop := fun _2361793 : (cart R _1210526) -> Prop => exists u : (cart R _1210526) -> Prop, (@_open _1210526 u) /\ (@retract_of _1210526 _2361793 u).
Lemma ENR_def {_1210526 : Type'} : (@ENR _1210526) = (fun _2361793 : (cart R _1210526) -> Prop => exists u : (cart R _1210526) -> Prop, (@_open _1210526 u) /\ (@retract_of _1210526 _2361793 u)).
Proof. exact (eq_refl (@ENR _1210526)). Qed.
Definition interval_bij {N' : Type'} : (prod (cart R N') (cart R N')) -> (prod (cart R N') (cart R N')) -> (cart R N') -> cart R N' := fun _2459693 : prod (cart R N') (cart R N') => fun _2459694 : prod (cart R N') (cart R N') => fun _2459695 : cart R N' => @lambda R N' (fun i : N => Rplus (@dollar R N' (@fst (cart R N') (cart R N') _2459694) i) (Rmult (Rdiv (Rminus (@dollar R N' _2459695 i) (@dollar R N' (@fst (cart R N') (cart R N') _2459693) i)) (Rminus (@dollar R N' (@snd (cart R N') (cart R N') _2459693) i) (@dollar R N' (@fst (cart R N') (cart R N') _2459693) i))) (Rminus (@dollar R N' (@snd (cart R N') (cart R N') _2459694) i) (@dollar R N' (@fst (cart R N') (cart R N') _2459694) i)))).
Lemma interval_bij_def {N' : Type'} : (@interval_bij N') = (fun _2459693 : prod (cart R N') (cart R N') => fun _2459694 : prod (cart R N') (cart R N') => fun _2459695 : cart R N' => @lambda R N' (fun i : N => Rplus (@dollar R N' (@fst (cart R N') (cart R N') _2459694) i) (Rmult (Rdiv (Rminus (@dollar R N' _2459695 i) (@dollar R N' (@fst (cart R N') (cart R N') _2459693) i)) (Rminus (@dollar R N' (@snd (cart R N') (cart R N') _2459693) i) (@dollar R N' (@fst (cart R N') (cart R N') _2459693) i))) (Rminus (@dollar R N' (@snd (cart R N') (cart R N') _2459694) i) (@dollar R N' (@fst (cart R N') (cart R N') _2459694) i))))).
Proof. exact (eq_refl (@interval_bij N')). Qed.
Definition has_derivative {_1241185 _1241188 : Type'} : ((cart R _1241188) -> cart R _1241185) -> ((cart R _1241188) -> cart R _1241185) -> (net (cart R _1241188)) -> Prop := fun _2495383 : (cart R _1241188) -> cart R _1241185 => fun _2495384 : (cart R _1241188) -> cart R _1241185 => fun _2495385 : net (cart R _1241188) => (@linear _1241188 _1241185 _2495384) /\ (@FImp _1241185 (cart R _1241188) (fun y : cart R _1241188 => @percent _1241185 (Rinv (@vector_norm _1241188 (@vector_sub _1241188 y (@netlimit (cart R _1241188) _2495385)))) (@vector_sub _1241185 (_2495383 y) (@vector_add _1241185 (_2495383 (@netlimit (cart R _1241188) _2495385)) (_2495384 (@vector_sub _1241188 y (@netlimit (cart R _1241188) _2495385)))))) (@vec _1241185 (NUMERAL 0%N)) _2495385).
Lemma has_derivative_def {_1241185 _1241188 : Type'} : (@has_derivative _1241185 _1241188) = (fun _2495383 : (cart R _1241188) -> cart R _1241185 => fun _2495384 : (cart R _1241188) -> cart R _1241185 => fun _2495385 : net (cart R _1241188) => (@linear _1241188 _1241185 _2495384) /\ (@FImp _1241185 (cart R _1241188) (fun y : cart R _1241188 => @percent _1241185 (Rinv (@vector_norm _1241188 (@vector_sub _1241188 y (@netlimit (cart R _1241188) _2495385)))) (@vector_sub _1241185 (_2495383 y) (@vector_add _1241185 (_2495383 (@netlimit (cart R _1241188) _2495385)) (_2495384 (@vector_sub _1241188 y (@netlimit (cart R _1241188) _2495385)))))) (@vec _1241185 (NUMERAL 0%N)) _2495385)).
Proof. exact (eq_refl (@has_derivative _1241185 _1241188)). Qed.
Definition differentiable {_1243141 _1243142 : Type'} : ((cart R _1243142) -> cart R _1243141) -> (net (cart R _1243142)) -> Prop := fun _2495701 : (cart R _1243142) -> cart R _1243141 => fun _2495702 : net (cart R _1243142) => exists f' : (cart R _1243142) -> cart R _1243141, @has_derivative _1243141 _1243142 _2495701 f' _2495702.
Lemma differentiable_def {_1243141 _1243142 : Type'} : (@differentiable _1243141 _1243142) = (fun _2495701 : (cart R _1243142) -> cart R _1243141 => fun _2495702 : net (cart R _1243142) => exists f' : (cart R _1243142) -> cart R _1243141, @has_derivative _1243141 _1243142 _2495701 f' _2495702).
Proof. exact (eq_refl (@differentiable _1243141 _1243142)). Qed.
Definition differentiable_on {_1243159 _1243165 : Type'} : ((cart R _1243165) -> cart R _1243159) -> ((cart R _1243165) -> Prop) -> Prop := fun _2495713 : (cart R _1243165) -> cart R _1243159 => fun _2495714 : (cart R _1243165) -> Prop => forall x : cart R _1243165, (@IN (cart R _1243165) x _2495714) -> @differentiable _1243159 _1243165 _2495713 (@within (cart R _1243165) (@_at _1243165 x) _2495714).
Lemma differentiable_on_def {_1243159 _1243165 : Type'} : (@differentiable_on _1243159 _1243165) = (fun _2495713 : (cart R _1243165) -> cart R _1243159 => fun _2495714 : (cart R _1243165) -> Prop => forall x : cart R _1243165, (@IN (cart R _1243165) x _2495714) -> @differentiable _1243159 _1243165 _2495713 (@within (cart R _1243165) (@_at _1243165 x) _2495714)).
Proof. exact (eq_refl (@differentiable_on _1243159 _1243165)). Qed.
Definition frechet_derivative {_1243519 _1243520 : Type'} : ((cart R _1243520) -> cart R _1243519) -> (net (cart R _1243520)) -> (cart R _1243520) -> cart R _1243519 := fun _2496343 : (cart R _1243520) -> cart R _1243519 => fun _2496344 : net (cart R _1243520) => @ε ((cart R _1243520) -> cart R _1243519) (fun f' : (cart R _1243520) -> cart R _1243519 => @has_derivative _1243519 _1243520 _2496343 f' _2496344).
Lemma frechet_derivative_def {_1243519 _1243520 : Type'} : (@frechet_derivative _1243519 _1243520) = (fun _2496343 : (cart R _1243520) -> cart R _1243519 => fun _2496344 : net (cart R _1243520) => @ε ((cart R _1243520) -> cart R _1243519) (fun f' : (cart R _1243520) -> cart R _1243519 => @has_derivative _1243519 _1243520 _2496343 f' _2496344)).
Proof. exact (eq_refl (@frechet_derivative _1243519 _1243520)). Qed.
Definition jacobian {_1243578 _1243579 : Type'} : ((cart R _1243578) -> cart R _1243579) -> (net (cart R _1243578)) -> cart (cart R _1243578) _1243579 := fun _2496355 : (cart R _1243578) -> cart R _1243579 => fun _2496356 : net (cart R _1243578) => @matrix _1243578 _1243579 (@frechet_derivative _1243579 _1243578 _2496355 _2496356).
Lemma jacobian_def {_1243578 _1243579 : Type'} : (@jacobian _1243578 _1243579) = (fun _2496355 : (cart R _1243578) -> cart R _1243579 => fun _2496356 : net (cart R _1243578) => @matrix _1243578 _1243579 (@frechet_derivative _1243579 _1243578 _2496355 _2496356)).
Proof. exact (eq_refl (@jacobian _1243578 _1243579)). Qed.
Definition has_vector_derivative {_1272665 : Type'} : ((cart R unit) -> cart R _1272665) -> (cart R _1272665) -> (net (cart R unit)) -> Prop := fun _2661005 : (cart R unit) -> cart R _1272665 => fun _2661006 : cart R _1272665 => fun _2661007 : net (cart R unit) => @has_derivative _1272665 unit _2661005 (fun x : cart R unit => @percent _1272665 (drop x) _2661006) _2661007.
Lemma has_vector_derivative_def {_1272665 : Type'} : (@has_vector_derivative _1272665) = (fun _2661005 : (cart R unit) -> cart R _1272665 => fun _2661006 : cart R _1272665 => fun _2661007 : net (cart R unit) => @has_derivative _1272665 unit _2661005 (fun x : cart R unit => @percent _1272665 (drop x) _2661006) _2661007).
Proof. exact (eq_refl (@has_vector_derivative _1272665)). Qed.
Definition vector_derivative {N' : Type'} : ((cart R unit) -> cart R N') -> (net (cart R unit)) -> cart R N' := fun _2661026 : (cart R unit) -> cart R N' => fun _2661027 : net (cart R unit) => @ε (cart R N') (fun f' : cart R N' => @has_vector_derivative N' _2661026 f' _2661027).
Lemma vector_derivative_def {N' : Type'} : (@vector_derivative N') = (fun _2661026 : (cart R unit) -> cart R N' => fun _2661027 : net (cart R unit) => @ε (cart R N') (fun f' : cart R N' => @has_vector_derivative N' _2661026 f' _2661027)).
Proof. exact (eq_refl (@vector_derivative N')). Qed.
Definition bitset : N -> N -> Prop := fun _2663271 : N => @GSPEC N (fun GEN_PVAR_5739 : N => exists i : N, @SETSPEC N GEN_PVAR_5739 (ODD (N.div _2663271 (N.pow (NUMERAL (BIT0 (BIT1 0%N))) i))) i).
Lemma bitset_def : bitset = (fun _2663271 : N => @GSPEC N (fun GEN_PVAR_5739 : N => exists i : N, @SETSPEC N GEN_PVAR_5739 (ODD (N.div _2663271 (N.pow (NUMERAL (BIT0 (BIT1 0%N))) i))) i)).
Proof. exact (eq_refl bitset). Qed.
Definition binarysum : (N -> Prop) -> N := fun _2663276 : N -> Prop => @nsum N _2663276 (fun i : N => N.pow (NUMERAL (BIT0 (BIT1 0%N))) i).
Lemma binarysum_def : binarysum = (fun _2663276 : N -> Prop => @nsum N _2663276 (fun i : N => N.pow (NUMERAL (BIT0 (BIT1 0%N))) i)).
Proof. exact (eq_refl binarysum). Qed.
Definition setcode : (N -> Prop) -> N := fun _2664142 : N -> Prop => N.add (NUMERAL (BIT1 0%N)) (binarysum (@IMAGE N N N.pred _2664142)).
Lemma setcode_def : setcode = (fun _2664142 : N -> Prop => N.add (NUMERAL (BIT1 0%N)) (binarysum (@IMAGE N N N.pred _2664142))).
Proof. exact (eq_refl setcode). Qed.
Definition codeset : N -> N -> Prop := fun _2664147 : N => @IMAGE N N N.succ (bitset (N.sub _2664147 (NUMERAL (BIT1 0%N)))).
Lemma codeset_def : codeset = (fun _2664147 : N => @IMAGE N N N.succ (bitset (N.sub _2664147 (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl codeset). Qed.
Definition dollardollar {N' : Type'} : (cart R (Multivector N')) -> (N -> Prop) -> R := fun _2664473 : cart R (Multivector N') => fun _2664474 : N -> Prop => @dollar R (Multivector N') _2664473 (setcode _2664474).
Lemma dollardollar_def {N' : Type'} : (@dollardollar N') = (fun _2664473 : cart R (Multivector N') => fun _2664474 : N -> Prop => @dollar R (Multivector N') _2664473 (setcode _2664474)).
Proof. exact (eq_refl (@dollardollar N')). Qed.
Definition lambdas {N' : Type'} : ((N -> Prop) -> R) -> cart R (Multivector N') := fun _2664485 : (N -> Prop) -> R => @lambda R (Multivector N') (fun i : N => _2664485 (codeset i)).
Lemma lambdas_def {N' : Type'} : (@lambdas N') = (fun _2664485 : (N -> Prop) -> R => @lambda R (Multivector N') (fun i : N => _2664485 (codeset i))).
Proof. exact (eq_refl (@lambdas N')). Qed.
Definition mbasis {_1278771 : Type'} : (N -> Prop) -> cart R (Multivector _1278771) := fun _2664528 : N -> Prop => @lambdas _1278771 (fun s : N -> Prop => @COND R (_2664528 = s) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))).
Lemma mbasis_def {_1278771 : Type'} : (@mbasis _1278771) = (fun _2664528 : N -> Prop => @lambdas _1278771 (fun s : N -> Prop => @COND R (_2664528 = s) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl (@mbasis _1278771)). Qed.
Definition multivec {N' : Type'} : (cart R N') -> cart R (Multivector N') := fun _2664804 : cart R N' => @vsum N (Multivector N') (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => @percent (Multivector N') (@dollar R N' _2664804 i) (@mbasis N' (@INSERT N i (@EMPTY N)))).
Lemma multivec_def {N' : Type'} : (@multivec N') = (fun _2664804 : cart R N' => @vsum N (Multivector N') (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N'))) (fun i : N => @percent (Multivector N') (@dollar R N' _2664804 i) (@mbasis N' (@INSERT N i (@EMPTY N))))).
Proof. exact (eq_refl (@multivec N')). Qed.
Definition multivector {N' : Type'} : N -> (cart R (Multivector N')) -> Prop := fun _2664809 : N => fun _2664810 : cart R (Multivector N') => forall s : N -> Prop, ((@SUBSET N s (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ (~ ((@dollardollar N' _2664810 s) = (R_of_N (NUMERAL 0%N))))) -> @HAS_SIZE N s _2664809.
Lemma multivector_def {N' : Type'} : (@multivector N') = (fun _2664809 : N => fun _2664810 : cart R (Multivector N') => forall s : N -> Prop, ((@SUBSET N s (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ (~ ((@dollardollar N' _2664810 s) = (R_of_N (NUMERAL 0%N))))) -> @HAS_SIZE N s _2664809).
Proof. exact (eq_refl (@multivector N')). Qed.
Definition grade {N' : Type'} : N -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2664821 : N => fun _2664822 : cart R (Multivector N') => @lambdas N' (fun s : N -> Prop => @COND R (@HAS_SIZE N s _2664821) (@dollardollar N' _2664822 s) (R_of_N (NUMERAL 0%N))).
Lemma grade_def {N' : Type'} : (@grade N') = (fun _2664821 : N => fun _2664822 : cart R (Multivector N') => @lambdas N' (fun s : N -> Prop => @COND R (@HAS_SIZE N s _2664821) (@dollardollar N' _2664822 s) (R_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl (@grade N')). Qed.
Definition Product {N' : Type'} : ((N -> Prop) -> (N -> Prop) -> R) -> ((N -> Prop) -> (N -> Prop) -> N -> Prop) -> (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2664837 : (N -> Prop) -> (N -> Prop) -> R => fun _2664838 : (N -> Prop) -> (N -> Prop) -> N -> Prop => fun _2664839 : cart R (Multivector N') => fun _2664840 : cart R (Multivector N') => @vsum (N -> Prop) (Multivector N') (@GSPEC (N -> Prop) (fun GEN_PVAR_5752 : N -> Prop => exists s : N -> Prop, @SETSPEC (N -> Prop) GEN_PVAR_5752 (@SUBSET N s (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) s)) (fun s : N -> Prop => @vsum (N -> Prop) (Multivector N') (@GSPEC (N -> Prop) (fun GEN_PVAR_5753 : N -> Prop => exists s' : N -> Prop, @SETSPEC (N -> Prop) GEN_PVAR_5753 (@SUBSET N s' (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) s')) (fun t : N -> Prop => @percent (Multivector N') (Rmult (@dollardollar N' _2664839 s) (Rmult (@dollardollar N' _2664840 t) (_2664837 s t))) (@mbasis N' (_2664838 s t)))).
Lemma Product_def {N' : Type'} : (@Product N') = (fun _2664837 : (N -> Prop) -> (N -> Prop) -> R => fun _2664838 : (N -> Prop) -> (N -> Prop) -> N -> Prop => fun _2664839 : cart R (Multivector N') => fun _2664840 : cart R (Multivector N') => @vsum (N -> Prop) (Multivector N') (@GSPEC (N -> Prop) (fun GEN_PVAR_5752 : N -> Prop => exists s : N -> Prop, @SETSPEC (N -> Prop) GEN_PVAR_5752 (@SUBSET N s (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) s)) (fun s : N -> Prop => @vsum (N -> Prop) (Multivector N') (@GSPEC (N -> Prop) (fun GEN_PVAR_5753 : N -> Prop => exists s' : N -> Prop, @SETSPEC (N -> Prop) GEN_PVAR_5753 (@SUBSET N s' (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) s')) (fun t : N -> Prop => @percent (Multivector N') (Rmult (@dollardollar N' _2664839 s) (Rmult (@dollardollar N' _2664840 t) (_2664837 s t))) (@mbasis N' (_2664838 s t))))).
Proof. exact (eq_refl (@Product N')). Qed.
Definition geom_mul {N' : Type'} : (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2666016 : cart R (Multivector N') => fun _2666017 : cart R (Multivector N') => @Product N' (fun s : N -> Prop => fun t : N -> Prop => Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (@CARD (prod N N) (@GSPEC (prod N N) (fun GEN_PVAR_5755 : prod N N => exists i : N, exists j : N, @SETSPEC (prod N N) GEN_PVAR_5755 ((@IN N i (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N j (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N i s) /\ ((@IN N j t) /\ (N.gt i j))))) (@pair N N i j))))) (fun s : N -> Prop => fun t : N -> Prop => @UNION N (@DIFF N s t) (@DIFF N t s)) _2666016 _2666017.
Lemma geom_mul_def {N' : Type'} : (@geom_mul N') = (fun _2666016 : cart R (Multivector N') => fun _2666017 : cart R (Multivector N') => @Product N' (fun s : N -> Prop => fun t : N -> Prop => Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (@CARD (prod N N) (@GSPEC (prod N N) (fun GEN_PVAR_5755 : prod N N => exists i : N, exists j : N, @SETSPEC (prod N N) GEN_PVAR_5755 ((@IN N i (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N j (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N i s) /\ ((@IN N j t) /\ (N.gt i j))))) (@pair N N i j))))) (fun s : N -> Prop => fun t : N -> Prop => @UNION N (@DIFF N s t) (@DIFF N t s)) _2666016 _2666017).
Proof. exact (eq_refl (@geom_mul N')). Qed.
Definition outer {N' : Type'} : (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2666100 : cart R (Multivector N') => fun _2666101 : cart R (Multivector N') => @Product N' (fun s : N -> Prop => fun t : N -> Prop => @COND R (~ ((@INTER N s t) = (@EMPTY N))) (R_of_N (NUMERAL 0%N)) (Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (@CARD (prod N N) (@GSPEC (prod N N) (fun GEN_PVAR_5756 : prod N N => exists i : N, exists j : N, @SETSPEC (prod N N) GEN_PVAR_5756 ((@IN N i (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N j (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N i s) /\ ((@IN N j t) /\ (N.gt i j))))) (@pair N N i j)))))) (fun s : N -> Prop => fun t : N -> Prop => @UNION N (@DIFF N s t) (@DIFF N t s)) _2666100 _2666101.
Lemma outer_def {N' : Type'} : (@outer N') = (fun _2666100 : cart R (Multivector N') => fun _2666101 : cart R (Multivector N') => @Product N' (fun s : N -> Prop => fun t : N -> Prop => @COND R (~ ((@INTER N s t) = (@EMPTY N))) (R_of_N (NUMERAL 0%N)) (Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (@CARD (prod N N) (@GSPEC (prod N N) (fun GEN_PVAR_5756 : prod N N => exists i : N, exists j : N, @SETSPEC (prod N N) GEN_PVAR_5756 ((@IN N i (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N j (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N i s) /\ ((@IN N j t) /\ (N.gt i j))))) (@pair N N i j)))))) (fun s : N -> Prop => fun t : N -> Prop => @UNION N (@DIFF N s t) (@DIFF N t s)) _2666100 _2666101).
Proof. exact (eq_refl (@outer N')). Qed.
Definition inner {N' : Type'} : (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2666286 : cart R (Multivector N') => fun _2666287 : cart R (Multivector N') => @Product N' (fun s : N -> Prop => fun t : N -> Prop => @COND R ((s = (@EMPTY N)) \/ ((t = (@EMPTY N)) \/ (~ (((@DIFF N s t) = (@EMPTY N)) /\ (~ ((@DIFF N t s) = (@EMPTY N))))))) (R_of_N (NUMERAL 0%N)) (Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (@CARD (prod N N) (@GSPEC (prod N N) (fun GEN_PVAR_5758 : prod N N => exists i : N, exists j : N, @SETSPEC (prod N N) GEN_PVAR_5758 ((@IN N i (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N j (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N i s) /\ ((@IN N j t) /\ (N.gt i j))))) (@pair N N i j)))))) (fun s : N -> Prop => fun t : N -> Prop => @UNION N (@DIFF N s t) (@DIFF N t s)) _2666286 _2666287.
Lemma inner_def {N' : Type'} : (@inner N') = (fun _2666286 : cart R (Multivector N') => fun _2666287 : cart R (Multivector N') => @Product N' (fun s : N -> Prop => fun t : N -> Prop => @COND R ((s = (@EMPTY N)) \/ ((t = (@EMPTY N)) \/ (~ (((@DIFF N s t) = (@EMPTY N)) /\ (~ ((@DIFF N t s) = (@EMPTY N))))))) (R_of_N (NUMERAL 0%N)) (Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (@CARD (prod N N) (@GSPEC (prod N N) (fun GEN_PVAR_5758 : prod N N => exists i : N, exists j : N, @SETSPEC (prod N N) GEN_PVAR_5758 ((@IN N i (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N j (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) /\ ((@IN N i s) /\ ((@IN N j t) /\ (N.gt i j))))) (@pair N N i j)))))) (fun s : N -> Prop => fun t : N -> Prop => @UNION N (@DIFF N s t) (@DIFF N t s)) _2666286 _2666287).
Proof. exact (eq_refl (@inner N')). Qed.
Definition seqiterate {_1282116 : Type'} : (_1282116 -> _1282116 -> _1282116) -> (N -> Prop) -> (N -> _1282116) -> _1282116 := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (_1282116 -> _1282116 -> _1282116) -> (N -> Prop) -> (N -> _1282116) -> _1282116) (fun h : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (_1282116 -> _1282116 -> _1282116) -> (N -> Prop) -> (N -> _1282116) -> _1282116 => forall _2667927 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))), forall op : _1282116 -> _1282116 -> _1282116, forall f : N -> _1282116, forall s : N -> Prop, (h _2667927 op s f) = (@COND _1282116 ((@INFINITE N s) \/ (s = (@EMPTY N))) (@neutral _1282116 op) (@LET N _1282116 (fun i : N => @LET_END _1282116 (@COND _1282116 (s = (@INSERT N i (@EMPTY N))) (f i) (op (f i) (h _2667927 op (@DELETE N s i) f)))) (minimal (fun x : N => @IN N x s))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))).
Lemma seqiterate_def {_1282116 : Type'} : (@seqiterate _1282116) = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (_1282116 -> _1282116 -> _1282116) -> (N -> Prop) -> (N -> _1282116) -> _1282116) (fun h : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) -> (_1282116 -> _1282116 -> _1282116) -> (N -> Prop) -> (N -> _1282116) -> _1282116 => forall _2667927 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))), forall op : _1282116 -> _1282116 -> _1282116, forall f : N -> _1282116, forall s : N -> Prop, (h _2667927 op s f) = (@COND _1282116 ((@INFINITE N s) \/ (s = (@EMPTY N))) (@neutral _1282116 op) (@LET N _1282116 (fun i : N => @LET_END _1282116 (@COND _1282116 (s = (@INSERT N i (@EMPTY N))) (f i) (op (f i) (h _2667927 op (@DELETE N s i) f)))) (minimal (fun x : N => @IN N x s))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))).
Proof. exact (eq_refl (@seqiterate _1282116)). Qed.
Definition outermorphism {N' P : Type'} : ((cart R N') -> cart R P) -> (cart R (Multivector N')) -> cart R (Multivector P) := fun _2668197 : (cart R N') -> cart R P => fun _2668198 : cart R (Multivector N') => @vsum (N -> Prop) (Multivector P) (@GSPEC (N -> Prop) (fun GEN_PVAR_5766 : N -> Prop => exists s : N -> Prop, @SETSPEC (N -> Prop) GEN_PVAR_5766 (@SUBSET N s (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) s)) (fun s : N -> Prop => @percent (Multivector P) (@dollardollar N' _2668198 s) (@seqiterate (cart R (Multivector P)) (@outer P) s (@o N (cart R P) (cart R (Multivector P)) (@multivec P) (@o N (cart R N') (cart R P) _2668197 (@basis N'))))).
Lemma outermorphism_def {N' P : Type'} : (@outermorphism N' P) = (fun _2668197 : (cart R N') -> cart R P => fun _2668198 : cart R (Multivector N') => @vsum (N -> Prop) (Multivector P) (@GSPEC (N -> Prop) (fun GEN_PVAR_5766 : N -> Prop => exists s : N -> Prop, @SETSPEC (N -> Prop) GEN_PVAR_5766 (@SUBSET N s (dotdot (NUMERAL (BIT1 0%N)) (@dimindex N' (@UNIV N')))) s)) (fun s : N -> Prop => @percent (Multivector P) (@dollardollar N' _2668198 s) (@seqiterate (cart R (Multivector P)) (@outer P) s (@o N (cart R P) (cart R (Multivector P)) (@multivec P) (@o N (cart R N') (cart R P) _2668197 (@basis N')))))).
Proof. exact (eq_refl (@outermorphism N' P)). Qed.
Definition reversion {N' : Type'} : (cart R (Multivector N')) -> cart R (Multivector N') := fun _2668316 : cart R (Multivector N') => @lambdas N' (fun s : N -> Prop => Rmult (Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (N.div (N.mul (@CARD N s) (N.sub (@CARD N s) (NUMERAL (BIT1 0%N)))) (NUMERAL (BIT0 (BIT1 0%N))))) (@dollardollar N' _2668316 s)).
Lemma reversion_def {N' : Type'} : (@reversion N') = (fun _2668316 : cart R (Multivector N') => @lambdas N' (fun s : N -> Prop => Rmult (Rpow (Ropp (R_of_N (NUMERAL (BIT1 0%N)))) (N.div (N.mul (@CARD N s) (N.sub (@CARD N s) (NUMERAL (BIT1 0%N)))) (NUMERAL (BIT0 (BIT1 0%N))))) (@dollardollar N' _2668316 s))).
Proof. exact (eq_refl (@reversion N')). Qed.
Definition interval_upperbound {M : Type'} : ((cart R M) -> Prop) -> cart R M := fun _2668631 : (cart R M) -> Prop => @lambda R M (fun i : N => sup (@GSPEC R (fun GEN_PVAR_5770 : R => exists a : R, @SETSPEC R GEN_PVAR_5770 (exists x : cart R M, (@IN (cart R M) x _2668631) /\ ((@dollar R M x i) = a)) a))).
Lemma interval_upperbound_def {M : Type'} : (@interval_upperbound M) = (fun _2668631 : (cart R M) -> Prop => @lambda R M (fun i : N => sup (@GSPEC R (fun GEN_PVAR_5770 : R => exists a : R, @SETSPEC R GEN_PVAR_5770 (exists x : cart R M, (@IN (cart R M) x _2668631) /\ ((@dollar R M x i) = a)) a)))).
Proof. exact (eq_refl (@interval_upperbound M)). Qed.
Definition interval_lowerbound {M : Type'} : ((cart R M) -> Prop) -> cart R M := fun _2668636 : (cart R M) -> Prop => @lambda R M (fun i : N => inf (@GSPEC R (fun GEN_PVAR_5771 : R => exists a : R, @SETSPEC R GEN_PVAR_5771 (exists x : cart R M, (@IN (cart R M) x _2668636) /\ ((@dollar R M x i) = a)) a))).
Lemma interval_lowerbound_def {M : Type'} : (@interval_lowerbound M) = (fun _2668636 : (cart R M) -> Prop => @lambda R M (fun i : N => inf (@GSPEC R (fun GEN_PVAR_5771 : R => exists a : R, @SETSPEC R GEN_PVAR_5771 (exists x : cart R M, (@IN (cart R M) x _2668636) /\ ((@dollar R M x i) = a)) a)))).
Proof. exact (eq_refl (@interval_lowerbound M)). Qed.
Definition content {M : Type'} : ((cart R M) -> Prop) -> R := fun _2668743 : (cart R M) -> Prop => @COND R (_2668743 = (@EMPTY (cart R M))) (R_of_N (NUMERAL 0%N)) (@product N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex M (@UNIV M))) (fun i : N => Rminus (@dollar R M (@interval_upperbound M _2668743) i) (@dollar R M (@interval_lowerbound M _2668743) i))).
Lemma content_def {M : Type'} : (@content M) = (fun _2668743 : (cart R M) -> Prop => @COND R (_2668743 = (@EMPTY (cart R M))) (R_of_N (NUMERAL 0%N)) (@product N (dotdot (NUMERAL (BIT1 0%N)) (@dimindex M (@UNIV M))) (fun i : N => Rminus (@dollar R M (@interval_upperbound M _2668743) i) (@dollar R M (@interval_lowerbound M _2668743) i)))).
Proof. exact (eq_refl (@content M)). Qed.
Definition gauge {_1284928 : Type'} : ((cart R _1284928) -> (cart R _1284928) -> Prop) -> Prop := fun _2669577 : (cart R _1284928) -> (cart R _1284928) -> Prop => forall x : cart R _1284928, (@IN (cart R _1284928) x (_2669577 x)) /\ (@_open _1284928 (_2669577 x)).
Lemma gauge_def {_1284928 : Type'} : (@gauge _1284928) = (fun _2669577 : (cart R _1284928) -> (cart R _1284928) -> Prop => forall x : cart R _1284928, (@IN (cart R _1284928) x (_2669577 x)) /\ (@_open _1284928 (_2669577 x))).
Proof. exact (eq_refl (@gauge _1284928)). Qed.
Definition division_of {_1285232 : Type'} : (((cart R _1285232) -> Prop) -> Prop) -> ((cart R _1285232) -> Prop) -> Prop := fun _2669616 : ((cart R _1285232) -> Prop) -> Prop => fun _2669617 : (cart R _1285232) -> Prop => (@FINITE ((cart R _1285232) -> Prop) _2669616) /\ ((forall k : (cart R _1285232) -> Prop, (@IN ((cart R _1285232) -> Prop) k _2669616) -> (@SUBSET (cart R _1285232) k _2669617) /\ ((~ (k = (@EMPTY (cart R _1285232)))) /\ (exists a : cart R _1285232, exists b : cart R _1285232, k = (@closed_interval _1285232 (@cons (prod (cart R _1285232) (cart R _1285232)) (@pair (cart R _1285232) (cart R _1285232) a b) (@nil (prod (cart R _1285232) (cart R _1285232)))))))) /\ ((forall k1 : (cart R _1285232) -> Prop, forall k2 : (cart R _1285232) -> Prop, ((@IN ((cart R _1285232) -> Prop) k1 _2669616) /\ ((@IN ((cart R _1285232) -> Prop) k2 _2669616) /\ (~ (k1 = k2)))) -> (@INTER (cart R _1285232) (@interior _1285232 k1) (@interior _1285232 k2)) = (@EMPTY (cart R _1285232))) /\ ((@UNIONS (cart R _1285232) _2669616) = _2669617))).
Lemma division_of_def {_1285232 : Type'} : (@division_of _1285232) = (fun _2669616 : ((cart R _1285232) -> Prop) -> Prop => fun _2669617 : (cart R _1285232) -> Prop => (@FINITE ((cart R _1285232) -> Prop) _2669616) /\ ((forall k : (cart R _1285232) -> Prop, (@IN ((cart R _1285232) -> Prop) k _2669616) -> (@SUBSET (cart R _1285232) k _2669617) /\ ((~ (k = (@EMPTY (cart R _1285232)))) /\ (exists a : cart R _1285232, exists b : cart R _1285232, k = (@closed_interval _1285232 (@cons (prod (cart R _1285232) (cart R _1285232)) (@pair (cart R _1285232) (cart R _1285232) a b) (@nil (prod (cart R _1285232) (cart R _1285232)))))))) /\ ((forall k1 : (cart R _1285232) -> Prop, forall k2 : (cart R _1285232) -> Prop, ((@IN ((cart R _1285232) -> Prop) k1 _2669616) /\ ((@IN ((cart R _1285232) -> Prop) k2 _2669616) /\ (~ (k1 = k2)))) -> (@INTER (cart R _1285232) (@interior _1285232 k1) (@interior _1285232 k2)) = (@EMPTY (cart R _1285232))) /\ ((@UNIONS (cart R _1285232) _2669616) = _2669617)))).
Proof. exact (eq_refl (@division_of _1285232)). Qed.
Definition tagged_partial_division_of {_1290787 : Type'} : ((prod (cart R _1290787) ((cart R _1290787) -> Prop)) -> Prop) -> ((cart R _1290787) -> Prop) -> Prop := fun _2700728 : (prod (cart R _1290787) ((cart R _1290787) -> Prop)) -> Prop => fun _2700729 : (cart R _1290787) -> Prop => (@FINITE (prod (cart R _1290787) ((cart R _1290787) -> Prop)) _2700728) /\ ((forall x : cart R _1290787, forall k : (cart R _1290787) -> Prop, (@IN (prod (cart R _1290787) ((cart R _1290787) -> Prop)) (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x k) _2700728) -> (@IN (cart R _1290787) x k) /\ ((@SUBSET (cart R _1290787) k _2700729) /\ (exists a : cart R _1290787, exists b : cart R _1290787, k = (@closed_interval _1290787 (@cons (prod (cart R _1290787) (cart R _1290787)) (@pair (cart R _1290787) (cart R _1290787) a b) (@nil (prod (cart R _1290787) (cart R _1290787)))))))) /\ (forall x1 : cart R _1290787, forall k1 : (cart R _1290787) -> Prop, forall x2 : cart R _1290787, forall k2 : (cart R _1290787) -> Prop, ((@IN (prod (cart R _1290787) ((cart R _1290787) -> Prop)) (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x1 k1) _2700728) /\ ((@IN (prod (cart R _1290787) ((cart R _1290787) -> Prop)) (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x2 k2) _2700728) /\ (~ ((@pair (cart R _1290787) ((cart R _1290787) -> Prop) x1 k1) = (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x2 k2))))) -> (@INTER (cart R _1290787) (@interior _1290787 k1) (@interior _1290787 k2)) = (@EMPTY (cart R _1290787)))).
Lemma tagged_partial_division_of_def {_1290787 : Type'} : (@tagged_partial_division_of _1290787) = (fun _2700728 : (prod (cart R _1290787) ((cart R _1290787) -> Prop)) -> Prop => fun _2700729 : (cart R _1290787) -> Prop => (@FINITE (prod (cart R _1290787) ((cart R _1290787) -> Prop)) _2700728) /\ ((forall x : cart R _1290787, forall k : (cart R _1290787) -> Prop, (@IN (prod (cart R _1290787) ((cart R _1290787) -> Prop)) (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x k) _2700728) -> (@IN (cart R _1290787) x k) /\ ((@SUBSET (cart R _1290787) k _2700729) /\ (exists a : cart R _1290787, exists b : cart R _1290787, k = (@closed_interval _1290787 (@cons (prod (cart R _1290787) (cart R _1290787)) (@pair (cart R _1290787) (cart R _1290787) a b) (@nil (prod (cart R _1290787) (cart R _1290787)))))))) /\ (forall x1 : cart R _1290787, forall k1 : (cart R _1290787) -> Prop, forall x2 : cart R _1290787, forall k2 : (cart R _1290787) -> Prop, ((@IN (prod (cart R _1290787) ((cart R _1290787) -> Prop)) (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x1 k1) _2700728) /\ ((@IN (prod (cart R _1290787) ((cart R _1290787) -> Prop)) (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x2 k2) _2700728) /\ (~ ((@pair (cart R _1290787) ((cart R _1290787) -> Prop) x1 k1) = (@pair (cart R _1290787) ((cart R _1290787) -> Prop) x2 k2))))) -> (@INTER (cart R _1290787) (@interior _1290787 k1) (@interior _1290787 k2)) = (@EMPTY (cart R _1290787))))).
Proof. exact (eq_refl (@tagged_partial_division_of _1290787)). Qed.
Definition tagged_division_of {_1290798 : Type'} : ((prod (cart R _1290798) ((cart R _1290798) -> Prop)) -> Prop) -> ((cart R _1290798) -> Prop) -> Prop := fun _2700740 : (prod (cart R _1290798) ((cart R _1290798) -> Prop)) -> Prop => fun _2700741 : (cart R _1290798) -> Prop => (@tagged_partial_division_of _1290798 _2700740 _2700741) /\ ((@UNIONS (cart R _1290798) (@GSPEC ((cart R _1290798) -> Prop) (fun GEN_PVAR_5795 : (cart R _1290798) -> Prop => exists k : (cart R _1290798) -> Prop, @SETSPEC ((cart R _1290798) -> Prop) GEN_PVAR_5795 (exists x : cart R _1290798, @IN (prod (cart R _1290798) ((cart R _1290798) -> Prop)) (@pair (cart R _1290798) ((cart R _1290798) -> Prop) x k) _2700740) k))) = _2700741).
Lemma tagged_division_of_def {_1290798 : Type'} : (@tagged_division_of _1290798) = (fun _2700740 : (prod (cart R _1290798) ((cart R _1290798) -> Prop)) -> Prop => fun _2700741 : (cart R _1290798) -> Prop => (@tagged_partial_division_of _1290798 _2700740 _2700741) /\ ((@UNIONS (cart R _1290798) (@GSPEC ((cart R _1290798) -> Prop) (fun GEN_PVAR_5795 : (cart R _1290798) -> Prop => exists k : (cart R _1290798) -> Prop, @SETSPEC ((cart R _1290798) -> Prop) GEN_PVAR_5795 (exists x : cart R _1290798, @IN (prod (cart R _1290798) ((cart R _1290798) -> Prop)) (@pair (cart R _1290798) ((cart R _1290798) -> Prop) x k) _2700740) k))) = _2700741)).
Proof. exact (eq_refl (@tagged_division_of _1290798)). Qed.
Definition fine {_1292404 _1292405 : Type'} : (_1292405 -> _1292404 -> Prop) -> ((prod _1292405 (_1292404 -> Prop)) -> Prop) -> Prop := fun _2707544 : _1292405 -> _1292404 -> Prop => fun _2707545 : (prod _1292405 (_1292404 -> Prop)) -> Prop => forall x : _1292405, forall k : _1292404 -> Prop, (@IN (prod _1292405 (_1292404 -> Prop)) (@pair _1292405 (_1292404 -> Prop) x k) _2707545) -> @SUBSET _1292404 k (_2707544 x).
Lemma fine_def {_1292404 _1292405 : Type'} : (@fine _1292404 _1292405) = (fun _2707544 : _1292405 -> _1292404 -> Prop => fun _2707545 : (prod _1292405 (_1292404 -> Prop)) -> Prop => forall x : _1292405, forall k : _1292404 -> Prop, (@IN (prod _1292405 (_1292404 -> Prop)) (@pair _1292405 (_1292404 -> Prop) x k) _2707545) -> @SUBSET _1292404 k (_2707544 x)).
Proof. exact (eq_refl (@fine _1292404 _1292405)). Qed.
Definition has_integral_compact_interval {_1292658 _1292690 : Type'} : ((cart R _1292658) -> cart R _1292690) -> (cart R _1292690) -> ((cart R _1292658) -> Prop) -> Prop := fun _2707632 : (cart R _1292658) -> cart R _1292690 => fun _2707633 : cart R _1292690 => fun _2707634 : (cart R _1292658) -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : (cart R _1292658) -> (cart R _1292658) -> Prop, (@gauge _1292658 d) /\ (forall p : (prod (cart R _1292658) ((cart R _1292658) -> Prop)) -> Prop, ((@tagged_division_of _1292658 p _2707634) /\ (@fine (cart R _1292658) (cart R _1292658) d p)) -> Rlt (@vector_norm _1292690 (@vector_sub _1292690 (@vsum (prod (cart R _1292658) ((cart R _1292658) -> Prop)) _1292690 p (@GABS ((prod (cart R _1292658) ((cart R _1292658) -> Prop)) -> cart R _1292690) (fun f : (prod (cart R _1292658) ((cart R _1292658) -> Prop)) -> cart R _1292690 => forall x : cart R _1292658, forall k : (cart R _1292658) -> Prop, @GEQ (cart R _1292690) (f (@pair (cart R _1292658) ((cart R _1292658) -> Prop) x k)) (@percent _1292690 (@content _1292658 k) (_2707632 x))))) _2707633)) e).
Lemma has_integral_compact_interval_def {_1292658 _1292690 : Type'} : (@has_integral_compact_interval _1292658 _1292690) = (fun _2707632 : (cart R _1292658) -> cart R _1292690 => fun _2707633 : cart R _1292690 => fun _2707634 : (cart R _1292658) -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : (cart R _1292658) -> (cart R _1292658) -> Prop, (@gauge _1292658 d) /\ (forall p : (prod (cart R _1292658) ((cart R _1292658) -> Prop)) -> Prop, ((@tagged_division_of _1292658 p _2707634) /\ (@fine (cart R _1292658) (cart R _1292658) d p)) -> Rlt (@vector_norm _1292690 (@vector_sub _1292690 (@vsum (prod (cart R _1292658) ((cart R _1292658) -> Prop)) _1292690 p (@GABS ((prod (cart R _1292658) ((cart R _1292658) -> Prop)) -> cart R _1292690) (fun f : (prod (cart R _1292658) ((cart R _1292658) -> Prop)) -> cart R _1292690 => forall x : cart R _1292658, forall k : (cart R _1292658) -> Prop, @GEQ (cart R _1292690) (f (@pair (cart R _1292658) ((cart R _1292658) -> Prop) x k)) (@percent _1292690 (@content _1292658 k) (_2707632 x))))) _2707633)) e)).
Proof. exact (eq_refl (@has_integral_compact_interval _1292658 _1292690)). Qed.
Definition has_integral {_1292827 _1292831 : Type'} : ((cart R _1292827) -> cart R _1292831) -> (cart R _1292831) -> ((cart R _1292827) -> Prop) -> Prop := fun _2707653 : (cart R _1292827) -> cart R _1292831 => fun _2707654 : cart R _1292831 => fun _2707655 : (cart R _1292827) -> Prop => @COND Prop (exists a : cart R _1292827, exists b : cart R _1292827, _2707655 = (@closed_interval _1292827 (@cons (prod (cart R _1292827) (cart R _1292827)) (@pair (cart R _1292827) (cart R _1292827) a b) (@nil (prod (cart R _1292827) (cart R _1292827)))))) (@has_integral_compact_interval _1292827 _1292831 _2707653 _2707654 _2707655) (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists B : R, (Rlt (R_of_N (NUMERAL 0%N)) B) /\ (forall a : cart R _1292827, forall b : cart R _1292827, (@SUBSET (cart R _1292827) (@ball _1292827 (@pair (cart R _1292827) R (@vec _1292827 (NUMERAL 0%N)) B)) (@closed_interval _1292827 (@cons (prod (cart R _1292827) (cart R _1292827)) (@pair (cart R _1292827) (cart R _1292827) a b) (@nil (prod (cart R _1292827) (cart R _1292827)))))) -> exists z : cart R _1292831, (@has_integral_compact_interval _1292827 _1292831 (fun x : cart R _1292827 => @COND (cart R _1292831) (@IN (cart R _1292827) x _2707655) (_2707653 x) (@vec _1292831 (NUMERAL 0%N))) z (@closed_interval _1292827 (@cons (prod (cart R _1292827) (cart R _1292827)) (@pair (cart R _1292827) (cart R _1292827) a b) (@nil (prod (cart R _1292827) (cart R _1292827)))))) /\ (Rlt (@vector_norm _1292831 (@vector_sub _1292831 z _2707654)) e))).
Lemma has_integral_def {_1292827 _1292831 : Type'} : (@has_integral _1292827 _1292831) = (fun _2707653 : (cart R _1292827) -> cart R _1292831 => fun _2707654 : cart R _1292831 => fun _2707655 : (cart R _1292827) -> Prop => @COND Prop (exists a : cart R _1292827, exists b : cart R _1292827, _2707655 = (@closed_interval _1292827 (@cons (prod (cart R _1292827) (cart R _1292827)) (@pair (cart R _1292827) (cart R _1292827) a b) (@nil (prod (cart R _1292827) (cart R _1292827)))))) (@has_integral_compact_interval _1292827 _1292831 _2707653 _2707654 _2707655) (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists B : R, (Rlt (R_of_N (NUMERAL 0%N)) B) /\ (forall a : cart R _1292827, forall b : cart R _1292827, (@SUBSET (cart R _1292827) (@ball _1292827 (@pair (cart R _1292827) R (@vec _1292827 (NUMERAL 0%N)) B)) (@closed_interval _1292827 (@cons (prod (cart R _1292827) (cart R _1292827)) (@pair (cart R _1292827) (cart R _1292827) a b) (@nil (prod (cart R _1292827) (cart R _1292827)))))) -> exists z : cart R _1292831, (@has_integral_compact_interval _1292827 _1292831 (fun x : cart R _1292827 => @COND (cart R _1292831) (@IN (cart R _1292827) x _2707655) (_2707653 x) (@vec _1292831 (NUMERAL 0%N))) z (@closed_interval _1292827 (@cons (prod (cart R _1292827) (cart R _1292827)) (@pair (cart R _1292827) (cart R _1292827) a b) (@nil (prod (cart R _1292827) (cart R _1292827)))))) /\ (Rlt (@vector_norm _1292831 (@vector_sub _1292831 z _2707654)) e)))).
Proof. exact (eq_refl (@has_integral _1292827 _1292831)). Qed.
Definition integrable_on {_1293095 _1293096 : Type'} : ((cart R _1293096) -> cart R _1293095) -> ((cart R _1293096) -> Prop) -> Prop := fun _2708135 : (cart R _1293096) -> cart R _1293095 => fun _2708136 : (cart R _1293096) -> Prop => exists y : cart R _1293095, @has_integral _1293096 _1293095 _2708135 y _2708136.
Lemma integrable_on_def {_1293095 _1293096 : Type'} : (@integrable_on _1293095 _1293096) = (fun _2708135 : (cart R _1293096) -> cart R _1293095 => fun _2708136 : (cart R _1293096) -> Prop => exists y : cart R _1293095, @has_integral _1293096 _1293095 _2708135 y _2708136).
Proof. exact (eq_refl (@integrable_on _1293095 _1293096)). Qed.
Definition integral {_1293110 _1293111 : Type'} : ((cart R _1293111) -> Prop) -> ((cart R _1293111) -> cart R _1293110) -> cart R _1293110 := fun _2708147 : (cart R _1293111) -> Prop => fun _2708148 : (cart R _1293111) -> cart R _1293110 => @ε (cart R _1293110) (fun y : cart R _1293110 => @has_integral _1293111 _1293110 _2708148 y _2708147).
Lemma integral_def {_1293110 _1293111 : Type'} : (@integral _1293110 _1293111) = (fun _2708147 : (cart R _1293111) -> Prop => fun _2708148 : (cart R _1293111) -> cart R _1293110 => @ε (cart R _1293110) (fun y : cart R _1293110 => @has_integral _1293111 _1293110 _2708148 y _2708147)).
Proof. exact (eq_refl (@integral _1293110 _1293111)). Qed.
Definition operative {A N' : Type'} : (A -> A -> A) -> (((cart R N') -> Prop) -> A) -> Prop := fun _2725067 : A -> A -> A => fun _2725068 : ((cart R N') -> Prop) -> A => (forall a : cart R N', forall b : cart R N', ((@content N' (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (R_of_N (NUMERAL 0%N))) -> (_2725068 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (@neutral A _2725067)) /\ (forall a : cart R N', forall b : cart R N', forall c : R, forall k : N, ((N.le (NUMERAL (BIT1 0%N)) k) /\ (N.le k (@dimindex N' (@UNIV N')))) -> (_2725068 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (_2725067 (_2725068 (@INTER (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5871 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5871 (Rle (@dollar R N' x k) c) x)))) (_2725068 (@INTER (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5872 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5872 (Rge (@dollar R N' x k) c) x)))))).
Lemma operative_def {A N' : Type'} : (@operative A N') = (fun _2725067 : A -> A -> A => fun _2725068 : ((cart R N') -> Prop) -> A => (forall a : cart R N', forall b : cart R N', ((@content N' (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (R_of_N (NUMERAL 0%N))) -> (_2725068 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (@neutral A _2725067)) /\ (forall a : cart R N', forall b : cart R N', forall c : R, forall k : N, ((N.le (NUMERAL (BIT1 0%N)) k) /\ (N.le k (@dimindex N' (@UNIV N')))) -> (_2725068 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (_2725067 (_2725068 (@INTER (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5871 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5871 (Rle (@dollar R N' x k) c) x)))) (_2725068 (@INTER (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5872 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5872 (Rge (@dollar R N' x k) c) x))))))).
Proof. exact (eq_refl (@operative A N')). Qed.
Definition lifted {_1302122 _1302124 : Type'} : (_1302124 -> _1302124 -> _1302122) -> (option _1302124) -> (option _1302124) -> option _1302122 := @ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (_1302124 -> _1302124 -> _1302122) -> (option _1302124) -> (option _1302124) -> option _1302122) (fun lifted' : (prod N (prod N (prod N (prod N (prod N N))))) -> (_1302124 -> _1302124 -> _1302122) -> (option _1302124) -> (option _1302124) -> option _1302122 => forall _2726389 : prod N (prod N (prod N (prod N (prod N N)))), (forall op : _1302124 -> _1302124 -> _1302122, forall __ : option _1302124, (lifted' _2726389 op (@None _1302124) __) = (@None _1302122)) /\ ((forall op : _1302124 -> _1302124 -> _1302122, forall __ : option _1302124, (lifted' _2726389 op __ (@None _1302124)) = (@None _1302122)) /\ (forall op : _1302124 -> _1302124 -> _1302122, forall x : _1302124, forall y : _1302124, (lifted' _2726389 op (@Some _1302124 x) (@Some _1302124 y)) = (@Some _1302122 (op x y))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))).
Lemma lifted_def {_1302122 _1302124 : Type'} : (@lifted _1302122 _1302124) = (@ε ((prod N (prod N (prod N (prod N (prod N N))))) -> (_1302124 -> _1302124 -> _1302122) -> (option _1302124) -> (option _1302124) -> option _1302122) (fun lifted' : (prod N (prod N (prod N (prod N (prod N N))))) -> (_1302124 -> _1302124 -> _1302122) -> (option _1302124) -> (option _1302124) -> option _1302122 => forall _2726389 : prod N (prod N (prod N (prod N (prod N N)))), (forall op : _1302124 -> _1302124 -> _1302122, forall __ : option _1302124, (lifted' _2726389 op (@None _1302124) __) = (@None _1302122)) /\ ((forall op : _1302124 -> _1302124 -> _1302122, forall __ : option _1302124, (lifted' _2726389 op __ (@None _1302124)) = (@None _1302122)) /\ (forall op : _1302124 -> _1302124 -> _1302122, forall x : _1302124, forall y : _1302124, (lifted' _2726389 op (@Some _1302124 x) (@Some _1302124 y)) = (@Some _1302122 (op x y))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))).
Proof. exact (eq_refl (@lifted _1302122 _1302124)). Qed.
Definition division_points {N' : Type'} : ((cart R N') -> Prop) -> (((cart R N') -> Prop) -> Prop) -> (prod N R) -> Prop := fun _2726930 : (cart R N') -> Prop => fun _2726931 : ((cart R N') -> Prop) -> Prop => @GSPEC (prod N R) (fun GEN_PVAR_5873 : prod N R => exists j : N, exists x : R, @SETSPEC (prod N R) GEN_PVAR_5873 ((N.le (NUMERAL (BIT1 0%N)) j) /\ ((N.le j (@dimindex N' (@UNIV N'))) /\ ((Rlt (@dollar R N' (@interval_lowerbound N' _2726930) j) x) /\ ((Rlt x (@dollar R N' (@interval_upperbound N' _2726930) j)) /\ (exists i : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) i _2726931) /\ (((@dollar R N' (@interval_lowerbound N' i) j) = x) \/ ((@dollar R N' (@interval_upperbound N' i) j) = x))))))) (@pair N R j x)).
Lemma division_points_def {N' : Type'} : (@division_points N') = (fun _2726930 : (cart R N') -> Prop => fun _2726931 : ((cart R N') -> Prop) -> Prop => @GSPEC (prod N R) (fun GEN_PVAR_5873 : prod N R => exists j : N, exists x : R, @SETSPEC (prod N R) GEN_PVAR_5873 ((N.le (NUMERAL (BIT1 0%N)) j) /\ ((N.le j (@dimindex N' (@UNIV N'))) /\ ((Rlt (@dollar R N' (@interval_lowerbound N' _2726930) j) x) /\ ((Rlt x (@dollar R N' (@interval_upperbound N' _2726930) j)) /\ (exists i : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) i _2726931) /\ (((@dollar R N' (@interval_lowerbound N' i) j) = x) \/ ((@dollar R N' (@interval_upperbound N' i) j) = x))))))) (@pair N R j x))).
Proof. exact (eq_refl (@division_points N')). Qed.
Definition negligible {_1308079 : Type'} : ((cart R _1308079) -> Prop) -> Prop := fun _2745452 : (cart R _1308079) -> Prop => forall a : cart R _1308079, forall b : cart R _1308079, @has_integral _1308079 unit (@indicator _1308079 _2745452) (@vec unit (NUMERAL 0%N)) (@closed_interval _1308079 (@cons (prod (cart R _1308079) (cart R _1308079)) (@pair (cart R _1308079) (cart R _1308079) a b) (@nil (prod (cart R _1308079) (cart R _1308079))))).
Lemma negligible_def {_1308079 : Type'} : (@negligible _1308079) = (fun _2745452 : (cart R _1308079) -> Prop => forall a : cart R _1308079, forall b : cart R _1308079, @has_integral _1308079 unit (@indicator _1308079 _2745452) (@vec unit (NUMERAL 0%N)) (@closed_interval _1308079 (@cons (prod (cart R _1308079) (cart R _1308079)) (@pair (cart R _1308079) (cart R _1308079) a b) (@nil (prod (cart R _1308079) (cart R _1308079)))))).
Proof. exact (eq_refl (@negligible _1308079)). Qed.
Definition set_variation {M N' : Type'} : ((cart R M) -> Prop) -> (((cart R M) -> Prop) -> cart R N') -> R := fun _2796421 : (cart R M) -> Prop => fun _2796422 : ((cart R M) -> Prop) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_5997 : R => exists d : ((cart R M) -> Prop) -> Prop, @SETSPEC R GEN_PVAR_5997 (exists t : (cart R M) -> Prop, (@division_of M d t) /\ (@SUBSET (cart R M) t _2796421)) (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2796422 k))))).
Lemma set_variation_def {M N' : Type'} : (@set_variation M N') = (fun _2796421 : (cart R M) -> Prop => fun _2796422 : ((cart R M) -> Prop) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_5997 : R => exists d : ((cart R M) -> Prop) -> Prop, @SETSPEC R GEN_PVAR_5997 (exists t : (cart R M) -> Prop, (@division_of M d t) /\ (@SUBSET (cart R M) t _2796421)) (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2796422 k)))))).
Proof. exact (eq_refl (@set_variation M N')). Qed.
Definition has_bounded_setvariation_on {M N' : Type'} : (((cart R M) -> Prop) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun _2796433 : ((cart R M) -> Prop) -> cart R N' => fun _2796434 : (cart R M) -> Prop => exists B : R, forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ (@SUBSET (cart R M) t _2796434)) -> Rle (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2796433 k))) B.
Lemma has_bounded_setvariation_on_def {M N' : Type'} : (@has_bounded_setvariation_on M N') = (fun _2796433 : ((cart R M) -> Prop) -> cart R N' => fun _2796434 : (cart R M) -> Prop => exists B : R, forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ (@SUBSET (cart R M) t _2796434)) -> Rle (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2796433 k))) B).
Proof. exact (eq_refl (@has_bounded_setvariation_on M N')). Qed.
Definition absolutely_integrable_on {_1341718 _1341723 : Type'} : ((cart R _1341723) -> cart R _1341718) -> ((cart R _1341723) -> Prop) -> Prop := fun _2802931 : (cart R _1341723) -> cart R _1341718 => fun _2802932 : (cart R _1341723) -> Prop => (@integrable_on _1341718 _1341723 _2802931 _2802932) /\ (@integrable_on unit _1341723 (fun x : cart R _1341723 => lift (@vector_norm _1341718 (_2802931 x))) _2802932).
Lemma absolutely_integrable_on_def {_1341718 _1341723 : Type'} : (@absolutely_integrable_on _1341718 _1341723) = (fun _2802931 : (cart R _1341723) -> cart R _1341718 => fun _2802932 : (cart R _1341723) -> Prop => (@integrable_on _1341718 _1341723 _2802931 _2802932) /\ (@integrable_on unit _1341723 (fun x : cart R _1341723 => lift (@vector_norm _1341718 (_2802931 x))) _2802932)).
Proof. exact (eq_refl (@absolutely_integrable_on _1341718 _1341723)). Qed.
Definition equiintegrable_on {M N' : Type'} : (((cart R M) -> cart R N') -> Prop) -> ((cart R M) -> Prop) -> Prop := fun _2854785 : ((cart R M) -> cart R N') -> Prop => fun _2854786 : (cart R M) -> Prop => (forall f : (cart R M) -> cart R N', (@IN ((cart R M) -> cart R N') f _2854785) -> @integrable_on N' M f _2854786) /\ (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : (cart R M) -> (cart R M) -> Prop, (@gauge M d) /\ (forall f : (cart R M) -> cart R N', forall p : (prod (cart R M) ((cart R M) -> Prop)) -> Prop, ((@IN ((cart R M) -> cart R N') f _2854785) /\ ((@tagged_division_of M p _2854786) /\ (@fine (cart R M) (cart R M) d p))) -> Rlt (@vector_norm N' (@vector_sub N' (@vsum (prod (cart R M) ((cart R M) -> Prop)) N' p (@GABS ((prod (cart R M) ((cart R M) -> Prop)) -> cart R N') (fun f' : (prod (cart R M) ((cart R M) -> Prop)) -> cart R N' => forall x : cart R M, forall k : (cart R M) -> Prop, @GEQ (cart R N') (f' (@pair (cart R M) ((cart R M) -> Prop) x k)) (@percent N' (@content M k) (f x))))) (@integral N' M _2854786 f))) e)).
Lemma equiintegrable_on_def {M N' : Type'} : (@equiintegrable_on M N') = (fun _2854785 : ((cart R M) -> cart R N') -> Prop => fun _2854786 : (cart R M) -> Prop => (forall f : (cart R M) -> cart R N', (@IN ((cart R M) -> cart R N') f _2854785) -> @integrable_on N' M f _2854786) /\ (forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : (cart R M) -> (cart R M) -> Prop, (@gauge M d) /\ (forall f : (cart R M) -> cart R N', forall p : (prod (cart R M) ((cart R M) -> Prop)) -> Prop, ((@IN ((cart R M) -> cart R N') f _2854785) /\ ((@tagged_division_of M p _2854786) /\ (@fine (cart R M) (cart R M) d p))) -> Rlt (@vector_norm N' (@vector_sub N' (@vsum (prod (cart R M) ((cart R M) -> Prop)) N' p (@GABS ((prod (cart R M) ((cart R M) -> Prop)) -> cart R N') (fun f' : (prod (cart R M) ((cart R M) -> Prop)) -> cart R N' => forall x : cart R M, forall k : (cart R M) -> Prop, @GEQ (cart R N') (f' (@pair (cart R M) ((cart R M) -> Prop) x k)) (@percent N' (@content M k) (f x))))) (@integral N' M _2854786 f))) e))).
Proof. exact (eq_refl (@equiintegrable_on M N')). Qed.
Definition has_bounded_variation_on {N' : Type'} : ((cart R unit) -> cart R N') -> ((cart R unit) -> Prop) -> Prop := fun _2915531 : (cart R unit) -> cart R N' => fun _2915532 : (cart R unit) -> Prop => @has_bounded_setvariation_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2915531 (@interval_upperbound unit k)) (_2915531 (@interval_lowerbound unit k))) _2915532.
Lemma has_bounded_variation_on_def {N' : Type'} : (@has_bounded_variation_on N') = (fun _2915531 : (cart R unit) -> cart R N' => fun _2915532 : (cart R unit) -> Prop => @has_bounded_setvariation_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2915531 (@interval_upperbound unit k)) (_2915531 (@interval_lowerbound unit k))) _2915532).
Proof. exact (eq_refl (@has_bounded_variation_on N')). Qed.
Definition vector_variation {N' : Type'} : ((cart R unit) -> Prop) -> ((cart R unit) -> cart R N') -> R := fun _2915543 : (cart R unit) -> Prop => fun _2915544 : (cart R unit) -> cart R N' => @set_variation unit N' _2915543 (fun k : (cart R unit) -> Prop => @vector_sub N' (_2915544 (@interval_upperbound unit k)) (_2915544 (@interval_lowerbound unit k))).
Lemma vector_variation_def {N' : Type'} : (@vector_variation N') = (fun _2915543 : (cart R unit) -> Prop => fun _2915544 : (cart R unit) -> cart R N' => @set_variation unit N' _2915543 (fun k : (cart R unit) -> Prop => @vector_sub N' (_2915544 (@interval_upperbound unit k)) (_2915544 (@interval_lowerbound unit k)))).
Proof. exact (eq_refl (@vector_variation N')). Qed.
Definition absolutely_setcontinuous_on {M N' : Type'} : (((cart R M) -> Prop) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun _2958000 : ((cart R M) -> Prop) -> cart R N' => fun _2958001 : (cart R M) -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists r : R, (Rlt (R_of_N (NUMERAL 0%N)) r) /\ (forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ ((@SUBSET (cart R M) t _2958001) /\ (Rlt (@sum ((cart R M) -> Prop) d (@content M)) r))) -> Rlt (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2958000 k))) e).
Lemma absolutely_setcontinuous_on_def {M N' : Type'} : (@absolutely_setcontinuous_on M N') = (fun _2958000 : ((cart R M) -> Prop) -> cart R N' => fun _2958001 : (cart R M) -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists r : R, (Rlt (R_of_N (NUMERAL 0%N)) r) /\ (forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ ((@SUBSET (cart R M) t _2958001) /\ (Rlt (@sum ((cart R M) -> Prop) d (@content M)) r))) -> Rlt (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2958000 k))) e)).
Proof. exact (eq_refl (@absolutely_setcontinuous_on M N')). Qed.
Definition absolutely_continuous_on {N' : Type'} : ((cart R unit) -> cart R N') -> ((cart R unit) -> Prop) -> Prop := fun _2969674 : (cart R unit) -> cart R N' => fun _2969675 : (cart R unit) -> Prop => @absolutely_setcontinuous_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2969674 (@interval_upperbound unit k)) (_2969674 (@interval_lowerbound unit k))) _2969675.
Lemma absolutely_continuous_on_def {N' : Type'} : (@absolutely_continuous_on N') = (fun _2969674 : (cart R unit) -> cart R N' => fun _2969675 : (cart R unit) -> Prop => @absolutely_setcontinuous_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2969674 (@interval_upperbound unit k)) (_2969674 (@interval_lowerbound unit k))) _2969675).
Proof. exact (eq_refl (@absolutely_continuous_on N')). Qed.
Definition rectifiable_path {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _2973608 : (cart R unit) -> cart R N' => (@path N' _2973608) /\ (@has_bounded_variation_on N' _2973608 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))).
Lemma rectifiable_path_def {N' : Type'} : (@rectifiable_path N') = (fun _2973608 : (cart R unit) -> cart R N' => (@path N' _2973608) /\ (@has_bounded_variation_on N' _2973608 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))))).
Proof. exact (eq_refl (@rectifiable_path N')). Qed.
Definition path_length {N' : Type'} : ((cart R unit) -> cart R N') -> R := fun _2973613 : (cart R unit) -> cart R N' => @vector_variation N' (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))) _2973613.
Lemma path_length_def {N' : Type'} : (@path_length N') = (fun _2973613 : (cart R unit) -> cart R N' => @vector_variation N' (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))) _2973613).
Proof. exact (eq_refl (@path_length N')). Qed.
Definition has_measure {_1428019 : Type'} : ((cart R _1428019) -> Prop) -> R -> Prop := fun _2987546 : (cart R _1428019) -> Prop => fun _2987547 : R => @has_integral _1428019 unit (fun x : cart R _1428019 => @vec unit (NUMERAL (BIT1 0%N))) (lift _2987547) _2987546.
Lemma has_measure_def {_1428019 : Type'} : (@has_measure _1428019) = (fun _2987546 : (cart R _1428019) -> Prop => fun _2987547 : R => @has_integral _1428019 unit (fun x : cart R _1428019 => @vec unit (NUMERAL (BIT1 0%N))) (lift _2987547) _2987546).
Proof. exact (eq_refl (@has_measure _1428019)). Qed.
Definition measurable {_1428035 : Type'} : ((cart R _1428035) -> Prop) -> Prop := fun _2987558 : (cart R _1428035) -> Prop => exists m : R, @has_measure _1428035 _2987558 m.
Lemma measurable_def {_1428035 : Type'} : (@measurable _1428035) = (fun _2987558 : (cart R _1428035) -> Prop => exists m : R, @has_measure _1428035 _2987558 m).
Proof. exact (eq_refl (@measurable _1428035)). Qed.
Definition measure {_1428047 : Type'} : ((cart R _1428047) -> Prop) -> R := fun _2987563 : (cart R _1428047) -> Prop => @ε R (fun m : R => @has_measure _1428047 _2987563 m).
Lemma measure_def {_1428047 : Type'} : (@measure _1428047) = (fun _2987563 : (cart R _1428047) -> Prop => @ε R (fun m : R => @has_measure _1428047 _2987563 m)).
Proof. exact (eq_refl (@measure _1428047)). Qed.
Definition measurable_on {M N' : Type'} : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun _3064508 : (cart R M) -> cart R N' => fun _3064509 : (cart R M) -> Prop => exists k : (cart R M) -> Prop, exists g : N -> (cart R M) -> cart R N', (@negligible M k) /\ ((forall n : N, @continuous_on M N' (g n) (@UNIV (cart R M))) /\ (forall x : cart R M, (~ (@IN (cart R M) x k)) -> @FImp N' N (fun n : N => g n x) (@COND (cart R N') (@IN (cart R M) x _3064509) (_3064508 x) (@vec N' (NUMERAL 0%N))) sequentially)).
Lemma measurable_on_def {M N' : Type'} : (@measurable_on M N') = (fun _3064508 : (cart R M) -> cart R N' => fun _3064509 : (cart R M) -> Prop => exists k : (cart R M) -> Prop, exists g : N -> (cart R M) -> cart R N', (@negligible M k) /\ ((forall n : N, @continuous_on M N' (g n) (@UNIV (cart R M))) /\ (forall x : cart R M, (~ (@IN (cart R M) x k)) -> @FImp N' N (fun n : N => g n x) (@COND (cart R N') (@IN (cart R M) x _3064509) (_3064508 x) (@vec N' (NUMERAL 0%N))) sequentially))).
Proof. exact (eq_refl (@measurable_on M N')). Qed.
Definition lebesgue_measurable {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _3064520 : (cart R N') -> Prop => @measurable_on N' unit (@indicator N' _3064520) (@UNIV (cart R N')).
Lemma lebesgue_measurable_def {N' : Type'} : (@lebesgue_measurable N') = (fun _3064520 : (cart R N') -> Prop => @measurable_on N' unit (@indicator N' _3064520) (@UNIV (cart R N'))).
Proof. exact (eq_refl (@lebesgue_measurable N')). Qed.
Definition Re : (cart R (tybit0 unit)) -> R := fun _3329248 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3329248 (NUMERAL (BIT1 0%N)).
Lemma Re_def : Re = (fun _3329248 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3329248 (NUMERAL (BIT1 0%N))).
Proof. exact (eq_refl Re). Qed.
Definition Im : (cart R (tybit0 unit)) -> R := fun _3329253 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3329253 (NUMERAL (BIT0 (BIT1 0%N))).
Lemma Im_def : Im = (fun _3329253 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3329253 (NUMERAL (BIT0 (BIT1 0%N)))).
Proof. exact (eq_refl Im). Qed.
Definition complex : (prod R R) -> cart R (tybit0 unit) := fun _3329258 : prod R R => @vector R (tybit0 unit) (@cons R (@fst R R _3329258) (@cons R (@snd R R _3329258) (@nil R))).
Lemma complex_def : complex = (fun _3329258 : prod R R => @vector R (tybit0 unit) (@cons R (@fst R R _3329258) (@cons R (@snd R R _3329258) (@nil R)))).
Proof. exact (eq_refl complex). Qed.
Definition Cx : R -> cart R (tybit0 unit) := fun _3329267 : R => complex (@pair R R _3329267 (R_of_N (NUMERAL 0%N))).
Lemma Cx_def : Cx = (fun _3329267 : R => complex (@pair R R _3329267 (R_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl Cx). Qed.
Definition ii : cart R (tybit0 unit) := complex (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N)))).
Lemma ii_def : ii = (complex (@pair R R (R_of_N (NUMERAL 0%N)) (R_of_N (NUMERAL (BIT1 0%N))))).
Proof. exact (eq_refl ii). Qed.
Definition complex_mul : (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3329272 : cart R (tybit0 unit) => fun _3329273 : cart R (tybit0 unit) => complex (@pair R R (Rminus (Rmult (Re _3329272) (Re _3329273)) (Rmult (Im _3329272) (Im _3329273))) (Rplus (Rmult (Re _3329272) (Im _3329273)) (Rmult (Im _3329272) (Re _3329273)))).
Lemma complex_mul_def : complex_mul = (fun _3329272 : cart R (tybit0 unit) => fun _3329273 : cart R (tybit0 unit) => complex (@pair R R (Rminus (Rmult (Re _3329272) (Re _3329273)) (Rmult (Im _3329272) (Im _3329273))) (Rplus (Rmult (Re _3329272) (Im _3329273)) (Rmult (Im _3329272) (Re _3329273))))).
Proof. exact (eq_refl complex_mul). Qed.
Definition complex_inv : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3329284 : cart R (tybit0 unit) => complex (@pair R R (Rdiv (Re _3329284) (Rplus (Rpow (Re _3329284) (NUMERAL (BIT0 (BIT1 0%N)))) (Rpow (Im _3329284) (NUMERAL (BIT0 (BIT1 0%N)))))) (Rdiv (Ropp (Im _3329284)) (Rplus (Rpow (Re _3329284) (NUMERAL (BIT0 (BIT1 0%N)))) (Rpow (Im _3329284) (NUMERAL (BIT0 (BIT1 0%N))))))).
Lemma complex_inv_def : complex_inv = (fun _3329284 : cart R (tybit0 unit) => complex (@pair R R (Rdiv (Re _3329284) (Rplus (Rpow (Re _3329284) (NUMERAL (BIT0 (BIT1 0%N)))) (Rpow (Im _3329284) (NUMERAL (BIT0 (BIT1 0%N)))))) (Rdiv (Ropp (Im _3329284)) (Rplus (Rpow (Re _3329284) (NUMERAL (BIT0 (BIT1 0%N)))) (Rpow (Im _3329284) (NUMERAL (BIT0 (BIT1 0%N)))))))).
Proof. exact (eq_refl complex_inv). Qed.
Definition complex_div : (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3329289 : cart R (tybit0 unit) => fun _3329290 : cart R (tybit0 unit) => complex_mul _3329289 (complex_inv _3329290).
Lemma complex_div_def : complex_div = (fun _3329289 : cart R (tybit0 unit) => fun _3329290 : cart R (tybit0 unit) => complex_mul _3329289 (complex_inv _3329290)).
Proof. exact (eq_refl complex_div). Qed.
Definition complex_pow : (cart R (tybit0 unit)) -> N -> cart R (tybit0 unit) := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (cart R (tybit0 unit)) -> N -> cart R (tybit0 unit)) (fun complex_pow' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (cart R (tybit0 unit)) -> N -> cart R (tybit0 unit) => forall _3329685 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), (forall x : cart R (tybit0 unit), (complex_pow' _3329685 x (NUMERAL 0%N)) = (Cx (R_of_N (NUMERAL (BIT1 0%N))))) /\ (forall x : cart R (tybit0 unit), forall n : N, (complex_pow' _3329685 x (N.succ n)) = (complex_mul x (complex_pow' _3329685 x n)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))))).
Lemma complex_pow_def : complex_pow = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (cart R (tybit0 unit)) -> N -> cart R (tybit0 unit)) (fun complex_pow' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) -> (cart R (tybit0 unit)) -> N -> cart R (tybit0 unit) => forall _3329685 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))), (forall x : cart R (tybit0 unit), (complex_pow' _3329685 x (NUMERAL 0%N)) = (Cx (R_of_N (NUMERAL (BIT1 0%N))))) /\ (forall x : cart R (tybit0 unit), forall n : N, (complex_pow' _3329685 x (N.succ n)) = (complex_mul x (complex_pow' _3329685 x n)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))))).
Proof. exact (eq_refl complex_pow). Qed.
Definition cnj : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3330120 : cart R (tybit0 unit) => complex (@pair R R (Re _3330120) (Ropp (Im _3330120))).
Lemma cnj_def : cnj = (fun _3330120 : cart R (tybit0 unit) => complex (@pair R R (Re _3330120) (Ropp (Im _3330120)))).
Proof. exact (eq_refl cnj). Qed.
Definition csqrt : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3330185 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) ((Im _3330185) = (R_of_N (NUMERAL 0%N))) (@COND (cart R (tybit0 unit)) (Rle (R_of_N (NUMERAL 0%N)) (Re _3330185)) (complex (@pair R R (sqrt (Re _3330185)) (R_of_N (NUMERAL 0%N)))) (complex (@pair R R (R_of_N (NUMERAL 0%N)) (sqrt (Ropp (Re _3330185)))))) (complex (@pair R R (sqrt (Rdiv (Rplus (@vector_norm (tybit0 unit) _3330185) (Re _3330185)) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (Rmult (Rdiv (Im _3330185) (Rabs (Im _3330185))) (sqrt (Rdiv (Rminus (@vector_norm (tybit0 unit) _3330185) (Re _3330185)) (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))))))).
Lemma csqrt_def : csqrt = (fun _3330185 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) ((Im _3330185) = (R_of_N (NUMERAL 0%N))) (@COND (cart R (tybit0 unit)) (Rle (R_of_N (NUMERAL 0%N)) (Re _3330185)) (complex (@pair R R (sqrt (Re _3330185)) (R_of_N (NUMERAL 0%N)))) (complex (@pair R R (R_of_N (NUMERAL 0%N)) (sqrt (Ropp (Re _3330185)))))) (complex (@pair R R (sqrt (Rdiv (Rplus (@vector_norm (tybit0 unit) _3330185) (Re _3330185)) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (Rmult (Rdiv (Im _3330185) (Rabs (Im _3330185))) (sqrt (Rdiv (Rminus (@vector_norm (tybit0 unit) _3330185) (Re _3330185)) (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))))))).
Proof. exact (eq_refl csqrt). Qed.
Definition real : (cart R (tybit0 unit)) -> Prop := fun _3330546 : cart R (tybit0 unit) => (Im _3330546) = (R_of_N (NUMERAL 0%N)).
Lemma real_def : real = (fun _3330546 : cart R (tybit0 unit) => (Im _3330546) = (R_of_N (NUMERAL 0%N))).
Proof. exact (eq_refl real). Qed.
Definition cproduct {_1609940 : Type'} : (_1609940 -> Prop) -> (_1609940 -> cart R (tybit0 unit)) -> cart R (tybit0 unit) := @iterate _1609940 (cart R (tybit0 unit)) complex_mul.
Lemma cproduct_def {_1609940 : Type'} : (@cproduct _1609940) = (@iterate _1609940 (cart R (tybit0 unit)) complex_mul).
Proof. exact (eq_refl (@cproduct _1609940)). Qed.
Definition has_complex_derivative : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> (net (cart R (tybit0 unit))) -> Prop := fun _3333810 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3333811 : cart R (tybit0 unit) => fun _3333812 : net (cart R (tybit0 unit)) => @has_derivative (tybit0 unit) (tybit0 unit) _3333810 (fun x : cart R (tybit0 unit) => complex_mul _3333811 x) _3333812.
Lemma has_complex_derivative_def : has_complex_derivative = (fun _3333810 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3333811 : cart R (tybit0 unit) => fun _3333812 : net (cart R (tybit0 unit)) => @has_derivative (tybit0 unit) (tybit0 unit) _3333810 (fun x : cart R (tybit0 unit) => complex_mul _3333811 x) _3333812).
Proof. exact (eq_refl has_complex_derivative). Qed.
Definition complex_differentiable : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (net (cart R (tybit0 unit))) -> Prop := fun _3333831 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3333832 : net (cart R (tybit0 unit)) => exists f' : cart R (tybit0 unit), has_complex_derivative _3333831 f' _3333832.
Lemma complex_differentiable_def : complex_differentiable = (fun _3333831 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3333832 : net (cart R (tybit0 unit)) => exists f' : cart R (tybit0 unit), has_complex_derivative _3333831 f' _3333832).
Proof. exact (eq_refl complex_differentiable). Qed.
Definition complex_derivative : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3333843 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3333844 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun f' : cart R (tybit0 unit) => has_complex_derivative _3333843 f' (@_at (tybit0 unit) _3333844)).
Lemma complex_derivative_def : complex_derivative = (fun _3333843 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3333844 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun f' : cart R (tybit0 unit) => has_complex_derivative _3333843 f' (@_at (tybit0 unit) _3333844))).
Proof. exact (eq_refl complex_derivative). Qed.
Definition higher_complex_derivative : N -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))) -> N -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit)) (fun higher_complex_derivative' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))) -> N -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) => forall _3334239 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))), (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), (higher_complex_derivative' _3334239 (NUMERAL 0%N) f) = f) /\ (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall n : N, (higher_complex_derivative' _3334239 (N.succ n) f) = (complex_derivative (higher_complex_derivative' _3334239 n f)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))))))))))).
Lemma higher_complex_derivative_def : higher_complex_derivative = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))) -> N -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit)) (fun higher_complex_derivative' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))))) -> N -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) => forall _3334239 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))), (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), (higher_complex_derivative' _3334239 (NUMERAL 0%N) f) = f) /\ (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall n : N, (higher_complex_derivative' _3334239 (N.succ n) f) = (complex_derivative (higher_complex_derivative' _3334239 n f)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))))))))))).
Proof. exact (eq_refl higher_complex_derivative). Qed.
Definition holomorphic_on : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> ((cart R (tybit0 unit)) -> Prop) -> Prop := fun _3334240 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334241 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3334241) -> exists f' : cart R (tybit0 unit), has_complex_derivative _3334240 f' (@within (cart R (tybit0 unit)) (@_at (tybit0 unit) x) _3334241).
Lemma holomorphic_on_def : holomorphic_on = (fun _3334240 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334241 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3334241) -> exists f' : cart R (tybit0 unit), has_complex_derivative _3334240 f' (@within (cart R (tybit0 unit)) (@_at (tybit0 unit) x) _3334241)).
Proof. exact (eq_refl holomorphic_on). Qed.
Definition analytic_on : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> ((cart R (tybit0 unit)) -> Prop) -> Prop := fun _3336443 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3336444 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3336444) -> exists e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) /\ (holomorphic_on _3336443 (@ball (tybit0 unit) (@pair (cart R (tybit0 unit)) R x e))).
Lemma analytic_on_def : analytic_on = (fun _3336443 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3336444 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3336444) -> exists e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) /\ (holomorphic_on _3336443 (@ball (tybit0 unit) (@pair (cart R (tybit0 unit)) R x e)))).
Proof. exact (eq_refl analytic_on). Qed.
Definition cexp : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3342061 : cart R (tybit0 unit) => @infsum (tybit0 unit) (from (NUMERAL 0%N)) (fun n : N => complex_div (complex_pow _3342061 n) (Cx (R_of_N (FACT n)))).
Lemma cexp_def : cexp = (fun _3342061 : cart R (tybit0 unit) => @infsum (tybit0 unit) (from (NUMERAL 0%N)) (fun n : N => complex_div (complex_pow _3342061 n) (Cx (R_of_N (FACT n))))).
Proof. exact (eq_refl cexp). Qed.
Definition ccos : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3342231 : cart R (tybit0 unit) => complex_div (@vector_add (tybit0 unit) (cexp (complex_mul ii _3342231)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3342231))) (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))).
Lemma ccos_def : ccos = (fun _3342231 : cart R (tybit0 unit) => complex_div (@vector_add (tybit0 unit) (cexp (complex_mul ii _3342231)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3342231))) (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))).
Proof. exact (eq_refl ccos). Qed.
Definition csin : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3342236 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) (cexp (complex_mul ii _3342236)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3342236))) (complex_mul (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))) ii).
Lemma csin_def : csin = (fun _3342236 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) (cexp (complex_mul ii _3342236)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3342236))) (complex_mul (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))) ii)).
Proof. exact (eq_refl csin). Qed.
Definition exp : R -> R := fun _3342241 : R => Re (cexp (Cx _3342241)).
Lemma exp_def : exp = (fun _3342241 : R => Re (cexp (Cx _3342241))).
Proof. exact (eq_refl exp). Qed.
Definition sin : R -> R := fun _3342371 : R => Re (csin (Cx _3342371)).
Lemma sin_def : sin = (fun _3342371 : R => Re (csin (Cx _3342371))).
Proof. exact (eq_refl sin). Qed.
Definition cos : R -> R := fun _3342376 : R => Re (ccos (Cx _3342376)).
Lemma cos_def : cos = (fun _3342376 : R => Re (ccos (Cx _3342376))).
Proof. exact (eq_refl cos). Qed.
Definition log : R -> R := fun _3342477 : R => @ε R (fun x : R => (exp x) = _3342477).
Lemma log_def : log = (fun _3342477 : R => @ε R (fun x : R => (exp x) = _3342477)).
Proof. exact (eq_refl log). Qed.
Definition pi : R := @ε R (fun p : R => (Rlt (R_of_N (NUMERAL 0%N)) p) /\ (((sin p) = (R_of_N (NUMERAL 0%N))) /\ (forall x : R, ((Rlt (R_of_N (NUMERAL 0%N)) x) /\ (Rlt x p)) -> ~ ((sin x) = (R_of_N (NUMERAL 0%N)))))).
Lemma pi_def : pi = (@ε R (fun p : R => (Rlt (R_of_N (NUMERAL 0%N)) p) /\ (((sin p) = (R_of_N (NUMERAL 0%N))) /\ (forall x : R, ((Rlt (R_of_N (NUMERAL 0%N)) x) /\ (Rlt x p)) -> ~ ((sin x) = (R_of_N (NUMERAL 0%N))))))).
Proof. exact (eq_refl pi). Qed.
Definition Arg : (cart R (tybit0 unit)) -> R := fun _3343510 : cart R (tybit0 unit) => @COND R (_3343510 = (Cx (R_of_N (NUMERAL 0%N)))) (R_of_N (NUMERAL 0%N)) (@ε R (fun t : R => (Rle (R_of_N (NUMERAL 0%N)) t) /\ ((Rlt t (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) pi)) /\ (_3343510 = (complex_mul (Cx (@vector_norm (tybit0 unit) _3343510)) (cexp (complex_mul ii (Cx t)))))))).
Lemma Arg_def : Arg = (fun _3343510 : cart R (tybit0 unit) => @COND R (_3343510 = (Cx (R_of_N (NUMERAL 0%N)))) (R_of_N (NUMERAL 0%N)) (@ε R (fun t : R => (Rle (R_of_N (NUMERAL 0%N)) t) /\ ((Rlt t (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) pi)) /\ (_3343510 = (complex_mul (Cx (@vector_norm (tybit0 unit) _3343510)) (cexp (complex_mul ii (Cx t))))))))).
Proof. exact (eq_refl Arg). Qed.
Definition rotate2d : R -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3343778 : R => fun _3343779 : cart R (tybit0 unit) => @vector R (tybit0 unit) (@cons R (Rminus (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT1 0%N))) (cos _3343778)) (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT0 (BIT1 0%N)))) (sin _3343778))) (@cons R (Rplus (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT1 0%N))) (sin _3343778)) (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT0 (BIT1 0%N)))) (cos _3343778))) (@nil R))).
Lemma rotate2d_def : rotate2d = (fun _3343778 : R => fun _3343779 : cart R (tybit0 unit) => @vector R (tybit0 unit) (@cons R (Rminus (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT1 0%N))) (cos _3343778)) (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT0 (BIT1 0%N)))) (sin _3343778))) (@cons R (Rplus (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT1 0%N))) (sin _3343778)) (Rmult (@dollar R (tybit0 unit) _3343779 (NUMERAL (BIT0 (BIT1 0%N)))) (cos _3343778))) (@nil R)))).
Proof. exact (eq_refl rotate2d). Qed.
Definition ctan : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3344450 : cart R (tybit0 unit) => complex_div (csin _3344450) (ccos _3344450).
Lemma ctan_def : ctan = (fun _3344450 : cart R (tybit0 unit) => complex_div (csin _3344450) (ccos _3344450)).
Proof. exact (eq_refl ctan). Qed.
Definition tan : R -> R := fun _3344653 : R => Re (ctan (Cx _3344653)).
Lemma tan_def : tan = (fun _3344653 : R => Re (ctan (Cx _3344653))).
Proof. exact (eq_refl tan). Qed.
Definition clog : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3344970 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun w : cart R (tybit0 unit) => ((cexp w) = _3344970) /\ ((Rlt (Ropp pi) (Im w)) /\ (Rle (Im w) pi))).
Lemma clog_def : clog = (fun _3344970 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun w : cart R (tybit0 unit) => ((cexp w) = _3344970) /\ ((Rlt (Ropp pi) (Im w)) /\ (Rle (Im w) pi)))).
Proof. exact (eq_refl clog). Qed.
Definition cpow : (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3345971 : cart R (tybit0 unit) => fun _3345972 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) (_3345971 = (Cx (R_of_N (NUMERAL 0%N)))) (Cx (R_of_N (NUMERAL 0%N))) (cexp (complex_mul _3345972 (clog _3345971))).
Lemma cpow_def : cpow = (fun _3345971 : cart R (tybit0 unit) => fun _3345972 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) (_3345971 = (Cx (R_of_N (NUMERAL 0%N)))) (Cx (R_of_N (NUMERAL 0%N))) (cexp (complex_mul _3345972 (clog _3345971)))).
Proof. exact (eq_refl cpow). Qed.
Definition unwinding : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3346173 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) _3346173 (clog (cexp _3346173))) (complex_mul (Cx (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) pi)) ii).
Lemma unwinding_def : unwinding = (fun _3346173 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) _3346173 (clog (cexp _3346173))) (complex_mul (Cx (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) pi)) ii)).
Proof. exact (eq_refl unwinding). Qed.
Definition catn : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3346178 : cart R (tybit0 unit) => complex_mul (complex_div ii (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (clog (complex_div (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_mul ii _3346178)) (@vector_add (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_mul ii _3346178)))).
Lemma catn_def : catn = (fun _3346178 : cart R (tybit0 unit) => complex_mul (complex_div ii (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))))) (clog (complex_div (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_mul ii _3346178)) (@vector_add (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_mul ii _3346178))))).
Proof. exact (eq_refl catn). Qed.
Definition atn : R -> R := fun _3346722 : R => Re (catn (Cx _3346722)).
Lemma atn_def : atn = (fun _3346722 : R => Re (catn (Cx _3346722))).
Proof. exact (eq_refl atn). Qed.
Definition casn : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3347097 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) (complex_mul ii _3347097) (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_pow _3347097 (NUMERAL (BIT0 (BIT1 0%N)))))))).
Lemma casn_def : casn = (fun _3347097 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) (complex_mul ii _3347097) (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_pow _3347097 (NUMERAL (BIT0 (BIT1 0%N))))))))).
Proof. exact (eq_refl casn). Qed.
Definition cacs : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3347591 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) _3347591 (complex_mul ii (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_pow _3347591 (NUMERAL (BIT0 (BIT1 0%N))))))))).
Lemma cacs_def : cacs = (fun _3347591 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) _3347591 (complex_mul ii (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_pow _3347591 (NUMERAL (BIT0 (BIT1 0%N)))))))))).
Proof. exact (eq_refl cacs). Qed.
Definition asn : R -> R := fun _3348126 : R => Re (casn (Cx _3348126)).
Lemma asn_def : asn = (fun _3348126 : R => Re (casn (Cx _3348126))).
Proof. exact (eq_refl asn). Qed.
Definition acs : R -> R := fun _3348211 : R => Re (cacs (Cx _3348211)).
Lemma acs_def : acs = (fun _3348211 : R => Re (cacs (Cx _3348211))).
Proof. exact (eq_refl acs). Qed.
Definition root : N -> R -> R := fun _3348721 : N => fun _3348722 : R => Rmult (Rsgn _3348722) (exp (Rdiv (log (Rabs _3348722)) (R_of_N _3348721))).
Lemma root_def : root = (fun _3348721 : N => fun _3348722 : R => Rmult (Rsgn _3348722) (exp (Rdiv (log (Rabs _3348722)) (R_of_N _3348721)))).
Proof. exact (eq_refl root). Qed.
Definition rpow : R -> R -> R := fun _3349071 : R => fun _3349072 : R => @COND R (Rlt (R_of_N (NUMERAL 0%N)) _3349071) (exp (Rmult _3349072 (log _3349071))) (@COND R (_3349071 = (R_of_N (NUMERAL 0%N))) (@COND R (_3349072 = (R_of_N (NUMERAL 0%N))) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))) (@COND R (exists m : N, exists n : N, (ODD m) /\ ((ODD n) /\ ((Rabs _3349072) = (Rdiv (R_of_N m) (R_of_N n))))) (Ropp (exp (Rmult _3349072 (log (Ropp _3349071))))) (exp (Rmult _3349072 (log (Ropp _3349071)))))).
Lemma rpow_def : rpow = (fun _3349071 : R => fun _3349072 : R => @COND R (Rlt (R_of_N (NUMERAL 0%N)) _3349071) (exp (Rmult _3349072 (log _3349071))) (@COND R (_3349071 = (R_of_N (NUMERAL 0%N))) (@COND R (_3349072 = (R_of_N (NUMERAL 0%N))) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))) (@COND R (exists m : N, exists n : N, (ODD m) /\ ((ODD n) /\ ((Rabs _3349072) = (Rdiv (R_of_N m) (R_of_N n))))) (Ropp (exp (Rmult _3349072 (log (Ropp _3349071))))) (exp (Rmult _3349072 (log (Ropp _3349071))))))).
Proof. exact (eq_refl rpow). Qed.
Definition longarrow {_1674736 : Type'} : (_1674736 -> R) -> R -> (net _1674736) -> Prop := fun _3352730 : _1674736 -> R => fun _3352731 : R => fun _3352732 : net _1674736 => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> @eventually _1674736 (fun x : _1674736 => Rlt (Rabs (Rminus (_3352730 x) _3352731)) e) _3352732.
Lemma longarrow_def {_1674736 : Type'} : (@longarrow _1674736) = (fun _3352730 : _1674736 -> R => fun _3352731 : R => fun _3352732 : net _1674736 => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> @eventually _1674736 (fun x : _1674736 => Rlt (Rabs (Rminus (_3352730 x) _3352731)) e) _3352732).
Proof. exact (eq_refl (@longarrow _1674736)). Qed.
Definition reallim {_1674750 : Type'} : (net _1674750) -> (_1674750 -> R) -> R := fun _3352751 : net _1674750 => fun _3352752 : _1674750 -> R => @ε R (fun l : R => @longarrow _1674750 _3352752 l _3352751).
Lemma reallim_def {_1674750 : Type'} : (@reallim _1674750) = (fun _3352751 : net _1674750 => fun _3352752 : _1674750 -> R => @ε R (fun l : R => @longarrow _1674750 _3352752 l _3352751)).
Proof. exact (eq_refl (@reallim _1674750)). Qed.
Definition real_sums : (N -> R) -> R -> (N -> Prop) -> Prop := fun _3353246 : N -> R => fun _3353247 : R => fun _3353248 : N -> Prop => @longarrow N (fun n : N => @sum N (@INTER N _3353248 (dotdot (NUMERAL 0%N) n)) _3353246) _3353247 sequentially.
Lemma real_sums_def : real_sums = (fun _3353246 : N -> R => fun _3353247 : R => fun _3353248 : N -> Prop => @longarrow N (fun n : N => @sum N (@INTER N _3353248 (dotdot (NUMERAL 0%N) n)) _3353246) _3353247 sequentially).
Proof. exact (eq_refl real_sums). Qed.
Definition real_infsum : (N -> Prop) -> (N -> R) -> R := fun _3353267 : N -> Prop => fun _3353268 : N -> R => @ε R (fun l : R => real_sums _3353268 l _3353267).
Lemma real_infsum_def : real_infsum = (fun _3353267 : N -> Prop => fun _3353268 : N -> R => @ε R (fun l : R => real_sums _3353268 l _3353267)).
Proof. exact (eq_refl real_infsum). Qed.
Definition real_summable : (N -> Prop) -> (N -> R) -> Prop := fun _3353279 : N -> Prop => fun _3353280 : N -> R => exists l : R, real_sums _3353280 l _3353279.
Lemma real_summable_def : real_summable = (fun _3353279 : N -> Prop => fun _3353280 : N -> R => exists l : R, real_sums _3353280 l _3353279).
Proof. exact (eq_refl real_summable). Qed.
Definition atreal : R -> net R := fun _3354706 : R => @atpointof R euclideanreal _3354706.
Lemma atreal_def : atreal = (fun _3354706 : R => @atpointof R euclideanreal _3354706).
Proof. exact (eq_refl atreal). Qed.
Definition real_continuous {_1684948 : Type'} : (_1684948 -> R) -> (net _1684948) -> Prop := fun _3355521 : _1684948 -> R => fun _3355522 : net _1684948 => @longarrow _1684948 _3355521 (_3355521 (@netlimit _1684948 _3355522)) _3355522.
Lemma real_continuous_def {_1684948 : Type'} : (@real_continuous _1684948) = (fun _3355521 : _1684948 -> R => fun _3355522 : net _1684948 => @longarrow _1684948 _3355521 (_3355521 (@netlimit _1684948 _3355522)) _3355522).
Proof. exact (eq_refl (@real_continuous _1684948)). Qed.
Definition real_continuous_on : (R -> R) -> (R -> Prop) -> Prop := fun _3356881 : R -> R => fun _3356882 : R -> Prop => forall x : R, (@IN R x _3356882) -> forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x' : R, ((@IN R x' _3356882) /\ (Rlt (Rabs (Rminus x' x)) d)) -> Rlt (Rabs (Rminus (_3356881 x') (_3356881 x))) e).
Lemma real_continuous_on_def : real_continuous_on = (fun _3356881 : R -> R => fun _3356882 : R -> Prop => forall x : R, (@IN R x _3356882) -> forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x' : R, ((@IN R x' _3356882) /\ (Rlt (Rabs (Rminus x' x)) d)) -> Rlt (Rabs (Rminus (_3356881 x') (_3356881 x))) e)).
Proof. exact (eq_refl real_continuous_on). Qed.
Definition real_uniformly_continuous_on : (R -> R) -> (R -> Prop) -> Prop := fun _3357306 : R -> R => fun _3357307 : R -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x : R, forall x' : R, ((@IN R x _3357307) /\ ((@IN R x' _3357307) /\ (Rlt (Rabs (Rminus x' x)) d))) -> Rlt (Rabs (Rminus (_3357306 x') (_3357306 x))) e).
Lemma real_uniformly_continuous_on_def : real_uniformly_continuous_on = (fun _3357306 : R -> R => fun _3357307 : R -> Prop => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists d : R, (Rlt (R_of_N (NUMERAL 0%N)) d) /\ (forall x : R, forall x' : R, ((@IN R x _3357307) /\ ((@IN R x' _3357307) /\ (Rlt (Rabs (Rminus x' x)) d))) -> Rlt (Rabs (Rminus (_3357306 x') (_3357306 x))) e)).
Proof. exact (eq_refl real_uniformly_continuous_on). Qed.
Definition has_real_derivative : (R -> R) -> R -> (net R) -> Prop := fun _3357396 : R -> R => fun _3357397 : R => fun _3357398 : net R => @longarrow R (fun x : R => Rmult (Rinv (Rminus x (@netlimit R _3357398))) (Rminus (_3357396 x) (Rplus (_3357396 (@netlimit R _3357398)) (Rmult _3357397 (Rminus x (@netlimit R _3357398)))))) (R_of_N (NUMERAL 0%N)) _3357398.
Lemma has_real_derivative_def : has_real_derivative = (fun _3357396 : R -> R => fun _3357397 : R => fun _3357398 : net R => @longarrow R (fun x : R => Rmult (Rinv (Rminus x (@netlimit R _3357398))) (Rminus (_3357396 x) (Rplus (_3357396 (@netlimit R _3357398)) (Rmult _3357397 (Rminus x (@netlimit R _3357398)))))) (R_of_N (NUMERAL 0%N)) _3357398).
Proof. exact (eq_refl has_real_derivative). Qed.
Definition real_differentiable : (R -> R) -> (net R) -> Prop := fun _3357417 : R -> R => fun _3357418 : net R => exists f' : R, has_real_derivative _3357417 f' _3357418.
Lemma real_differentiable_def : real_differentiable = (fun _3357417 : R -> R => fun _3357418 : net R => exists f' : R, has_real_derivative _3357417 f' _3357418).
Proof. exact (eq_refl real_differentiable). Qed.
Definition real_derivative : (R -> R) -> R -> R := fun _3357429 : R -> R => fun _3357430 : R => @ε R (fun f' : R => has_real_derivative _3357429 f' (atreal _3357430)).
Lemma real_derivative_def : real_derivative = (fun _3357429 : R -> R => fun _3357430 : R => @ε R (fun f' : R => has_real_derivative _3357429 f' (atreal _3357430))).
Proof. exact (eq_refl real_derivative). Qed.
Definition higher_real_derivative : N -> (R -> R) -> R -> R := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (R -> R) -> R -> R) (fun higher_real_derivative' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (R -> R) -> R -> R => forall _3357825 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))), (forall f : R -> R, (higher_real_derivative' _3357825 (NUMERAL 0%N) f) = f) /\ (forall f : R -> R, forall n : N, (higher_real_derivative' _3357825 (N.succ n) f) = (real_derivative (higher_real_derivative' _3357825 n f)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))))))).
Lemma higher_real_derivative_def : higher_real_derivative = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (R -> R) -> R -> R) (fun higher_real_derivative' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))))) -> N -> (R -> R) -> R -> R => forall _3357825 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))), (forall f : R -> R, (higher_real_derivative' _3357825 (NUMERAL 0%N) f) = f) /\ (forall f : R -> R, forall n : N, (higher_real_derivative' _3357825 (N.succ n) f) = (real_derivative (higher_real_derivative' _3357825 n f)))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))))))))).
Proof. exact (eq_refl higher_real_derivative). Qed.
Definition real_differentiable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3357826 : R -> R => fun _3357827 : R -> Prop => forall x : R, (@IN R x _3357827) -> exists f' : R, has_real_derivative _3357826 f' (@within R (atreal x) _3357827).
Lemma real_differentiable_on_def : real_differentiable_on = (fun _3357826 : R -> R => fun _3357827 : R -> Prop => forall x : R, (@IN R x _3357827) -> exists f' : R, has_real_derivative _3357826 f' (@within R (atreal x) _3357827)).
Proof. exact (eq_refl real_differentiable_on). Qed.
Definition has_limsup {A : Type'} : (A -> R) -> R -> (net A) -> Prop := fun _3361879 : A -> R => fun _3361880 : R => fun _3361881 : net A => (@trivial_limit A _3361881) \/ (has_inf (@GSPEC R (fun GEN_PVAR_8465 : R => exists b : R, @SETSPEC R GEN_PVAR_8465 (@eventually A (fun x : A => Rle (_3361879 x) b) _3361881) b)) _3361880).
Lemma has_limsup_def {A : Type'} : (@has_limsup A) = (fun _3361879 : A -> R => fun _3361880 : R => fun _3361881 : net A => (@trivial_limit A _3361881) \/ (has_inf (@GSPEC R (fun GEN_PVAR_8465 : R => exists b : R, @SETSPEC R GEN_PVAR_8465 (@eventually A (fun x : A => Rle (_3361879 x) b) _3361881) b)) _3361880)).
Proof. exact (eq_refl (@has_limsup A)). Qed.
Definition has_liminf {A : Type'} : (A -> R) -> R -> (net A) -> Prop := fun _3361900 : A -> R => fun _3361901 : R => fun _3361902 : net A => (@trivial_limit A _3361902) \/ (has_sup (@GSPEC R (fun GEN_PVAR_8466 : R => exists b : R, @SETSPEC R GEN_PVAR_8466 (@eventually A (fun x : A => Rle b (_3361900 x)) _3361902) b)) _3361901).
Lemma has_liminf_def {A : Type'} : (@has_liminf A) = (fun _3361900 : A -> R => fun _3361901 : R => fun _3361902 : net A => (@trivial_limit A _3361902) \/ (has_sup (@GSPEC R (fun GEN_PVAR_8466 : R => exists b : R, @SETSPEC R GEN_PVAR_8466 (@eventually A (fun x : A => Rle b (_3361900 x)) _3361902) b)) _3361901)).
Proof. exact (eq_refl (@has_liminf A)). Qed.
Definition closed_real_segment : (list (prod R R)) -> R -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) -> (list (prod R R)) -> R -> Prop) (fun closed_real_segment' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) -> (list (prod R R)) -> R -> Prop => forall _3363925 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))), forall a : R, forall b : R, (closed_real_segment' _3363925 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_8483 : R => exists u : R, @SETSPEC R GEN_PVAR_8483 ((Rle (R_of_N (NUMERAL 0%N)) u) /\ (Rle u (R_of_N (NUMERAL (BIT1 0%N))))) (Rplus (Rmult (Rminus (R_of_N (NUMERAL (BIT1 0%N))) u) a) (Rmult u b))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))))))))))))))))))))).
Lemma closed_real_segment_def : closed_real_segment = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) -> (list (prod R R)) -> R -> Prop) (fun closed_real_segment' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))))) -> (list (prod R R)) -> R -> Prop => forall _3363925 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))), forall a : R, forall b : R, (closed_real_segment' _3363925 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_8483 : R => exists u : R, @SETSPEC R GEN_PVAR_8483 ((Rle (R_of_N (NUMERAL 0%N)) u) /\ (Rle u (R_of_N (NUMERAL (BIT1 0%N))))) (Rplus (Rmult (Rminus (R_of_N (NUMERAL (BIT1 0%N))) u) a) (Rmult u b))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N))))))))))))))))))))))))))).
Proof. exact (eq_refl closed_real_segment). Qed.
Definition open_real_segment : (prod R R) -> R -> Prop := fun _3363926 : prod R R => @DIFF R (closed_real_segment (@cons (prod R R) (@pair R R (@fst R R _3363926) (@snd R R _3363926)) (@nil (prod R R)))) (@INSERT R (@fst R R _3363926) (@INSERT R (@snd R R _3363926) (@EMPTY R))).
Lemma open_real_segment_def : open_real_segment = (fun _3363926 : prod R R => @DIFF R (closed_real_segment (@cons (prod R R) (@pair R R (@fst R R _3363926) (@snd R R _3363926)) (@nil (prod R R)))) (@INSERT R (@fst R R _3363926) (@INSERT R (@snd R R _3363926) (@EMPTY R)))).
Proof. exact (eq_refl open_real_segment). Qed.
Definition real_convex_on : (R -> R) -> (R -> Prop) -> Prop := fun _3364268 : R -> R => fun _3364269 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3364269) /\ ((@IN R y _3364269) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> Rle (_3364268 (Rplus (Rmult u x) (Rmult v y))) (Rplus (Rmult u (_3364268 x)) (Rmult v (_3364268 y))).
Lemma real_convex_on_def : real_convex_on = (fun _3364268 : R -> R => fun _3364269 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3364269) /\ ((@IN R y _3364269) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> Rle (_3364268 (Rplus (Rmult u x) (Rmult v y))) (Rplus (Rmult u (_3364268 x)) (Rmult v (_3364268 y)))).
Proof. exact (eq_refl real_convex_on). Qed.
Definition log_convex_on {N' : Type'} : ((cart R N') -> R) -> ((cart R N') -> Prop) -> Prop := fun _3365513 : (cart R N') -> R => fun _3365514 : (cart R N') -> Prop => forall x : cart R N', forall y : cart R N', forall u : R, forall v : R, ((@IN (cart R N') x _3365514) /\ ((@IN (cart R N') y _3365514) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> (Rle (R_of_N (NUMERAL 0%N)) (_3365513 (@vector_add N' (@percent N' u x) (@percent N' v y)))) /\ (Rle (_3365513 (@vector_add N' (@percent N' u x) (@percent N' v y))) (Rmult (rpow (_3365513 x) u) (rpow (_3365513 y) v))).
Lemma log_convex_on_def {N' : Type'} : (@log_convex_on N') = (fun _3365513 : (cart R N') -> R => fun _3365514 : (cart R N') -> Prop => forall x : cart R N', forall y : cart R N', forall u : R, forall v : R, ((@IN (cart R N') x _3365514) /\ ((@IN (cart R N') y _3365514) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> (Rle (R_of_N (NUMERAL 0%N)) (_3365513 (@vector_add N' (@percent N' u x) (@percent N' v y)))) /\ (Rle (_3365513 (@vector_add N' (@percent N' u x) (@percent N' v y))) (Rmult (rpow (_3365513 x) u) (rpow (_3365513 y) v)))).
Proof. exact (eq_refl (@log_convex_on N')). Qed.
Definition real_log_convex_on : (R -> R) -> (R -> Prop) -> Prop := fun _3366359 : R -> R => fun _3366360 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3366360) /\ ((@IN R y _3366360) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> (Rle (R_of_N (NUMERAL 0%N)) (_3366359 (Rplus (Rmult u x) (Rmult v y)))) /\ (Rle (_3366359 (Rplus (Rmult u x) (Rmult v y))) (Rmult (rpow (_3366359 x) u) (rpow (_3366359 y) v))).
Lemma real_log_convex_on_def : real_log_convex_on = (fun _3366359 : R -> R => fun _3366360 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3366360) /\ ((@IN R y _3366360) /\ ((Rle (R_of_N (NUMERAL 0%N)) u) /\ ((Rle (R_of_N (NUMERAL 0%N)) v) /\ ((Rplus u v) = (R_of_N (NUMERAL (BIT1 0%N)))))))) -> (Rle (R_of_N (NUMERAL 0%N)) (_3366359 (Rplus (Rmult u x) (Rmult v y)))) /\ (Rle (_3366359 (Rplus (Rmult u x) (Rmult v y))) (Rmult (rpow (_3366359 x) u) (rpow (_3366359 y) v)))).
Proof. exact (eq_refl real_log_convex_on). Qed.
Definition has_real_integral : (R -> R) -> R -> (R -> Prop) -> Prop := fun _3367240 : R -> R => fun _3367241 : R => fun _3367242 : R -> Prop => @has_integral unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3367240 drop)) (lift _3367241) (@IMAGE R (cart R unit) lift _3367242).
Lemma has_real_integral_def : has_real_integral = (fun _3367240 : R -> R => fun _3367241 : R => fun _3367242 : R -> Prop => @has_integral unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3367240 drop)) (lift _3367241) (@IMAGE R (cart R unit) lift _3367242)).
Proof. exact (eq_refl has_real_integral). Qed.
Definition real_integrable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3367261 : R -> R => fun _3367262 : R -> Prop => exists y : R, has_real_integral _3367261 y _3367262.
Lemma real_integrable_on_def : real_integrable_on = (fun _3367261 : R -> R => fun _3367262 : R -> Prop => exists y : R, has_real_integral _3367261 y _3367262).
Proof. exact (eq_refl real_integrable_on). Qed.
Definition real_integral : (R -> Prop) -> (R -> R) -> R := fun _3367273 : R -> Prop => fun _3367274 : R -> R => @ε R (fun y : R => has_real_integral _3367274 y _3367273).
Lemma real_integral_def : real_integral = (fun _3367273 : R -> Prop => fun _3367274 : R -> R => @ε R (fun y : R => has_real_integral _3367274 y _3367273)).
Proof. exact (eq_refl real_integral). Qed.
Definition real_negligible : (R -> Prop) -> Prop := fun _3367285 : R -> Prop => @negligible unit (@IMAGE R (cart R unit) lift _3367285).
Lemma real_negligible_def : real_negligible = (fun _3367285 : R -> Prop => @negligible unit (@IMAGE R (cart R unit) lift _3367285)).
Proof. exact (eq_refl real_negligible). Qed.
Definition absolutely_real_integrable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3367290 : R -> R => fun _3367291 : R -> Prop => (real_integrable_on _3367290 _3367291) /\ (real_integrable_on (fun x : R => Rabs (_3367290 x)) _3367291).
Lemma absolutely_real_integrable_on_def : absolutely_real_integrable_on = (fun _3367290 : R -> R => fun _3367291 : R -> Prop => (real_integrable_on _3367290 _3367291) /\ (real_integrable_on (fun x : R => Rabs (_3367290 x)) _3367291)).
Proof. exact (eq_refl absolutely_real_integrable_on). Qed.
Definition has_real_measure : (R -> Prop) -> R -> Prop := fun _3367302 : R -> Prop => fun _3367303 : R => has_real_integral (fun x : R => R_of_N (NUMERAL (BIT1 0%N))) _3367303 _3367302.
Lemma has_real_measure_def : has_real_measure = (fun _3367302 : R -> Prop => fun _3367303 : R => has_real_integral (fun x : R => R_of_N (NUMERAL (BIT1 0%N))) _3367303 _3367302).
Proof. exact (eq_refl has_real_measure). Qed.
Definition real_measurable : (R -> Prop) -> Prop := fun _3367314 : R -> Prop => exists m : R, has_real_measure _3367314 m.
Lemma real_measurable_def : real_measurable = (fun _3367314 : R -> Prop => exists m : R, has_real_measure _3367314 m).
Proof. exact (eq_refl real_measurable). Qed.
Definition real_measure : (R -> Prop) -> R := fun _3367319 : R -> Prop => @ε R (fun m : R => has_real_measure _3367319 m).
Lemma real_measure_def : real_measure = (fun _3367319 : R -> Prop => @ε R (fun m : R => has_real_measure _3367319 m)).
Proof. exact (eq_refl real_measure). Qed.
Definition slice {_1737277 _1737298 : Type'} : N -> R -> ((cart R _1737298) -> Prop) -> (cart R _1737277) -> Prop := fun _3373426 : N => fun _3373427 : R => fun _3373428 : (cart R _1737298) -> Prop => @IMAGE (cart R _1737298) (cart R _1737277) (@dropout _1737298 _1737277 _3373426) (@INTER (cart R _1737298) _3373428 (@GSPEC (cart R _1737298) (fun GEN_PVAR_8546 : cart R _1737298 => exists x : cart R _1737298, @SETSPEC (cart R _1737298) GEN_PVAR_8546 ((@dollar R _1737298 x _3373426) = _3373427) x))).
Lemma slice_def {_1737277 _1737298 : Type'} : (@slice _1737277 _1737298) = (fun _3373426 : N => fun _3373427 : R => fun _3373428 : (cart R _1737298) -> Prop => @IMAGE (cart R _1737298) (cart R _1737277) (@dropout _1737298 _1737277 _3373426) (@INTER (cart R _1737298) _3373428 (@GSPEC (cart R _1737298) (fun GEN_PVAR_8546 : cart R _1737298 => exists x : cart R _1737298, @SETSPEC (cart R _1737298) GEN_PVAR_8546 ((@dollar R _1737298 x _3373426) = _3373427) x)))).
Proof. exact (eq_refl (@slice _1737277 _1737298)). Qed.
Definition bernstein : N -> N -> R -> R := fun _3382684 : N => fun _3382685 : N => fun _3382686 : R => Rmult (R_of_N (binom (@pair N N _3382684 _3382685))) (Rmult (Rpow _3382686 _3382685) (Rpow (Rminus (R_of_N (NUMERAL (BIT1 0%N))) _3382686) (N.sub _3382684 _3382685))).
Lemma bernstein_def : bernstein = (fun _3382684 : N => fun _3382685 : N => fun _3382686 : R => Rmult (R_of_N (binom (@pair N N _3382684 _3382685))) (Rmult (Rpow _3382686 _3382685) (Rpow (Rminus (R_of_N (NUMERAL (BIT1 0%N))) _3382686) (N.sub _3382684 _3382685)))).
Proof. exact (eq_refl bernstein). Qed.
Definition real_polynomial_function {N' : Type'} : ((cart R N') -> R) -> Prop := fun a : (cart R N') -> R => forall real_polynomial_function' : ((cart R N') -> R) -> Prop, (forall a' : (cart R N') -> R, ((exists i : N, (a' = (fun x : cart R N' => @dollar R N' x i)) /\ ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N'))))) \/ ((exists c : R, a' = (fun x : cart R N' => c)) \/ ((exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => Rplus (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g))) \/ (exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => Rmult (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g)))))) -> real_polynomial_function' a') -> real_polynomial_function' a.
Lemma real_polynomial_function_def {N' : Type'} : (@real_polynomial_function N') = (fun a : (cart R N') -> R => forall real_polynomial_function' : ((cart R N') -> R) -> Prop, (forall a' : (cart R N') -> R, ((exists i : N, (a' = (fun x : cart R N' => @dollar R N' x i)) /\ ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N'))))) \/ ((exists c : R, a' = (fun x : cart R N' => c)) \/ ((exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => Rplus (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g))) \/ (exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => Rmult (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g)))))) -> real_polynomial_function' a') -> real_polynomial_function' a).
Proof. exact (eq_refl (@real_polynomial_function N')). Qed.
Definition vector_polynomial_function {M N' : Type'} : ((cart R M) -> cart R N') -> Prop := fun _3396120 : (cart R M) -> cart R N' => forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> @real_polynomial_function M (fun x : cart R M => @dollar R N' (_3396120 x) i).
Lemma vector_polynomial_function_def {M N' : Type'} : (@vector_polynomial_function M N') = (fun _3396120 : (cart R M) -> cart R N' => forall i : N, ((N.le (NUMERAL (BIT1 0%N)) i) /\ (N.le i (@dimindex N' (@UNIV N')))) -> @real_polynomial_function M (fun x : cart R M => @dollar R N' (_3396120 x) i)).
Proof. exact (eq_refl (@vector_polynomial_function M N')). Qed.
Definition bernoulli : N -> R -> R := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> R -> R) (fun bernoulli' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> R -> R => forall _3398909 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall x : R, (bernoulli' _3398909 (NUMERAL 0%N) x) = (R_of_N (NUMERAL (BIT1 0%N)))) /\ (forall n : N, forall x : R, (bernoulli' _3398909 (N.add n (NUMERAL (BIT1 0%N))) x) = (Rminus (Rpow x (N.add n (NUMERAL (BIT1 0%N)))) (Rdiv (@sum N (dotdot (NUMERAL 0%N) n) (fun k : N => Rmult (R_of_N (binom (@pair N N (N.add n (NUMERAL (BIT0 (BIT1 0%N)))) k))) (bernoulli' _3398909 k x))) (Rplus (R_of_N n) (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))).
Lemma bernoulli_def : bernoulli = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> R -> R) (fun bernoulli' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) -> N -> R -> R => forall _3398909 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))), (forall x : R, (bernoulli' _3398909 (NUMERAL 0%N) x) = (R_of_N (NUMERAL (BIT1 0%N)))) /\ (forall n : N, forall x : R, (bernoulli' _3398909 (N.add n (NUMERAL (BIT1 0%N))) x) = (Rminus (Rpow x (N.add n (NUMERAL (BIT1 0%N)))) (Rdiv (@sum N (dotdot (NUMERAL 0%N) n) (fun k : N => Rmult (R_of_N (binom (@pair N N (N.add n (NUMERAL (BIT0 (BIT1 0%N)))) k))) (bernoulli' _3398909 k x))) (Rplus (R_of_N n) (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))).
Proof. exact (eq_refl bernoulli). Qed.
Definition real_measurable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3400317 : R -> R => fun _3400318 : R -> Prop => @measurable_on unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3400317 drop)) (@IMAGE R (cart R unit) lift _3400318).
Lemma real_measurable_on_def : real_measurable_on = (fun _3400317 : R -> R => fun _3400318 : R -> Prop => @measurable_on unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3400317 drop)) (@IMAGE R (cart R unit) lift _3400318)).
Proof. exact (eq_refl real_measurable_on). Qed.
Definition real_lebesgue_measurable : (R -> Prop) -> Prop := fun _3400329 : R -> Prop => real_measurable_on (fun x : R => @COND R (@IN R x _3400329) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))) (@UNIV R).
Lemma real_lebesgue_measurable_def : real_lebesgue_measurable = (fun _3400329 : R -> Prop => real_measurable_on (fun x : R => @COND R (@IN R x _3400329) (R_of_N (NUMERAL (BIT1 0%N))) (R_of_N (NUMERAL 0%N))) (@UNIV R)).
Proof. exact (eq_refl real_lebesgue_measurable). Qed.
Definition has_bounded_real_variation_on : (R -> R) -> (R -> Prop) -> Prop := fun _3404260 : R -> R => fun _3404261 : R -> Prop => @has_bounded_variation_on unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3404260 drop)) (@IMAGE R (cart R unit) lift _3404261).
Lemma has_bounded_real_variation_on_def : has_bounded_real_variation_on = (fun _3404260 : R -> R => fun _3404261 : R -> Prop => @has_bounded_variation_on unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3404260 drop)) (@IMAGE R (cart R unit) lift _3404261)).
Proof. exact (eq_refl has_bounded_real_variation_on). Qed.
Definition real_variation : (R -> Prop) -> (R -> R) -> R := fun _3404272 : R -> Prop => fun _3404273 : R -> R => @vector_variation unit (@IMAGE R (cart R unit) lift _3404272) (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3404273 drop)).
Lemma real_variation_def : real_variation = (fun _3404272 : R -> Prop => fun _3404273 : R -> R => @vector_variation unit (@IMAGE R (cart R unit) lift _3404272) (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3404273 drop))).
Proof. exact (eq_refl real_variation). Qed.
Definition borsukian {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _3567376 : (cart R N') -> Prop => forall f : (cart R N') -> cart R (tybit0 unit), ((@continuous_on N' (tybit0 unit) f _3567376) /\ (@SUBSET (cart R (tybit0 unit)) (@IMAGE (cart R N') (cart R (tybit0 unit)) f _3567376) (@DIFF (cart R (tybit0 unit)) (@UNIV (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_N (NUMERAL 0%N))) (@EMPTY (cart R (tybit0 unit))))))) -> exists a : cart R (tybit0 unit), @homotopic_with (cart R (tybit0 unit)) (cart R N') (fun h : (cart R N') -> cart R (tybit0 unit) => True) (@pair (Topology (cart R N')) (Topology (cart R (tybit0 unit))) (@subtopology (cart R N') (@euclidean N') _3567376) (@subtopology (cart R (tybit0 unit)) (@euclidean (tybit0 unit)) (@DIFF (cart R (tybit0 unit)) (@UNIV (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_N (NUMERAL 0%N))) (@EMPTY (cart R (tybit0 unit))))))) f (fun x : cart R N' => a).
Lemma borsukian_def {N' : Type'} : (@borsukian N') = (fun _3567376 : (cart R N') -> Prop => forall f : (cart R N') -> cart R (tybit0 unit), ((@continuous_on N' (tybit0 unit) f _3567376) /\ (@SUBSET (cart R (tybit0 unit)) (@IMAGE (cart R N') (cart R (tybit0 unit)) f _3567376) (@DIFF (cart R (tybit0 unit)) (@UNIV (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_N (NUMERAL 0%N))) (@EMPTY (cart R (tybit0 unit))))))) -> exists a : cart R (tybit0 unit), @homotopic_with (cart R (tybit0 unit)) (cart R N') (fun h : (cart R N') -> cart R (tybit0 unit) => True) (@pair (Topology (cart R N')) (Topology (cart R (tybit0 unit))) (@subtopology (cart R N') (@euclidean N') _3567376) (@subtopology (cart R (tybit0 unit)) (@euclidean (tybit0 unit)) (@DIFF (cart R (tybit0 unit)) (@UNIV (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_N (NUMERAL 0%N))) (@EMPTY (cart R (tybit0 unit))))))) f (fun x : cart R N' => a)).
Proof. exact (eq_refl (@borsukian N')). Qed.
Definition unicoherent {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _3573850 : (cart R N') -> Prop => forall s : (cart R N') -> Prop, forall t : (cart R N') -> Prop, ((@connected N' s) /\ ((@connected N' t) /\ (((@UNION (cart R N') s t) = _3573850) /\ ((@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3573850) s) /\ (@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3573850) t))))) -> @connected N' (@INTER (cart R N') s t).
Lemma unicoherent_def {N' : Type'} : (@unicoherent N') = (fun _3573850 : (cart R N') -> Prop => forall s : (cart R N') -> Prop, forall t : (cart R N') -> Prop, ((@connected N' s) /\ ((@connected N' t) /\ (((@UNION (cart R N') s t) = _3573850) /\ ((@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3573850) s) /\ (@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3573850) t))))) -> @connected N' (@INTER (cart R N') s t)).
Proof. exact (eq_refl (@unicoherent N')). Qed.
Definition piecewise_differentiable_on {_1808913 _1808940 : Type'} : ((cart R _1808940) -> cart R _1808913) -> ((cart R _1808940) -> Prop) -> Prop := fun _3640062 : (cart R _1808940) -> cart R _1808913 => fun _3640063 : (cart R _1808940) -> Prop => (@continuous_on _1808940 _1808913 _3640062 _3640063) /\ (exists s : (cart R _1808940) -> Prop, (@FINITE (cart R _1808940) s) /\ (forall x : cart R _1808940, (@IN (cart R _1808940) x (@DIFF (cart R _1808940) _3640063 s)) -> @differentiable _1808913 _1808940 _3640062 (@_at _1808940 x))).
Lemma piecewise_differentiable_on_def {_1808913 _1808940 : Type'} : (@piecewise_differentiable_on _1808913 _1808940) = (fun _3640062 : (cart R _1808940) -> cart R _1808913 => fun _3640063 : (cart R _1808940) -> Prop => (@continuous_on _1808940 _1808913 _3640062 _3640063) /\ (exists s : (cart R _1808940) -> Prop, (@FINITE (cart R _1808940) s) /\ (forall x : cart R _1808940, (@IN (cart R _1808940) x (@DIFF (cart R _1808940) _3640063 s)) -> @differentiable _1808913 _1808940 _3640062 (@_at _1808940 x)))).
Proof. exact (eq_refl (@piecewise_differentiable_on _1808913 _1808940)). Qed.
Definition valid_path : ((cart R unit) -> cart R (tybit0 unit)) -> Prop := fun _3640825 : (cart R unit) -> cart R (tybit0 unit) => @piecewise_differentiable_on (tybit0 unit) unit _3640825 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))).
Lemma valid_path_def : valid_path = (fun _3640825 : (cart R unit) -> cart R (tybit0 unit) => @piecewise_differentiable_on (tybit0 unit) unit _3640825 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))).
Proof. exact (eq_refl valid_path). Qed.
Definition closed_path {_1809683 : Type'} : ((cart R unit) -> cart R _1809683) -> Prop := fun _3640830 : (cart R unit) -> cart R _1809683 => (@pathstart _1809683 _3640830) = (@pathfinish _1809683 _3640830).
Lemma closed_path_def {_1809683 : Type'} : (@closed_path _1809683) = (fun _3640830 : (cart R unit) -> cart R _1809683 => (@pathstart _1809683 _3640830) = (@pathfinish _1809683 _3640830)).
Proof. exact (eq_refl (@closed_path _1809683)). Qed.
Definition has_path_integral : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop := @ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop) (fun has_path_integral' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop => forall _3641459 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))), forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall i : cart R (tybit0 unit), forall g : (cart R unit) -> cart R (tybit0 unit), (has_path_integral' _3641459 f i g) = (@has_integral unit (tybit0 unit) (fun x : cart R unit => complex_mul (f (g x)) (@vector_derivative (tybit0 unit) g (@within (cart R unit) (@_at unit x) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))))) i (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))))))))))))))))))).
Lemma has_path_integral_def : has_path_integral = (@ε ((prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop) (fun has_path_integral' : (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop => forall _3641459 : prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))), forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall i : cart R (tybit0 unit), forall g : (cart R unit) -> cart R (tybit0 unit), (has_path_integral' _3641459 f i g) = (@has_integral unit (tybit0 unit) (fun x : cart R unit => complex_mul (f (g x)) (@vector_derivative (tybit0 unit) g (@within (cart R unit) (@_at unit x) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))))) i (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N (prod N N))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N (prod N N)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N (prod N N))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N (prod N N)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N (prod N N))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N (prod N N)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (@pair N (prod N N) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0%N)))))))) (@pair N N (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0%N)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0%N))))))))))))))))))))))))).
Proof. exact (eq_refl has_path_integral). Qed.
Definition path_integral : ((cart R unit) -> cart R (tybit0 unit)) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3641460 : (cart R unit) -> cart R (tybit0 unit) => fun _3641461 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun i : cart R (tybit0 unit) => has_path_integral _3641461 i _3641460).
Lemma path_integral_def : path_integral = (fun _3641460 : (cart R unit) -> cart R (tybit0 unit) => fun _3641461 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun i : cart R (tybit0 unit) => has_path_integral _3641461 i _3641460)).
Proof. exact (eq_refl path_integral). Qed.
Definition path_integrable_on : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop := fun _3641472 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3641473 : (cart R unit) -> cart R (tybit0 unit) => exists i : cart R (tybit0 unit), has_path_integral _3641472 i _3641473.
Lemma path_integrable_on_def : path_integrable_on = (fun _3641472 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3641473 : (cart R unit) -> cart R (tybit0 unit) => exists i : cart R (tybit0 unit), has_path_integral _3641472 i _3641473).
Proof. exact (eq_refl path_integrable_on). Qed.
Definition winding_number : (prod ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit))) -> cart R (tybit0 unit) := fun _3677625 : prod ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) => @ε (cart R (tybit0 unit)) (fun n : cart R (tybit0 unit) => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists p : (cart R unit) -> cart R (tybit0 unit), (valid_path p) /\ ((~ (@IN (cart R (tybit0 unit)) (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625) (@path_image (tybit0 unit) p))) /\ (((@pathstart (tybit0 unit) p) = (@pathstart (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625))) /\ (((@pathfinish (tybit0 unit) p) = (@pathfinish (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625))) /\ ((forall t : cart R unit, (@IN (cart R unit) t (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) -> Rlt (@vector_norm (tybit0 unit) (@vector_sub (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625 t) (p t))) e) /\ ((path_integral p (fun w : cart R (tybit0 unit) => complex_div (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (@vector_sub (tybit0 unit) w (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625)))) = (complex_mul (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))) (complex_mul (Cx pi) (complex_mul ii n))))))))).
Lemma winding_number_def : winding_number = (fun _3677625 : prod ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) => @ε (cart R (tybit0 unit)) (fun n : cart R (tybit0 unit) => forall e : R, (Rlt (R_of_N (NUMERAL 0%N)) e) -> exists p : (cart R unit) -> cart R (tybit0 unit), (valid_path p) /\ ((~ (@IN (cart R (tybit0 unit)) (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625) (@path_image (tybit0 unit) p))) /\ (((@pathstart (tybit0 unit) p) = (@pathstart (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625))) /\ (((@pathfinish (tybit0 unit) p) = (@pathfinish (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625))) /\ ((forall t : cart R unit, (@IN (cart R unit) t (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL 0%N)) (@vec unit (NUMERAL (BIT1 0%N)))) (@nil (prod (cart R unit) (cart R unit)))))) -> Rlt (@vector_norm (tybit0 unit) (@vector_sub (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625 t) (p t))) e) /\ ((path_integral p (fun w : cart R (tybit0 unit) => complex_div (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (@vector_sub (tybit0 unit) w (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3677625)))) = (complex_mul (Cx (R_of_N (NUMERAL (BIT0 (BIT1 0%N))))) (complex_mul (Cx pi) (complex_mul ii n)))))))))).
Proof. exact (eq_refl winding_number). Qed.
Definition complex_integer : (cart R (tybit0 unit)) -> Prop := fun _3681650 : cart R (tybit0 unit) => (integer (Re _3681650)) /\ ((Im _3681650) = (R_of_N (NUMERAL 0%N))).
Lemma complex_integer_def : complex_integer = (fun _3681650 : cart R (tybit0 unit) => (integer (Re _3681650)) /\ ((Im _3681650) = (R_of_N (NUMERAL 0%N)))).
Proof. exact (eq_refl complex_integer). Qed.
Definition partcirclepath : (prod (cart R (tybit0 unit)) (prod R (prod R R))) -> (cart R unit) -> cart R (tybit0 unit) := fun _3700031 : prod (cart R (tybit0 unit)) (prod R (prod R R)) => fun x : cart R unit => @vector_add (tybit0 unit) (@fst (cart R (tybit0 unit)) (prod R (prod R R)) _3700031) (complex_mul (Cx (@fst R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3700031))) (cexp (complex_mul ii (@linepath (tybit0 unit) (@pair (cart R (tybit0 unit)) (cart R (tybit0 unit)) (Cx (@fst R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3700031)))) (Cx (@snd R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3700031))))) x)))).
Lemma partcirclepath_def : partcirclepath = (fun _3700031 : prod (cart R (tybit0 unit)) (prod R (prod R R)) => fun x : cart R unit => @vector_add (tybit0 unit) (@fst (cart R (tybit0 unit)) (prod R (prod R R)) _3700031) (complex_mul (Cx (@fst R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3700031))) (cexp (complex_mul ii (@linepath (tybit0 unit) (@pair (cart R (tybit0 unit)) (cart R (tybit0 unit)) (Cx (@fst R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3700031)))) (Cx (@snd R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3700031))))) x))))).
Proof. exact (eq_refl partcirclepath). Qed.
Definition circlepath : (prod (cart R (tybit0 unit)) R) -> (cart R unit) -> cart R (tybit0 unit) := fun _3701090 : prod (cart R (tybit0 unit)) R => partcirclepath (@pair (cart R (tybit0 unit)) (prod R (prod R R)) (@fst (cart R (tybit0 unit)) R _3701090) (@pair R (prod R R) (@snd (cart R (tybit0 unit)) R _3701090) (@pair R R (R_of_N (NUMERAL 0%N)) (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) pi)))).
Lemma circlepath_def : circlepath = (fun _3701090 : prod (cart R (tybit0 unit)) R => partcirclepath (@pair (cart R (tybit0 unit)) (prod R (prod R R)) (@fst (cart R (tybit0 unit)) R _3701090) (@pair R (prod R R) (@snd (cart R (tybit0 unit)) R _3701090) (@pair R R (R_of_N (NUMERAL 0%N)) (Rmult (R_of_N (NUMERAL (BIT0 (BIT1 0%N)))) pi))))).
Proof. exact (eq_refl circlepath). Qed.
Definition moebius_function : R -> (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3777086 : R => fun _3777087 : cart R (tybit0 unit) => fun _3777088 : cart R (tybit0 unit) => complex_mul (cexp (complex_mul ii (Cx _3777086))) (complex_div (@vector_sub (tybit0 unit) _3777088 _3777087) (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_mul (cnj _3777087) _3777088))).
Lemma moebius_function_def : moebius_function = (fun _3777086 : R => fun _3777087 : cart R (tybit0 unit) => fun _3777088 : cart R (tybit0 unit) => complex_mul (cexp (complex_mul ii (Cx _3777086))) (complex_div (@vector_sub (tybit0 unit) _3777088 _3777087) (@vector_sub (tybit0 unit) (Cx (R_of_N (NUMERAL (BIT1 0%N)))) (complex_mul (cnj _3777087) _3777088)))).
Proof. exact (eq_refl moebius_function). Qed.
